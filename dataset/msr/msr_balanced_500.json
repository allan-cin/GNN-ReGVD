[{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"SeekHead::SeekHead(\n    Segment* pSegment,\n    long long start,\n    long long size_,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_start(start),\n    m_size(size_),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    m_entries(0),\n    m_entry_count(0),\n    m_void_elements(0),\n    m_void_element_count(0)\n{\n }\n","project":"Android","target":1},{"commit_id":"d4a34fefbf292d1e02336e4e272da3ef1e3eef85","func":"uint8_t rfc_parse_data(tRFC_MCB* p_mcb, MX_FRAME* p_frame, BT_HDR* p_buf) {\n uint8_t ead, eal, fcs;\n uint8_t* p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n uint8_t* p_start = p_data;\n uint16_t len;\n\n if (p_buf->len < RFCOMM_CTRL_FRAME_LEN) {\n    RFCOMM_TRACE_ERROR(\"Bad Length1: %d\", p_buf->len);\n return (RFC_EVENT_BAD_FRAME);\n }\n\n  RFCOMM_PARSE_CTRL_FIELD(ead, p_frame->cr, p_frame->dlci, p_data);\n if (!ead) {\n    RFCOMM_TRACE_ERROR(\"Bad Address(EA must be 1)\");\n return (RFC_EVENT_BAD_FRAME);\n }\n  RFCOMM_PARSE_TYPE_FIELD(p_frame->type, p_frame->pf, p_data);\n\n \n   eal = *(p_data)&RFCOMM_EA;\n   len = *(p_data)++ >> RFCOMM_SHIFT_LENGTH1;\n  if (eal == 0 && p_buf->len < RFCOMM_CTRL_FRAME_LEN) {\n     len += (*(p_data)++ << RFCOMM_SHIFT_LENGTH2);\n   } else if (eal == 0) {\n     RFCOMM_TRACE_ERROR(\"Bad Length when EAL = 0: %d\", p_buf->len);\n    android_errorWriteLog(0x534e4554, \"78288018\");\n return RFC_EVENT_BAD_FRAME;\n }\n\n  p_buf->len -= (3 + !ead + !eal + 1); \/* Additional 1 for FCS *\/\n  p_buf->offset += (3 + !ead + !eal);\n\n \/* handle credit if credit based flow control *\/\n if ((p_mcb->flow == PORT_FC_CREDIT) && (p_frame->type == RFCOMM_UIH) &&\n (p_frame->dlci != RFCOMM_MX_DLCI) && (p_frame->pf == 1)) {\n    p_frame->credit = *p_data++;\n    p_buf->len--;\n    p_buf->offset++;\n } else\n    p_frame->credit = 0;\n\n if (p_buf->len != len) {\n    RFCOMM_TRACE_ERROR(\"Bad Length2 %d %d\", p_buf->len, len);\n return (RFC_EVENT_BAD_FRAME);\n }\n\n  fcs = *(p_data + len);\n\n \/* All control frames that we are sending are sent with P=1, expect *\/\n \/* reply with F=1 *\/\n \/* According to TS 07.10 spec ivalid frames are discarded without *\/\n \/* notification to the sender *\/\n switch (p_frame->type) {\n case RFCOMM_SABME:\n if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) ||\n !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad SABME\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_SABME);\n\n case RFCOMM_UA:\n if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) ||\n !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad UA\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_UA);\n\n case RFCOMM_DM:\n if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) || len ||\n !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad DM\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_DM);\n\n case RFCOMM_DISC:\n if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) ||\n !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad DISC\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_DISC);\n\n case RFCOMM_UIH:\n if (!RFCOMM_VALID_DLCI(p_frame->dlci)) {\n        RFCOMM_TRACE_ERROR(\"Bad UIH - invalid DLCI\");\n return (RFC_EVENT_BAD_FRAME);\n } else if (!rfc_check_fcs(2, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad UIH - FCS\");\n return (RFC_EVENT_BAD_FRAME);\n } else if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr)) {\n \/* we assume that this is ok to allow bad implementations to work *\/\n        RFCOMM_TRACE_ERROR(\"Bad UIH - response\");\n return (RFC_EVENT_UIH);\n } else\n return (RFC_EVENT_UIH);\n }\n\n return (RFC_EVENT_BAD_FRAME);\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void SetUp() {\n     UUT_ = GET_PARAM(2);\n     \/* Set up guard blocks for an inner block centered in the outer block *\/\n     for (int i = 0; i < kOutputBufferSize; ++i) {\n       if (IsIndexInBorder(i))\n        output_[i] = 255;\n else\n        output_[i] = 0;\n\n     }\n \n     ::libvpx_test::ACMRandom prng;\n    for (int i = 0; i < kInputBufferSize; ++i)\n      input_[i] = prng.Rand8Extremes();\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void CuePoint::Load(IMkvReader* pReader)\n{\n \n    if (m_timecode >= 0)  \/\/already loaded\n        return;\n \n    assert(m_track_positions == NULL);\n    assert(m_track_positions_count == 0);\n \n    long long pos_ = -m_timecode;\n    const long long element_start = pos_;\n \n    long long stop;\n \n    {\n        long len;\n \n        const long long id = ReadUInt(pReader, pos_, len);\n        assert(id == 0x3B);  \/\/CuePoint ID\n        if (id != 0x3B)\n            return;\n \n        pos_ += len;  \/\/consume ID\n \n        const long long size = ReadUInt(pReader, pos_, len);\n        assert(size >= 0);\n \n        pos_ += len;  \/\/consume Size field\n \n        stop = pos_ + size;\n     }\n \n    const long long element_size = stop - element_start;\n \n    long long pos = pos_;\n \n    while (pos < stop)\n    {\n        long len;\n        const long long id = ReadUInt(pReader, pos, len);\n        assert(id >= 0);  \/\/TODO\n        assert((pos + len) <= stop);\n        pos += len;  \/\/consume ID\n        const long long size = ReadUInt(pReader, pos, len);\n        assert(size >= 0);\n        assert((pos + len) <= stop);\n        pos += len;  \/\/consume Size field\n        assert((pos + size) <= stop);\n        if (id == 0x33)  \/\/CueTime ID\n            m_timecode = UnserializeUInt(pReader, pos, size);\n        else if (id == 0x37) \/\/CueTrackPosition(s) ID\n            ++m_track_positions_count;\n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n    }\n    assert(m_timecode >= 0);\n    assert(m_track_positions_count > 0);\n    m_track_positions = new TrackPosition[m_track_positions_count];\n    TrackPosition* p = m_track_positions;\n    pos = pos_;\n    while (pos < stop)\n    {\n        long len;\n        const long long id = ReadUInt(pReader, pos, len);\n        assert(id >= 0);  \/\/TODO\n        assert((pos + len) <= stop);\n        pos += len;  \/\/consume ID\n        const long long size = ReadUInt(pReader, pos, len);\n        assert(size >= 0);\n        assert((pos + len) <= stop);\n        pos += len;  \/\/consume Size field\n        assert((pos + size) <= stop);\n        if (id == 0x37) \/\/CueTrackPosition(s) ID\n        {\n            TrackPosition& tp = *p++;\n            tp.Parse(pReader, pos, size);\n        }\n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n    }\n    assert(size_t(p - m_track_positions) == m_track_positions_count);\n    m_element_start = element_start;\n    m_element_size = element_size;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   SvcTest()\n       : codec_iface_(0),\n         test_file_name_(\"hantro_collage_w352h288.yuv\"),\n        stats_file_name_(\"hantro_collage_w352h288.stat\"),\n         codec_initialized_(false),\n         decoder_(0) {\n     memset(&svc_, 0, sizeof(svc_));\n    memset(&codec_, 0, sizeof(codec_));\n    memset(&codec_enc_, 0, sizeof(codec_enc_));\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"unsigned long long Track::GetUid() const\n{\n    return m_info.uid;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n #if WRITE_COMPRESSED_STREAM\n     ++out_frames_;\n \n if (pkt->data.frame.pts == 0)\n      write_ivf_file_header(&cfg_, 0, outfile_);\n\n\n     write_ivf_frame_header(pkt, outfile_);\n     (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);\n#endif\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long SegmentInfo::GetDuration() const\n{\n    if (m_duration < 0)\n        return -1;\n    assert(m_timecodeScale >= 1);\n    const double dd = double(m_duration) * double(m_timecodeScale);\n    const long long d = static_cast<long long>(dd);\n    return d;\n}\n","project":"Android","target":1},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"void acl_perm_str(acl_entry_t entry, char *str)\n{\n\tacl_permset_t permset;\n\tint n;\n\n\tacl_get_permset(entry, &permset);\n\tfor (n = 0; n < (int) ACL_PERMS; n++) {\n\t\tstr[n] = (acl_get_perm(permset, acl_perm_defs[n].tag) ?\n\t\t          acl_perm_defs[n].c : '-');\n\t}\n\tstr[n] = '\\0';\n}\n","project":"savannah","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_x509_export)\n{\n\tX509 * cert;\n\tzval ** zcert, *zout;\n\tzend_bool notext = 1;\n\tBIO * bio_out;\n\tlong certresource;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zz|b\", &zcert, &zout, &notext) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get cert from parameter 1\");\n\t\treturn;\n\t}\n\n\tbio_out = BIO_new(BIO_s_mem());\n\tif (!notext) {\n\t\tX509_print(bio_out, cert);\n\t}\n\tif (PEM_write_bio_X509(bio_out, cert))  {\n\t\tBUF_MEM *bio_buf;\n\n\t\tzval_dtor(zout);\n\t\tBIO_get_mem_ptr(bio_out, &bio_buf);\n\t\tZVAL_STRINGL(zout, bio_buf->data, bio_buf->length, 1);\n\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (certresource == -1 && cert) {\n\t\tX509_free(cert);\n\t}\n\tBIO_free(bio_out);\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long ContentEncoding::ParseEncryptionEntry(\n    long long start,\n    long long size,\n    IMkvReader* pReader,\n    ContentEncryption* encryption) {\n   assert(pReader);\n   assert(encryption);\n \n long long pos = start;\n const long long stop = start + size;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  \/\/error\n       return status;\n \n     if (id == 0x7E1) {\n      encryption->algo = UnserializeUInt(pReader, pos, size);\n if (encryption->algo != 5)\n\n         return E_FILE_FORMAT_INVALID;\n     } else if (id == 0x7E2) {\n      delete[] encryption->key_id;\n       encryption->key_id = NULL;\n       encryption->key_id_len = 0;\n \n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      encryption->key_id = buf;\n\n       encryption->key_id_len = buflen;\n     } else if (id == 0x7E3) {\n      delete[] encryption->signature;\n       encryption->signature = NULL;\n       encryption->signature_len = 0;\n \n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      encryption->signature = buf;\n\n       encryption->signature_len = buflen;\n     } else if (id == 0x7E4) {\n      delete[] encryption->sig_key_id;\n       encryption->sig_key_id = NULL;\n       encryption->sig_key_id_len = 0;\n \n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      encryption->sig_key_id = buf;\n      encryption->sig_key_id_len = buflen;\n } else if (id == 0x7E5) {\n      encryption->sig_algo = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x7E6) {\n      encryption->sig_hash_algo = UnserializeUInt(pReader, pos, size);\n\n     } else if (id == 0x7E7) {\n       const long status = ParseContentEncAESSettingsEntry(\n          pos,\n          size,\n          pReader,\n          &encryption->aes_settings);\n       if (status)\n         return status;\n     }\n \n    pos += size;  \/\/consume payload\n     assert(pos <= stop);\n   }\n \n   return 0;\n }\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool id_exists;\n\tuint32_t msds_intid;\n\tint32_t system_flags;\n\tstruct ldb_context *ldb;\n\tstruct ldb_result *ldb_res;\n\tstruct ldb_dn *schema_dn;\n\tstruct samldb_msds_intid_persistant *msds_intid_struct;\n\tstruct dsdb_schema *schema;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\t\/* replicated update should always go through *\/\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* msDS-IntId is handled by system and should never be\n\t * passed by clients *\/\n\tif (ldb_msg_find_element(ac->msg, \"msDS-IntId\")) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t\/* do not generate msDS-IntId if Relax control is passed *\/\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* check Functional Level *\/\n\tif (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* check systemFlags for SCHEMA_BASE_OBJECT flag *\/\n\tsystem_flags = ldb_msg_find_attr_as_int(ac->msg, \"systemFlags\", 0);\n\tif (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tmsds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);\n\tif (!msds_intid_struct) {\n\t\tmsds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);\n\t\t\/* Generate new value for msDs-IntId\n\t\t* Value should be in 0x80000000..0xBFFFFFFF range *\/\n\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\tmsds_intid += 0x80000000;\n\t\tmsds_intid_struct->msds_intid = msds_intid;\n\t\tmsds_intid_struct->usn = schema->loaded_usn;\n\t\tDEBUG(2, (\"No samldb_msds_intid_persistant struct, allocating a new one\\n\"));\n\t} else {\n\t\tmsds_intid = msds_intid_struct->msds_intid;\n\t}\n\n\t\/* probe id values until unique one is found *\/\n\tdo {\n\t\tuint64_t current_usn;\n\t\tmsds_intid++;\n\t\tif (msds_intid > 0xBFFFFFFF) {\n\t\t\tmsds_intid = 0x80000001;\n\t\t}\n\t\t\/*\n\t\t * Alternative strategy to a costly (even indexed search) to the\n\t\t * database.\n\t\t * We search in the schema if we have already this intid (using dsdb_attribute_by_attributeID_id because\n\t\t * in the range 0x80000000 0xBFFFFFFFF, attributeID is a DSDB_ATTID_TYPE_INTID).\n\t\t * If so generate another random value.\n\t\t * If not check if the highest USN in the database for the schema partition is the\n\t\t * one that we know.\n\t\t * If so it means that's only this ldb context that is touching the schema in the database.\n\t\t * If not it means that's someone else has modified the database while we are doing our changes too\n\t\t * (this case should be very bery rare) in order to be sure do the search in the database.\n\t\t *\/\n\t\tif (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {\n\t\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\t\tmsds_intid += 0x80000000;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = dsdb_module_load_partition_usn(ac->module, schema_dn,\n\t\t\t\t\t\t     &current_usn, NULL, NULL);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t      __location__\": Searching for schema USN failed: %s\\n\",\n\t\t\t\t      ldb_errstring(ldb));\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\n\t\t\/* current_usn can be lesser than msds_intid_struct-> if there is\n\t\t * uncommited changes.\n\t\t *\/\n\t\tif (current_usn > msds_intid_struct->usn) {\n\t\t\t\/* oups something has changed, someone\/something\n\t\t\t * else is modifying or has modified the schema\n\t\t\t * we'd better check this intid is the database directly\n\t\t\t *\/\n\n\t\t\tDEBUG(2, (\"Schema has changed, searching the database for the unicity of %d\\n\",\n\t\t\t\t\tmsds_intid));\n\n\t\t\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t\t\t&ldb_res,\n\t\t\t\t\t\tschema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t\t\tDSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t\tac->req,\n\t\t\t\t\t\t\"(msDS-IntId=%d)\", msds_intid);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t\t__location__\": Searching for msDS-IntId=%d failed - %s\\n\",\n\t\t\t\t\tmsds_intid,\n\t\t\t\t\tldb_errstring(ldb));\n\t\t\t\treturn ldb_operr(ldb);\n\t\t\t}\n\t\t\tid_exists = (ldb_res->count > 0);\n\t\t\ttalloc_free(ldb_res);\n\t\t} else {\n\t\t\tid_exists = 0;\n\t\t}\n\n\t} while(id_exists);\n\tmsds_intid_struct->msds_intid = msds_intid;\n\tldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);\n\n\treturn samdb_msg_add_int(ldb, ac->msg, ac->msg, \"msDS-IntId\",\n\t\t\t\t msds_intid);\n}\n","project":"samba","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Track::EOSBlock::EOSBlock() :\n    BlockEntry(NULL, LONG_MIN)\n{\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkey_export_to_file)\n{\n\tstruct php_x509_request req;\n\tzval ** zpkey, * args = NULL;\n\tchar * passphrase = NULL; int passphrase_len = 0;\n\tchar * filename = NULL; int filename_len = 0;\n\tlong key_resource = -1;\n\tEVP_PKEY * key;\n\tBIO * bio_out = NULL;\n\tconst EVP_CIPHER * cipher;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zs|s!a!\", &zpkey, &filename, &filename_len, &passphrase, &passphrase_len, &args) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tif (strlen(filename) != filename_len) {\n\t\treturn;\n\t}\n\n\tkey = php_openssl_evp_from_zval(zpkey, 0, passphrase, 0, &key_resource TSRMLS_CC);\n\n\tif (key == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get key from parameter 1\");\n\t\tRETURN_FALSE;\n\t}\n\t\n\tif (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\tPHP_SSL_REQ_INIT(&req);\n\n\tif (PHP_SSL_REQ_PARSE(&req, args) == SUCCESS) {\n\t\tbio_out = BIO_new_file(filename, \"w\");\n\n\t\tif (passphrase && req.priv_key_encrypt) {\n\t\t\tcipher = (EVP_CIPHER *) EVP_des_ede3_cbc();\n\t\t} else {\n\t\t\tcipher = NULL;\n\t\t}\n\t\tif (PEM_write_bio_PrivateKey(bio_out, key, cipher, (unsigned char *)passphrase, passphrase_len, NULL, NULL)) {\n\t\t\t\/* Success!\n\t\t\t * If returning the output as a string, do so now *\/\n\t\t\tRETVAL_TRUE;\n\t\t}\n\t}\n\tPHP_SSL_REQ_DISPOSE(&req);\n\n\tif (key_resource == -1 && key) {\n\t\tEVP_PKEY_free(key);\n\t}\n\tif (bio_out) {\n\t\tBIO_free(bio_out);\n\t}\n}\n","project":"php","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_FUNCTION(preg_split)\n{\n\tchar\t\t\t\t*regex;\t\t\t\/* Regular expression *\/\n\tchar\t\t\t\t*subject;\t\t\/* String to match against *\/\n\tint\t\t\t\t\t regex_len;\n\tint\t\t\t\t\t subject_len;\n\tlong\t\t\t\t limit_val = -1;\/* Integer value of limit *\/\n\tlong\t\t\t\t flags = 0;\t\t\/* Match control flags *\/\n\tpcre_cache_entry\t*pce;\t\t\t\/* Compiled regular expression *\/\n\n\t\/* Get function parameters and do error checking *\/\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|ll\", &regex, &regex_len,\n\t\t\t\t\t\t\t  &subject, &subject_len, &limit_val, &flags) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\t\/* Compile regex or get it from cache. *\/\n\tif ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_pcre_split_impl(pce, subject, subject_len, return_value, limit_val, flags TSRMLS_CC);\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Cluster* Segment::FindOrPreloadCluster(long long requested_pos)\n{\n    if (requested_pos < 0)\n        return 0;\n \n    Cluster** const ii = m_clusters;\n    Cluster** i = ii;\n \n    const long count = m_clusterCount + m_clusterPreloadCount;\n \n    Cluster** const jj = ii + count;\n    Cluster** j = jj;\n \n    while (i < j)\n    {\n \n        Cluster** const k = i + (j - i) \/ 2;\n        assert(k < jj);\n        Cluster* const pCluster = *k;\n        assert(pCluster);\n        const long long pos = pCluster->GetPosition();\n        assert(pos >= 0);\n        if (pos < requested_pos)\n            i = k + 1;\n        else if (pos > requested_pos)\n            j = k;\n        else\n            return pCluster;\n    }\n    assert(i == j);\n    Cluster* const pCluster = Cluster::Create(\n                                this,\n                                -1,\n                                requested_pos);\n     assert(pCluster);\n \n    const ptrdiff_t idx = i - m_clusters;\n \n    PreloadCluster(pCluster, idx);\n    assert(m_clusters);\n    assert(m_clusterPreloadCount > 0);\n    assert(m_clusters[idx] == pCluster);\n \n    return pCluster;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Chapters::ParseEdition(\n    long long pos,\n    long long size)\n{\n    if (!ExpandEditionsArray())\n        return -1;\n \n    Edition& e = m_editions[m_editions_count++];\n    e.Init();\n    return e.Parse(m_pSegment->m_pReader, pos, size);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_keep_default_colorspaces(fz_context *ctx, fz_default_colorspaces *default_cs)\n{\n\treturn fz_keep_imp(ctx, default_cs, &default_cs->refs);\n}\n","project":"ghostscript","target":0},{"commit_id":"2c75e1c3b98e4e94f50c63e2b7694be5f948477c","func":"status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n        OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {\n Mutex::Autolock autoLock(mLock);\n\n if (getGraphicBufferSource() != NULL) {\n        android_errorWriteLog(0x534e4554, \"29422020\");\n return INVALID_OPERATION;\n }\n\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, kPortIndexInput);\n if (header == NULL) {\n        ALOGE(\"b\/25884056\");\n return BAD_VALUE;\n\n     }\n     BufferMeta *buffer_meta =\n         static_cast<BufferMeta *>(header->pAppPrivate);\n    sp<ABuffer> backup = buffer_meta->getBuffer(header, true \/* backup *\/, false \/* limit *\/);\n    sp<ABuffer> codec = buffer_meta->getBuffer(header, false \/* backup *\/, false \/* limit *\/);\n \n    if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource\n            && backup->capacity() >= sizeof(VideoNativeMetadata)\n            && codec->capacity() >= sizeof(VideoGrallocMetadata)\n            && ((VideoNativeMetadata *)backup->base())->eType\n                    == kMetadataBufferTypeANWBuffer) {\n        VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();\n        VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();\n        CLOG_BUFFER(emptyBuffer, \"converting ANWB %p to handle %p\",\n                backupMeta.pBuffer, backupMeta.pBuffer->handle);\n        codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;\n        codecMeta.eType = kMetadataBufferTypeGrallocSource;\n        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;\n         header->nOffset = 0;\n     } else {\n if (rangeOffset > header->nAllocLen\n || rangeLength > header->nAllocLen - rangeOffset) {\n            CLOG_ERROR(emptyBuffer, OMX_ErrorBadParameter, FULL_BUFFER(NULL, header, fenceFd));\n if (fenceFd >= 0) {\n ::close(fenceFd);\n }\n return BAD_VALUE;\n }\n        header->nFilledLen = rangeLength;\n        header->nOffset = rangeOffset;\n\n        buffer_meta->CopyToOMX(header);\n }\n\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer, fenceFd);\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_flush_text(fz_context *ctx, pdf_run_processor *pr)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tfz_text *text;\n\tint dofill;\n\tint dostroke;\n\tint doclip;\n\tint doinvisible;\n\tsoftmask_save softmask = { NULL };\n\tint knockout_group = 0;\n\n\ttext = pdf_tos_get_text(ctx, &pr->tos);\n\tif (!text)\n\t\treturn gstate;\n\n\tdofill = dostroke = doclip = doinvisible = 0;\n\tswitch (pr->tos.text_mode)\n\t{\n\tcase 0: dofill = 1; break;\n\tcase 1: dostroke = 1; break;\n\tcase 2: dofill = dostroke = 1; break;\n\tcase 3: doinvisible = 1; break;\n\tcase 4: dofill = doclip = 1; break;\n\tcase 5: dostroke = doclip = 1; break;\n\tcase 6: dofill = dostroke = doclip = 1; break;\n\tcase 7: doclip = 1; break;\n\t}\n\n\tif (pr->super.hidden)\n\t\tdostroke = dofill = 0;\n\n\tfz_try(ctx)\n\t{\n\t\tfz_rect tb = pr->tos.text_bbox;\n\n\t\tfz_transform_rect(&tb, &gstate->ctm);\n\t\tif (dostroke)\n\t\t\tfz_adjust_rect_for_stroke(ctx, &tb, gstate->stroke_state, &gstate->ctm);\n\n\t\t\/* Don't bother sending a text group with nothing in it *\/\n\t\tif (!text->head)\n\t\t\tbreak;\n\n\t\tif (dofill || dostroke)\n\t\t\tgstate = pdf_begin_group(ctx, pr, &tb, &softmask);\n\n\t\tif (dofill && dostroke)\n\t\t{\n\t\t\t\/* We may need to push a knockout group *\/\n\t\t\tif (gstate->stroke.alpha == 0)\n\t\t\t{\n\t\t\t\t\/* No need for group, as stroke won't do anything *\/\n\t\t\t}\n\t\t\telse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n\t\t\t{\n\t\t\t\t\/* No need for group, as stroke won't show up *\/\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tknockout_group = 1;\n\t\t\t\tfz_begin_group(ctx, pr->dev, &tb, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (doinvisible)\n\t\t\tfz_ignore_text(ctx, pr->dev, text, &gstate->ctm);\n\n\t\tif (dofill)\n\t\t{\n\t\t\tswitch (gstate->fill.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_fill_text(ctx, pr->dev, text, &gstate->ctm,\n\t\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->fill.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_text(ctx, pr->dev, text, &gstate->ctm, &tb);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &tb, PDF_FILL);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->fill.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_text(ctx, pr->dev, text, &gstate->ctm, &tb);\n\t\t\t\t\t\/* Page 2 of patterns.pdf shows that fz_fill_shade should NOT be called with gstate->ctm *\/\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dostroke)\n\t\t{\n\t\t\tswitch (gstate->stroke.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_stroke_text(ctx, pr->dev, text, gstate->stroke_state, &gstate->ctm,\n\t\t\t\t\tgstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->stroke.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_text(ctx, pr->dev, text, gstate->stroke_state, &gstate->ctm, &tb);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &tb, PDF_STROKE);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->stroke.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_text(ctx, pr->dev, text, gstate->stroke_state, &gstate->ctm, &tb);\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (knockout_group)\n\t\t\tfz_end_group(ctx, pr->dev);\n\n\t\tif (dofill || dostroke)\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\n\t\tif (doclip)\n\t\t{\n\t\t\tgstate->clip_depth++;\n\t\t\tfz_clip_text(ctx, pr->dev, text, &gstate->ctm, &tb);\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_text(ctx, text);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n\n\treturn pr->gstate + pr->gtop;\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_x509_checkpurpose)\n{\n\tzval ** zcert, * zcainfo = NULL;\n\tX509_STORE * cainfo = NULL;\n\tX509 * cert = NULL;\n\tlong certresource = -1;\n\tSTACK_OF(X509) * untrustedchain = NULL;\n\tlong purpose;\n\tchar * untrusted = NULL;\n\tint untrusted_len = 0, ret;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zl|a!s\", &zcert, &purpose, &zcainfo, &untrusted, &untrusted_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETVAL_LONG(-1);\n\n\tif (untrusted) {\n\t\tuntrustedchain = load_all_certs_from_file(untrusted);\n\t\tif (untrustedchain == NULL) {\n\t\t\tgoto clean_exit;\n\t\t}\n\t}\n\n\tcainfo = setup_verify(zcainfo TSRMLS_CC);\n\tif (cainfo == NULL) {\n\t\tgoto clean_exit;\n\t}\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tgoto clean_exit;\n\t}\n\n\tret = check_cert(cainfo, cert, untrustedchain, purpose);\n\tif (ret != 0 && ret != 1) {\n\t\tRETVAL_LONG(ret);\n\t} else {\n\t\tRETVAL_BOOL(ret);\n\t}\n\nclean_exit:\n\tif (certresource == 1 && cert) {\n\t\tX509_free(cert);\n\t}\n\tif (cainfo) { \n\t\tX509_STORE_free(cainfo); \n\t}\n\tif (untrustedchain) {\n\t\tsk_X509_pop_free(untrustedchain, X509_free);\n\t}\n}\n","project":"php","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_drop_run_processor(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\n\twhile (pr->gtop)\n\t\tpdf_grestore(ctx, pr);\n\n\tpdf_drop_material(ctx, &pr->gstate[0].fill);\n\tpdf_drop_material(ctx, &pr->gstate[0].stroke);\n\tpdf_drop_font(ctx, pr->gstate[0].text.font);\n\tpdf_drop_xobject(ctx, pr->gstate[0].softmask);\n\tfz_drop_stroke_state(ctx, pr->gstate[0].stroke_state);\n\n\twhile (pr->gstate[0].clip_depth--)\n\t\tfz_pop_clip(ctx, pr->dev);\n\n\tfz_drop_path(ctx, pr->path);\n\tfz_drop_text(ctx, pr->tos.text);\n\n\tfz_drop_default_colorspaces(ctx, pr->default_cs);\n\n\tfz_free(ctx, pr->gstate);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_clamp_color(fz_context *ctx, const fz_colorspace *cs, const float *in, float *out)\n{\n\tcs->clamp(cs, in, out);\n}\n","project":"ghostscript","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_FUNCTION(preg_last_error)\n{\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"\") == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(PCRE_G(error_code));\n}\n","project":"php","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static void pcre_handle_exec_error(int pcre_code TSRMLS_DC) \/* {{{ *\/\n{\n\tint preg_code = 0;\n\n\tswitch (pcre_code) {\n\t\tcase PCRE_ERROR_MATCHLIMIT:\n\t\t\tpreg_code = PHP_PCRE_BACKTRACK_LIMIT_ERROR;\n\t\t\tbreak;\n\n\t\tcase PCRE_ERROR_RECURSIONLIMIT:\n\t\t\tpreg_code = PHP_PCRE_RECURSION_LIMIT_ERROR;\n\t\t\tbreak;\n\n\t\tcase PCRE_ERROR_BADUTF8:\n\t\t\tpreg_code = PHP_PCRE_BAD_UTF8_ERROR;\n\t\t\tbreak;\n\n\t\tcase PCRE_ERROR_BADUTF8_OFFSET:\n\t\t\tpreg_code = PHP_PCRE_BAD_UTF8_OFFSET_ERROR;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpreg_code = PHP_PCRE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\tPCRE_G(error_code) = preg_code;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Chapters::Display::ShallowCopy(Display& rhs) const\n{\n    rhs.m_string = m_string;\n    rhs.m_language = m_language;\n    rhs.m_country = m_country;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void SetUp() {\n    const tuple<int, int, SubpelVarianceFunctionType>& params =\n        this->GetParam();\n     log2width_  = get<0>(params);\n     width_ = 1 << log2width_;\n     log2height_ = get<1>(params);\n     height_ = 1 << log2height_;\n    subpel_variance_ = get<2>(params);\n \n     rnd(ACMRandom::DeterministicSeed());\n     block_size_ = width_ * height_;\n     src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\n    sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));\n    ref_ = new uint8_t[block_size_ + width_ + height_ + 1];\n     ASSERT_TRUE(src_ != NULL);\n    ASSERT_TRUE(sec_ != NULL);\n     ASSERT_TRUE(ref_ != NULL);\n   }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n VpxVideoReader *reader = NULL;\n const VpxInterface *decoder = NULL;\n const VpxVideoInfo *info = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 3)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing.\", argv[2]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n     die_codec(&codec, \"Failed to initialize decoder.\");\n \n   while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))\n      die_codec(&codec, \"Failed to decode frame.\");\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {\n      vpx_img_write(img, outfile);\n ++frame_cnt;\n }\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec\");\n\n  printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\",\n         info->frame_width, info->frame_height, argv[2]);\n\n  vpx_video_reader_close(reader);\n\n  fclose(outfile);\n\n return EXIT_SUCCESS;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int openssl_x509v3_subjectAltName(BIO *bio, X509_EXTENSION *extension)\n{\n\tGENERAL_NAMES *names;\n\tconst X509V3_EXT_METHOD *method = NULL;\n\tlong i, length, num;\n\tconst unsigned char *p;\n\n\tmethod = X509V3_EXT_get(extension);\n\tif (method == NULL) {\n\t\treturn -1;\n\t}\n\n\tp = extension->value->data;\n\tlength = extension->value->length;\n\tif (method->it) {\n\t\tnames = (GENERAL_NAMES*)(ASN1_item_d2i(NULL, &p, length,\n\t\t\t\t\t\t       ASN1_ITEM_ptr(method->it)));\n\t} else {\n\t\tnames = (GENERAL_NAMES*)(method->d2i(NULL, &p, length));\n\t}\n\tif (names == NULL) {\n\t\treturn -1;\n\t}\n\n\tnum = sk_GENERAL_NAME_num(names);\n\tfor (i = 0; i < num; i++) {\n\t\t\tGENERAL_NAME *name;\n\t\t\tASN1_STRING *as;\n\t\t\tname = sk_GENERAL_NAME_value(names, i);\n\t\t\tswitch (name->type) {\n\t\t\t\tcase GEN_EMAIL:\n\t\t\t\t\tBIO_puts(bio, \"email:\");\n\t\t\t\t\tas = name->d.rfc822Name;\n\t\t\t\t\tBIO_write(bio, ASN1_STRING_data(as),\n\t\t\t\t\t\t  ASN1_STRING_length(as));\n\t\t\t\t\tbreak;\n\t\t\t\tcase GEN_DNS:\n\t\t\t\t\tBIO_puts(bio, \"DNS:\");\n\t\t\t\t\tas = name->d.dNSName;\n\t\t\t\t\tBIO_write(bio, ASN1_STRING_data(as),\n\t\t\t\t\t\t  ASN1_STRING_length(as));\n\t\t\t\t\tbreak;\n\t\t\t\tcase GEN_URI:\n\t\t\t\t\tBIO_puts(bio, \"URI:\");\n\t\t\t\t\tas = name->d.uniformResourceIdentifier;\n\t\t\t\t\tBIO_write(bio, ASN1_STRING_data(as),\n\t\t\t\t\t\t  ASN1_STRING_length(as));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t\/* use builtin print for GEN_OTHERNAME, GEN_X400,\n\t\t\t\t\t * GEN_EDIPARTY, GEN_DIRNAME, GEN_IPADD and GEN_RID\n\t\t\t\t\t *\/\n\t\t\t\t\tGENERAL_NAME_print(bio, name);\n\t\t\t}\n\t\t\t\/* trailing ', ' except for last element *\/\n\t\t\tif (i < (num - 1)) {\n\t\t\t\tBIO_puts(bio, \", \");\n\t\t\t}\n\t}\n\tsk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);\n\n\treturn 0;\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void SADs(unsigned int *results) {\n    const uint8_t* refs[] = {GetReference(0), GetReference(1),\n                             GetReference(2), GetReference(3)};\n \n    REGISTER_STATE_CHECK(GET_PARAM(2)(source_data_, source_stride_,\n                                      refs, reference_stride_,\n                                      results));\n   }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" int main(int argc, char **argv) {\n   FILE *infile = NULL;\n  VpxVideoWriter *writer = NULL;\n   vpx_codec_ctx_t codec;\n   vpx_codec_enc_cfg_t cfg;\n   vpx_image_t raw;\n   vpx_codec_err_t res;\n  vpx_fixed_buf_t stats = {0};\n  VpxVideoInfo info = {0};\n   const VpxInterface *encoder = NULL;\n  int pass;\n   const int fps = 30;        \/\/ TODO(dkovalev) add command line argument\n   const int bitrate = 200;   \/\/ kbit\/s TODO(dkovalev) add command line argument\n   const char *const codec_arg = argv[1];\n const char *const width_arg = argv[2];\n const char *const height_arg = argv[3];\n const char *const infile_arg = argv[4];\n const char *const outfile_arg = argv[5];\n  exec_name = argv[0];\n\n if (argc != 6)\n    die(\"Invalid number of arguments.\");\n\n  encoder = get_vpx_encoder_by_name(codec_arg);\n\n   if (!encoder)\n     die(\"Unsupported codec.\");\n \n  info.codec_fourcc = encoder->fourcc;\n  info.time_base.numerator = 1;\n  info.time_base.denominator = fps;\n  info.frame_width = strtol(width_arg, NULL, 0);\n  info.frame_height = strtol(height_arg, NULL, 0);\n \n  if (info.frame_width <= 0 ||\n      info.frame_height <= 0 ||\n      (info.frame_width % 2) != 0 ||\n      (info.frame_height % 2) != 0) {\n    die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);\n  }\n \n  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n                                             info.frame_height, 1)) {\n    die(\"Failed to allocate image\", info.frame_width, info.frame_height);\n  }\n \n  writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);\n  if (!writer)\n    die(\"Failed to open %s for writing\", outfile_arg);\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));\n  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \"Failed to get default codec config.\");\n \n  cfg.g_w = info.frame_width;\n  cfg.g_h = info.frame_height;\n  cfg.g_timebase.num = info.time_base.numerator;\n  cfg.g_timebase.den = info.time_base.denominator;\n   cfg.rc_target_bitrate = bitrate;\n \n  for (pass = 0; pass < 2; ++pass) {\n    int frame_count = 0;\n \n    if (pass == 0) {\n      cfg.g_pass = VPX_RC_FIRST_PASS;\n    } else {\n      cfg.g_pass = VPX_RC_LAST_PASS;\n      cfg.rc_twopass_stats_in = stats;\n    }\n \n    if (!(infile = fopen(infile_arg, \"rb\")))\n      die(\"Failed to open %s for reading\", infile_arg);\n    if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n      die_codec(&codec, \"Failed to initialize encoder\");\n    while (vpx_img_read(&raw, infile)) {\n      ++frame_count;\n      if (pass == 0) {\n        get_frame_stats(&codec, &raw, frame_count, 1, 0, VPX_DL_BEST_QUALITY,\n                        &stats);\n      } else {\n        encode_frame(&codec, &raw, frame_count, 1, 0, VPX_DL_BEST_QUALITY,\n                     writer);\n      }\n    }\n    if (pass == 0) {\n      get_frame_stats(&codec, NULL, frame_count, 1, 0, VPX_DL_BEST_QUALITY,\n                      &stats);\n    } else {\n      printf(\"\\n\");\n    }\n    fclose(infile);\n    printf(\"Pass %d complete. Processed %d frames.\\n\", pass + 1, frame_count);\n    if (vpx_codec_destroy(&codec))\n      die_codec(&codec, \"Failed to destroy codec.\");\n  }\n  vpx_img_free(&raw);\n   free(stats.buf);\n \n  vpx_video_writer_close(writer);\n \n   return EXIT_SUCCESS;\n }\n","project":"Android","target":1},{"commit_id":"190cef6eed37d0e73a73c1e205eb31d45ab60a3c","func":"gnutls_session_get_data2 (gnutls_session_t session, gnutls_datum_t * data)\n{\n\n  int ret;\n\n  if (data == NULL)\n    {\n      return GNUTLS_E_INVALID_REQUEST;\n    }\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  ret = _gnutls_session_pack (session, data);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n\n  return 0;\n}\n","project":"savannah","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_unintern (struct cluster_list *cluster)\n{\n  if (cluster->refcnt)\n    cluster->refcnt--;\n\n  if (cluster->refcnt == 0)\n    {\n      hash_release (cluster_hash, cluster);\n      cluster_free (cluster);\n    }\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long CuePoint::GetTime(const Segment* pSegment) const\n{\n    assert(pSegment);\n    assert(m_timecode >= 0);\n    const SegmentInfo* const pInfo = pSegment->GetInfo();\n    assert(pInfo);\n    const long long scale = pInfo->GetTimeCodeScale();\n    assert(scale >= 1);\n    const long long time = scale * m_timecode;\n    return time;\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_packet_attribute (struct bgp *bgp, struct peer *peer,\n\t\t      struct stream *s, struct attr *attr, struct prefix *p,\n\t\t      afi_t afi, safi_t safi, struct peer *from,\n\t\t      struct prefix_rd *prd, u_char *tag)\n{\n  size_t cp;\n  size_t aspath_sizep;\n  struct aspath *aspath;\n  int send_as4_path = 0;\n  int send_as4_aggregator = 0;\n  int use32bit = (CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV)) ? 1 : 0;\n\n  if (! bgp)\n    bgp = bgp_get_default ();\n\n  \/* Remember current pointer. *\/\n  cp = stream_get_endp (s);\n\n  \/* Origin attribute. *\/\n  stream_putc (s, BGP_ATTR_FLAG_TRANS);\n  stream_putc (s, BGP_ATTR_ORIGIN);\n  stream_putc (s, 1);\n  stream_putc (s, attr->origin);\n\n  \/* AS path attribute. *\/\n\n  \/* If remote-peer is EBGP *\/\n  if (peer_sort (peer) == BGP_PEER_EBGP\n      && (! CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED)\n\t  || attr->aspath->segments == NULL)\n      && (! CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)))\n    {    \n      aspath = aspath_dup (attr->aspath);\n\n      if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION))\n\t{\n\t  \/* Strip the confed info, and then stuff our path CONFED_ID\n\t     on the front *\/\n\t  aspath = aspath_delete_confed_seq (aspath);\n\t  aspath = aspath_add_seq (aspath, bgp->confed_id);\n\t}\n      else\n\t{\n\t  aspath = aspath_add_seq (aspath, peer->local_as);\n\t  if (peer->change_local_as)\n\t    aspath = aspath_add_seq (aspath, peer->change_local_as);\n\t}\n    }\n  else if (peer_sort (peer) == BGP_PEER_CONFED)\n    {\n      \/* A confed member, so we need to do the AS_CONFED_SEQUENCE thing *\/\n      aspath = aspath_dup (attr->aspath);\n      aspath = aspath_add_confed_seq (aspath, peer->local_as);\n    }\n  else\n    aspath = attr->aspath;\n\n  \/* If peer is not AS4 capable, then:\n   * - send the created AS_PATH out as AS4_PATH (optional, transitive),\n   *   but ensure that no AS_CONFED_SEQUENCE and AS_CONFED_SET path segment\n   *   types are in it (i.e. exclude them if they are there)\n   *   AND do this only if there is at least one asnum > 65535 in the path!\n   * - send an AS_PATH out, but put 16Bit ASnums in it, not 32bit, and change\n   *   all ASnums > 65535 to BGP_AS_TRANS\n   *\/\n\n  stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);\n  stream_putc (s, BGP_ATTR_AS_PATH);\n  aspath_sizep = stream_get_endp (s);\n  stream_putw (s, 0);\n  stream_putw_at (s, aspath_sizep, aspath_put (s, aspath, use32bit));\n  \n  \/* OLD session may need NEW_AS_PATH sent, if there are 4-byte ASNs \n   * in the path\n   *\/\n  if (!use32bit && aspath_has_as4 (aspath))\n      send_as4_path = 1; \/* we'll do this later, at the correct place *\/\n  \n  \/* Nexthop attribute. *\/\n  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP) && afi == AFI_IP)\n    {\n      stream_putc (s, BGP_ATTR_FLAG_TRANS);\n      stream_putc (s, BGP_ATTR_NEXT_HOP);\n      stream_putc (s, 4);\n      if (safi == SAFI_MPLS_VPN)\n\t{\n\t  if (attr->nexthop.s_addr == 0)\n\t    stream_put_ipv4 (s, peer->nexthop.v4.s_addr);\n\t  else\n\t    stream_put_ipv4 (s, attr->nexthop.s_addr);\n\t}\n      else\n\tstream_put_ipv4 (s, attr->nexthop.s_addr);\n    }\n\n  \/* MED attribute. *\/\n  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))\n    {\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc (s, BGP_ATTR_MULTI_EXIT_DISC);\n      stream_putc (s, 4);\n      stream_putl (s, attr->med);\n    }\n\n  \/* Local preference. *\/\n  if (peer_sort (peer) == BGP_PEER_IBGP ||\n      peer_sort (peer) == BGP_PEER_CONFED)\n    {\n      stream_putc (s, BGP_ATTR_FLAG_TRANS);\n      stream_putc (s, BGP_ATTR_LOCAL_PREF);\n      stream_putc (s, 4);\n      stream_putl (s, attr->local_pref);\n    }\n\n  \/* Atomic aggregate. *\/\n  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE))\n    {\n      stream_putc (s, BGP_ATTR_FLAG_TRANS);\n      stream_putc (s, BGP_ATTR_ATOMIC_AGGREGATE);\n      stream_putc (s, 0);\n    }\n\n  \/* Aggregator. *\/\n  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR))\n    {\n      assert (attr->extra);\n      \n      \/* Common to BGP_ATTR_AGGREGATOR, regardless of ASN size *\/\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);\n      stream_putc (s, BGP_ATTR_AGGREGATOR);\n      \n      if (use32bit)\n        {\n          \/* AS4 capable peer *\/\n          stream_putc (s, 8);\n          stream_putl (s, attr->extra->aggregator_as);\n        }\n      else\n        {\n          \/* 2-byte AS peer *\/\n          stream_putc (s, 6);\n          \n          \/* Is ASN representable in 2-bytes? Or must AS_TRANS be used? *\/\n          if ( attr->extra->aggregator_as > 65535 )\n            {\n              stream_putw (s, BGP_AS_TRANS);\n              \n              \/* we have to send AS4_AGGREGATOR, too.\n               * we'll do that later in order to send attributes in ascending\n               * order.\n               *\/\n              send_as4_aggregator = 1;\n            }\n          else\n            stream_putw (s, (u_int16_t) attr->extra->aggregator_as);\n        }\n      stream_put_ipv4 (s, attr->extra->aggregator_addr.s_addr);\n    }\n\n  \/* Community attribute. *\/\n  if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY) \n      && (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES)))\n    {\n      if (attr->community->size * 4 > 255)\n\t{\n\t  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);\n\t  stream_putc (s, BGP_ATTR_COMMUNITIES);\n\t  stream_putw (s, attr->community->size * 4);\n\t}\n      else\n\t{\n\t  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);\n\t  stream_putc (s, BGP_ATTR_COMMUNITIES);\n\t  stream_putc (s, attr->community->size * 4);\n\t}\n      stream_put (s, attr->community->val, attr->community->size * 4);\n    }\n\n  \/* Route Reflector. *\/\n  if (peer_sort (peer) == BGP_PEER_IBGP\n      && from\n      && peer_sort (from) == BGP_PEER_IBGP)\n    {\n      \/* Originator ID. *\/\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc (s, BGP_ATTR_ORIGINATOR_ID);\n      stream_putc (s, 4);\n\n      if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))\n\tstream_put_in_addr (s, &attr->extra->originator_id);\n      else \n        stream_put_in_addr (s, &from->remote_id);\n\n      \/* Cluster list. *\/\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc (s, BGP_ATTR_CLUSTER_LIST);\n      \n      if (attr->extra && attr->extra->cluster)\n\t{\n\t  stream_putc (s, attr->extra->cluster->length + 4);\n\t  \/* If this peer configuration's parent BGP has cluster_id. *\/\n\t  if (bgp->config & BGP_CONFIG_CLUSTER_ID)\n\t    stream_put_in_addr (s, &bgp->cluster_id);\n\t  else\n\t    stream_put_in_addr (s, &bgp->router_id);\n\t  stream_put (s, attr->extra->cluster->list, \n\t              attr->extra->cluster->length);\n\t}\n      else\n\t{\n\t  stream_putc (s, 4);\n\t  \/* If this peer configuration's parent BGP has cluster_id. *\/\n\t  if (bgp->config & BGP_CONFIG_CLUSTER_ID)\n\t    stream_put_in_addr (s, &bgp->cluster_id);\n\t  else\n\t    stream_put_in_addr (s, &bgp->router_id);\n\t}\n    }\n\n#ifdef HAVE_IPV6\n  \/* If p is IPv6 address put it into attribute. *\/\n  if (p->family == AF_INET6)\n    {\n      unsigned long sizep;\n      struct attr_extra *attre = attr->extra;\n      \n      assert (attr->extra);\n      \n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc (s, BGP_ATTR_MP_REACH_NLRI);\n      sizep = stream_get_endp (s);\n      stream_putc (s, 0);\t\/* Marker: Attribute length. *\/\n      stream_putw (s, AFI_IP6);\t\/* AFI *\/\n      stream_putc (s, safi);\t\/* SAFI *\/\n\n      stream_putc (s, attre->mp_nexthop_len);\n\n      if (attre->mp_nexthop_len == 16)\n\tstream_put (s, &attre->mp_nexthop_global, 16);\n      else if (attre->mp_nexthop_len == 32)\n\t{\n\t  stream_put (s, &attre->mp_nexthop_global, 16);\n\t  stream_put (s, &attre->mp_nexthop_local, 16);\n\t}\n      \n      \/* SNPA *\/\n      stream_putc (s, 0);\n\n      \/* Prefix write. *\/\n      stream_put_prefix (s, p);\n\n      \/* Set MP attribute length. *\/\n      stream_putc_at (s, sizep, (stream_get_endp (s) - sizep) - 1);\n    }\n#endif \/* HAVE_IPV6 *\/\n\n  if (p->family == AF_INET && safi == SAFI_MULTICAST)\n    {\n      unsigned long sizep;\n\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc (s, BGP_ATTR_MP_REACH_NLRI);\n      sizep = stream_get_endp (s);\n      stream_putc (s, 0);\t\/* Marker: Attribute Length. *\/\n      stream_putw (s, AFI_IP);\t\/* AFI *\/\n      stream_putc (s, SAFI_MULTICAST);\t\/* SAFI *\/\n\n      stream_putc (s, 4);\n      stream_put_ipv4 (s, attr->nexthop.s_addr);\n\n      \/* SNPA *\/\n      stream_putc (s, 0);\n\n      \/* Prefix write. *\/\n      stream_put_prefix (s, p);\n\n      \/* Set MP attribute length. *\/\n      stream_putc_at (s, sizep, (stream_get_endp (s) - sizep) - 1);\n    }\n\n  if (p->family == AF_INET && safi == SAFI_MPLS_VPN)\n    {\n      unsigned long sizep;\n\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc (s, BGP_ATTR_MP_REACH_NLRI);\n      sizep = stream_get_endp (s);\n      stream_putc (s, 0);\t\/* Length of this attribute. *\/\n      stream_putw (s, AFI_IP);\t\/* AFI *\/\n      stream_putc (s, SAFI_MPLS_LABELED_VPN);\t\/* SAFI *\/\n\n      stream_putc (s, 12);\n      stream_putl (s, 0);\n      stream_putl (s, 0);\n      stream_put (s, &attr->extra->mp_nexthop_global_in, 4);\n\n      \/* SNPA *\/\n      stream_putc (s, 0);\n\n      \/* Tag, RD, Prefix write. *\/\n      stream_putc (s, p->prefixlen + 88);\n      stream_put (s, tag, 3);\n      stream_put (s, prd->val, 8);\n      stream_put (s, &p->u.prefix, PSIZE (p->prefixlen));\n\n      \/* Set MP attribute length. *\/\n      stream_putc_at (s, sizep, (stream_get_endp (s) - sizep) - 1);\n    }\n\n  \/* Extended Communities attribute. *\/\n  if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY) \n      && (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES)))\n    {\n      struct attr_extra *attre = attr->extra;\n      \n      assert (attre);\n      \n      if (peer_sort (peer) == BGP_PEER_IBGP \n          || peer_sort (peer) == BGP_PEER_CONFED)\n\t{\n\t  if (attre->ecommunity->size * 8 > 255)\n\t    {\n\t      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);\n\t      stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);\n\t      stream_putw (s, attre->ecommunity->size * 8);\n\t    }\n\t  else\n\t    {\n\t      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);\n\t      stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);\n\t      stream_putc (s, attre->ecommunity->size * 8);\n\t    }\n\t  stream_put (s, attre->ecommunity->val, attre->ecommunity->size * 8);\n\t}\n      else\n\t{\n\t  u_int8_t *pnt;\n\t  int tbit;\n\t  int ecom_tr_size = 0;\n\t  int i;\n\n\t  for (i = 0; i < attre->ecommunity->size; i++)\n\t    {\n\t      pnt = attre->ecommunity->val + (i * 8);\n\t      tbit = *pnt;\n\n\t      if (CHECK_FLAG (tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE))\n\t\tcontinue;\n\n\t      ecom_tr_size++;\n\t    }\n\n\t  if (ecom_tr_size)\n\t    {\n\t      if (ecom_tr_size * 8 > 255)\n\t\t{\n\t\t  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);\n\t\t  stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);\n\t\t  stream_putw (s, ecom_tr_size * 8);\n\t\t}\n\t      else\n\t\t{\n\t\t  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);\n\t\t  stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);\n\t\t  stream_putc (s, ecom_tr_size * 8);\n\t\t}\n\n\t      for (i = 0; i < attre->ecommunity->size; i++)\n\t\t{\n\t\t  pnt = attre->ecommunity->val + (i * 8);\n\t\t  tbit = *pnt;\n\n\t\t  if (CHECK_FLAG (tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE))\n\t\t    continue;\n\n\t\t  stream_put (s, pnt, 8);\n\t\t}\n\t    }\n\t}\n    }\n\n  if ( send_as4_path )\n    {\n      \/* If the peer is NOT As4 capable, AND *\/\n      \/* there are ASnums > 65535 in path  THEN\n       * give out AS4_PATH *\/\n\n      \/* Get rid of all AS_CONFED_SEQUENCE and AS_CONFED_SET\n       * path segments!\n       * Hm, I wonder...  confederation things *should* only be at\n       * the beginning of an aspath, right?  Then we should use\n       * aspath_delete_confed_seq for this, because it is already\n       * there! (JK) \n       * Folks, talk to me: what is reasonable here!?\n       *\/\n      aspath = aspath_delete_confed_seq (aspath);\n\n      stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_EXTLEN);\n      stream_putc (s, BGP_ATTR_AS4_PATH);\n      aspath_sizep = stream_get_endp (s);\n      stream_putw (s, 0);\n      stream_putw_at (s, aspath_sizep, aspath_put (s, aspath, 1));\n    }\n\n  if (aspath != attr->aspath)\n    aspath_free (aspath);\n\n  if ( send_as4_aggregator ) \n    {\n      assert (attr->extra);\n\n      \/* send AS4_AGGREGATOR, at this place *\/\n      \/* this section of code moved here in order to ensure the correct\n       * *ascending* order of attributes\n       *\/\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);\n      stream_putc (s, BGP_ATTR_AS4_AGGREGATOR);\n      stream_putc (s, 8);\n      stream_putl (s, attr->extra->aggregator_as);\n      stream_put_ipv4 (s, attr->extra->aggregator_addr.s_addr);\n    }\n  \n  \/* Unknown transit attribute. *\/\n  if (attr->extra && attr->extra->transit)\n    stream_put (s, attr->extra->transit->val, attr->extra->transit->length);\n\n  \/* Return total size of attribute. *\/\n  return stream_get_endp (s) - cp;\n}\n","project":"savannah","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_public_decrypt)\n{\n\tzval **key, *crypted;\n\tEVP_PKEY *pkey;\n\tint cryptedlen;\n\tunsigned char *cryptedbuf = NULL;\n\tunsigned char *crypttemp;\n\tint successful = 0;\n\tlong keyresource = -1;\n\tlong padding = RSA_PKCS1_PADDING;\n\tchar * data;\n\tint data_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"szZ|l\", &data, &data_len, &crypted, &key, &padding) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\t\n\tpkey = php_openssl_evp_from_zval(key, 1, NULL, 0, &keyresource TSRMLS_CC);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key parameter is not a valid public key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcryptedlen = EVP_PKEY_size(pkey);\n\tcrypttemp = emalloc(cryptedlen + 1);\n\n\tswitch (pkey->type) {\n\t\tcase EVP_PKEY_RSA:\n\t\tcase EVP_PKEY_RSA2:\n\t\t\tcryptedlen = RSA_public_decrypt(data_len, \n\t\t\t\t\t(unsigned char *)data, \n\t\t\t\t\tcrypttemp, \n\t\t\t\t\tpkey->pkey.rsa, \n\t\t\t\t\tpadding);\n\t\t\tif (cryptedlen != -1) {\n\t\t\t\tcryptedbuf = emalloc(cryptedlen + 1);\n\t\t\t\tmemcpy(cryptedbuf, crypttemp, cryptedlen);\n\t\t\t\tsuccessful = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key type not supported in this PHP build!\");\n\t\t \n\t}\n\n\tefree(crypttemp);\n\n\tif (successful) {\n\t\tzval_dtor(crypted);\n\t\tcryptedbuf[cryptedlen] = '\\0';\n\t\tZVAL_STRINGL(crypted, (char *)cryptedbuf, cryptedlen, 0);\n\t\tcryptedbuf = NULL;\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (cryptedbuf) {\n\t\tefree(cryptedbuf);\n\t}\n\tif (keyresource == -1) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n}\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_finish (void)\n{\n  aspath_finish ();\n  attrhash_finish ();\n  community_finish ();\n  ecommunity_finish ();\n  cluster_finish ();\n  transit_finish ();\n}\n","project":"savannah","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct dom_sid *sid;\n\tstruct ldb_result *res;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\ttalloc_free(res);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"Failed to find primary group with RID %u!\",\n\t\t\t\t       rid);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n","project":"samba","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {\n    }\n  }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_origin (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer;\n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  \/* If any recognized attribute has Attribute Length that conflicts\n     with the expected length (based on the attribute type code), then\n     the Error Subcode is set to Attribute Length Error.  The Data\n     field contains the erroneous attribute (type, length and\n     value). *\/\n  if (length != 1)\n    {\n      zlog (peer->log, LOG_ERR, \"Origin attribute length is not one %d\",\n\t    length);\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n\n  \/* Fetch origin attribute. *\/\n  attr->origin = stream_getc (BGP_INPUT (peer));\n\n  \/* If the ORIGIN attribute has an undefined value, then the Error\n     Subcode is set to Invalid Origin Attribute.  The Data field\n     contains the unrecognized attribute (type, length and value). *\/\n  if ((attr->origin != BGP_ORIGIN_IGP)\n      && (attr->origin != BGP_ORIGIN_EGP)\n      && (attr->origin != BGP_ORIGIN_INCOMPLETE))\n    {\n      zlog (peer->log, LOG_ERR, \"Origin attribute value is invalid %d\",\n\t      attr->origin);\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_INVAL_ORIGIN,\n                                 args->total);\n    }\n\n  \/* Set oring attribute flag. *\/\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);\n\n  return 0;\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Cluster::Cluster() :\n    m_pSegment(NULL),\n    m_element_start(0),\n    m_index(0),\n    m_pos(0),\n    m_element_size(0),\n    m_timecode(0),\n    m_entries(NULL),\n    m_entries_size(0),\n    m_entries_count(0)  \/\/means \"no entries\"\n{\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"unsigned long long Chapters::Atom::GetUID() const\n{\n    return m_uid;\n }\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAMRWBEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAMR;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            amrParams->nChannels = 1;\n            amrParams->nBitRate = mBitRate;\n\n            amrParams->eAMRBandMode =\n (OMX_AUDIO_AMRBANDMODETYPE)(mMode + OMX_AUDIO_AMRBandModeWB0);\n\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelCF;\n\n            pcmParams->nChannels = 1;\n            pcmParams->nSamplingRate = kSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"SegmentInfo::SegmentInfo(\n    Segment* pSegment,\n    long long start,\n    long long size_,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_start(start),\n    m_size(size_),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    m_pMuxingAppAsUTF8(NULL),\n    m_pWritingAppAsUTF8(NULL),\n    m_pTitleAsUTF8(NULL)\n{\n}\n","project":"Android","target":1},{"commit_id":"640b04121d7cd2cac90e2f7c82b97fce05f074a5","func":"status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b\/25884056\");\n return BAD_VALUE;\n }\n\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {\n return BAD_VALUE;\n }\n\n bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;\n\n BufferMeta *buffer_meta = new BufferMeta(\n            params, portIndex,\n (portIndex == kPortIndexInput) && copy \/* copyToOmx *\/,\n (portIndex == kPortIndexOutput) && copy \/* copyFromOmx *\/,\n            NULL \/* data *\/);\n\n    OMX_BUFFERHEADERTYPE *header;\n\n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n\n     }\n \n     CHECK_EQ(header->pAppPrivate, buffer_meta);\n    memset(header->pBuffer, 0, header->nAllocLen);\n \n     *buffer = makeBufferID(header);\n \n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n\n return OK;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"static void usage(char *progname) {\n   printf(\"Usage:\\n\");\n   printf(\"%s <input_yuv> <width>x<height> <target_width>x<target_height> \",\n         progname);\n   printf(\"<output_yuv> [<frames>]\\n\");\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Segment::ParseNext(\n    const Cluster* pCurr,\n    const Cluster*& pResult,\n    long long& pos,\n    long& len)\n{\n    assert(pCurr);\n    assert(!pCurr->EOS());\n    assert(m_clusters);\n \n    pResult = 0;\n \n    if (pCurr->m_index >= 0)  \/\/loaded (not merely preloaded)\n    {\n        assert(m_clusters[pCurr->m_index] == pCurr);\n \n        const long next_idx = pCurr->m_index + 1;\n \n        if (next_idx < m_clusterCount)\n        {\n            pResult = m_clusters[next_idx];\n            return 0;  \/\/success\n        }\n \n \n        const long result = LoadCluster(pos, len);\n \n        if (result < 0)  \/\/error or underflow\n            return result;\n \n        if (result > 0)  \/\/no more clusters\n        {\n            return 1;\n        }\n \n        pResult = GetLast();\n        return 0;  \/\/success\n     }\n \n    assert(m_pos > 0);\n \n    long long total, avail;\n \n    long status = m_pReader->Length(&total, &avail);\n \n    if (status < 0)  \/\/error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n \n \n    pos = pCurr->m_element_start;\n \n    if (pCurr->m_element_size >= 0)\n        pos += pCurr->m_element_size;\n     else\n    {\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(m_pReader, pos, len);\n \n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n \n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n \n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id = ReadUInt(m_pReader, pos, len);\n        if (id != 0x0F43B675)  \/\/weird: not Cluster ID\n            return -1;\n        pos += len;  \/\/consume ID\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(m_pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(m_pReader, pos, len);\n        if (size < 0) \/\/error\n            return static_cast<long>(size);\n        pos += len;  \/\/consume size field\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)          \/\/TODO: should never happen\n            return E_FILE_FORMAT_INVALID;  \/\/TODO: resolve this\n        if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        pos += size;  \/\/consume payload (that is, the current cluster)\n        assert((segment_stop < 0) || (pos <= segment_stop));\n    }\n    for (;;)\n    {\n        const long status = DoParseNext(pResult, pos, len);\n        if (status <= 1)\n            return status;\n    }\n }\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)\n{\n\tstruct samldb_step *step, *stepper;\n\n\tstep = talloc_zero(ac, struct samldb_step);\n\tif (step == NULL) {\n\t\treturn ldb_oom(ldb_module_get_ctx(ac->module));\n\t}\n\n\tstep->fn = fn;\n\n\tif (ac->steps == NULL) {\n\t\tac->steps = step;\n\t\tac->curstep = step;\n\t} else {\n\t\tif (ac->curstep == NULL)\n\t\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t\tfor (stepper = ac->curstep; stepper->next != NULL;\n\t\t\tstepper = stepper->next);\n\t\tstepper->next = step;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n","project":"samba","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static const EVP_CIPHER * php_openssl_get_evp_cipher_from_algo(long algo) { \/* {{{ *\/\n\tswitch (algo) {\n#ifndef OPENSSL_NO_RC2\n\t\tcase PHP_OPENSSL_CIPHER_RC2_40:\n\t\t\treturn EVP_rc2_40_cbc();\n\t\t\tbreak;\n\t\tcase PHP_OPENSSL_CIPHER_RC2_64:\n\t\t\treturn EVP_rc2_64_cbc();\n\t\t\tbreak;\n\t\tcase PHP_OPENSSL_CIPHER_RC2_128:\n\t\t\treturn EVP_rc2_cbc();\n\t\t\tbreak;\n#endif\n\n#ifndef OPENSSL_NO_DES\n\t\tcase PHP_OPENSSL_CIPHER_DES:\n\t\t\treturn EVP_des_cbc();\n\t\t\tbreak;\n\t\tcase PHP_OPENSSL_CIPHER_3DES:\n\t\t\treturn EVP_des_ede3_cbc();\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_cmm_init_profile(fz_context *ctx, fz_iccprofile *profile)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->init_profile(ctx->cmm_instance, profile);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Tracks::Parse()\n{\n    assert(m_trackEntries == NULL);\n    assert(m_trackEntriesEnd == NULL);\n    const long long stop = m_start + m_size;\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    int count = 0;\n    long long pos = m_start;\n    while (pos < stop)\n    {\n        long long id, size;\n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n        if (status < 0)  \/\/error\n            return status;\n        if (size == 0)  \/\/weird\n            continue;\n        if (id == 0x2E)  \/\/TrackEntry ID\n            ++count;\n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    if (count <= 0)\n        return 0;  \/\/success\n    m_trackEntries = new (std::nothrow) Track*[count];\n    if (m_trackEntries == NULL)\n        return -1;\n    m_trackEntriesEnd = m_trackEntries;\n    pos = m_start;\n    while (pos < stop)\n    {\n        const long long element_start = pos;\n        long long id, payload_size;\n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                payload_size);\n        if (status < 0)  \/\/error\n            return status;\n        if (payload_size == 0)  \/\/weird\n            continue;\n        const long long payload_stop = pos + payload_size;\n        assert(payload_stop <= stop);  \/\/checked in ParseElement\n        const long long element_size = payload_stop - element_start;\n        if (id == 0x2E)  \/\/TrackEntry ID\n        {\n            Track*& pTrack = *m_trackEntriesEnd;\n            pTrack = NULL;\n            const long status = ParseTrackEntry(\n                                    pos,\n                                    payload_size,\n                                    element_start,\n                                    element_size,\n                                    pTrack);\n            if (status)\n                return status;\n            if (pTrack)\n                ++m_trackEntriesEnd;\n        }\n        pos = payload_stop;\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    return 0;  \/\/success\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Track* Tracks::GetTrackByNumber(long tn) const\n{\n    if (tn < 0)\n        return NULL;\n    Track** i = m_trackEntries;\n    Track** const j = m_trackEntriesEnd;\n    while (i != j)\n    {\n        Track* const pTrack = *i++;\n        if (pTrack == NULL)\n            continue;\n        if (tn == pTrack->GetNumber())\n            return pTrack;\n    }\n    return NULL;  \/\/not found\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_default_color_params(fz_context *ctx)\n{\n\treturn default_color_params;\n}\n","project":"ghostscript","target":0},{"commit_id":"65756b4082cd79a2d99b2ccb5b392291fd53703f","func":"void SoftAMR::onQueueFilled(OMX_U32 \/* portIndex *\/) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n\n         BufferInfo *inInfo = *inQueue.begin();\n         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n \n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n \n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n int32_t numBytesRead;\n\n if (mMode == MODE_NARROW) {\n if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {\n                ALOGE(\"b\/27662364: NB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n\n                 return;\n             }\n \n             numBytesRead =\n                 AMRDecode(mState,\n                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; \/\/ Include the frame type header byte.\n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n } else {\n if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {\n                ALOGE(\"b\/27662364: WB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n\n if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n\n             }\n \n             size_t frameSize = getFrameSize(mode);\n            CHECK_GE(inHeader->nFilledLen, frameSize);\n \n             int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n \n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n \/* Delete the 2 LSBs (14-bit output) *\/\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) \/ kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) \/ kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_any_to_alpha(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tassert(copy_spots && dst->s == 0 && src->s == 0);\n\n\tif (!src->alpha)\n\t\tfz_clear_pixmap_with_value(ctx, dst, 255);\n\telse\n\t{\n\t\tunsigned char *s = src->samples;\n\t\tunsigned char *d = dst->samples;\n\t\tsize_t w = src->w;\n\t\tint h = src->h;\n\t\tint n = src->n;\n\t\tptrdiff_t d_line_inc = dst->stride - w * dst->n;\n\t\tptrdiff_t s_line_inc = src->stride - w * src->n;\n\n\t\tif ((int)w < 0 || h < 0)\n\t\t\treturn;\n\n\t\tassert(dst->alpha && src->alpha && dst->n == 1);\n\n\t\tif (d_line_inc == 0 && s_line_inc == 0)\n\t\t{\n\t\t\tw *= h;\n\t\t\th = 1;\n\t\t}\n\n\t\ts += n-1;\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\t*d++ = *s;\n\t\t\t\ts += n;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftVPXEncoder::internalGetParameter(OMX_INDEXTYPE index,\n                                                   OMX_PTR param) {\n const int32_t indexFull = index;\n\n switch (indexFull) {\n case OMX_IndexParamVideoBitrate: {\n\n             OMX_VIDEO_PARAM_BITRATETYPE *bitrate =\n                 (OMX_VIDEO_PARAM_BITRATETYPE *)param;\n \n                if (bitrate->nPortIndex != kOutputPortIndex) {\n                    return OMX_ErrorUnsupportedIndex;\n                }\n \n                bitrate->nTargetBitrate = mBitrate;\n \n                if (mBitrateControlMode == VPX_VBR) {\n                    bitrate->eControlRate = OMX_Video_ControlRateVariable;\n                } else if (mBitrateControlMode == VPX_CBR) {\n                    bitrate->eControlRate = OMX_Video_ControlRateConstant;\n                } else {\n                    return OMX_ErrorUnsupportedSetting;\n                }\n                return OMX_ErrorNone;\n         }\n \n case OMX_IndexParamVideoVp8: {\n\n             OMX_VIDEO_PARAM_VP8TYPE *vp8Params =\n                 (OMX_VIDEO_PARAM_VP8TYPE *)param;\n \n                if (vp8Params->nPortIndex != kOutputPortIndex) {\n                    return OMX_ErrorUnsupportedIndex;\n                }\n \n                vp8Params->eProfile = OMX_VIDEO_VP8ProfileMain;\n                vp8Params->eLevel = mLevel;\n                vp8Params->nDCTPartitions = mDCTPartitions;\n                vp8Params->bErrorResilientMode = mErrorResilience;\n                return OMX_ErrorNone;\n         }\n \n         case OMX_IndexParamVideoAndroidVp8Encoder: {\n             OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *vp8AndroidParams =\n                 (OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *)param;\n \n                if (vp8AndroidParams->nPortIndex != kOutputPortIndex) {\n                    return OMX_ErrorUnsupportedIndex;\n                }\n \n                vp8AndroidParams->nKeyFrameInterval = mKeyFrameInterval;\n                vp8AndroidParams->eTemporalPattern = mTemporalPatternType;\n                vp8AndroidParams->nTemporalLayerCount = mTemporalLayers;\n                vp8AndroidParams->nMinQuantizer = mMinQuantizer;\n                vp8AndroidParams->nMaxQuantizer = mMaxQuantizer;\n                memcpy(vp8AndroidParams->nTemporalLayerBitrateRatio,\n                       mTemporalLayerBitrateRatio, sizeof(mTemporalLayerBitrateRatio));\n                return OMX_ErrorNone;\n         }\n \n         default:\n return SoftVideoEncoderOMXComponent::internalGetParameter(index, param);\n }\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftGSM::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (pcmParams->nChannels != 1) {\n return OMX_ErrorUndefined;\n }\n\n if (pcmParams->nSamplingRate != 8000) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.gsm\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"static unsigned int delete_node(pdf_cmap *cmap, unsigned int current)\n{\n\tcmap_splay *tree = cmap->tree;\n\tunsigned int parent;\n\tunsigned int replacement;\n\n\tassert(current != EMPTY);\n\n\tparent = tree[current].parent;\n\tif (tree[current].right == EMPTY)\n\t{\n\t\tif (parent == EMPTY)\n\t\t{\n\t\t\treplacement = cmap->ttop = tree[current].left;\n\t\t}\n\t\telse if (tree[parent].left == current)\n\t\t{\n\t\t\treplacement = tree[parent].left = tree[current].left;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(tree[parent].right == current);\n\t\t\treplacement = tree[parent].right = tree[current].left;\n\t\t}\n\t\tif (replacement != EMPTY)\n\t\t\ttree[replacement].parent = parent;\n\t\telse\n\t\t\treplacement = parent;\n\t}\n\telse if (tree[current].left == EMPTY)\n\t{\n\t\tif (parent == EMPTY)\n\t\t{\n\t\t\treplacement = cmap->ttop = tree[current].right;\n\t\t}\n\t\telse if (tree[parent].left == current)\n\t\t{\n\t\t\treplacement = tree[parent].left = tree[current].right;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(tree[parent].right == current);\n\t\t\treplacement = tree[parent].right = tree[current].right;\n\t\t}\n\t\tif (replacement != EMPTY)\n\t\t\ttree[replacement].parent = parent;\n\t\telse\n\t\t\treplacement = parent;\n\t}\n\telse\n\t{\n\t\t\/* Hard case, find the in-order predecessor of current *\/\n\t\tint amputee = current;\n\t\treplacement = tree[current].left;\n\t\twhile (tree[replacement].right != EMPTY) {\n\t\t\tamputee = replacement;\n\t\t\treplacement = tree[replacement].right;\n\t\t}\n\t\t\/* Remove replacement from the tree *\/\n\t\tif (amputee == current)\n\t\t{\n\t\t\ttree[amputee].left = tree[replacement].left;\n\t\t\tif (tree[amputee].left != EMPTY)\n\t\t\t\ttree[tree[amputee].left].parent = amputee;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttree[amputee].right = tree[replacement].left;\n\t\t\tif (tree[amputee].right != EMPTY)\n\t\t\t\ttree[tree[amputee].right].parent = amputee;\n\t\t}\n\t\t\/* Insert replacement in place of current *\/\n\t\ttree[replacement].parent = parent;\n\t\tif (parent == EMPTY)\n\t\t{\n\t\t\ttree[replacement].parent = EMPTY;\n\t\t\tcmap->ttop = replacement;\n\t\t}\n\t\telse if (tree[parent].left == current)\n\t\t\ttree[parent].left = replacement;\n\t\telse\n\t\t{\n\t\t\tassert(tree[parent].right == current);\n\t\t\ttree[parent].right = replacement;\n\t\t}\n\t\ttree[replacement].left = tree[current].left;\n\t\tif (tree[replacement].left != EMPTY)\n\t\t\ttree[tree[replacement].left].parent = replacement;\n\t\ttree[replacement].right = tree[current].right;\n\t\tif (tree[replacement].right != EMPTY)\n\t\t\ttree[tree[replacement].right].parent = replacement;\n\t}\n\n\t\/* current is now unlinked. We need to remove it from our array. *\/\n\tcmap->tlen--;\n\tif (current != cmap->tlen)\n\t{\n\t\tif (replacement == cmap->tlen)\n\t\t\treplacement = current;\n\t\ttree[current] = tree[cmap->tlen];\n\t\tparent = tree[current].parent;\n\t\tif (parent == EMPTY)\n\t\t\tcmap->ttop = current;\n\t\telse if (tree[parent].left == cmap->tlen)\n\t\t\ttree[parent].left = current;\n\t\telse\n\t\t{\n\t\t\tassert(tree[parent].right == cmap->tlen);\n\t\t\ttree[parent].right = current;\n\t\t}\n\t\tif (tree[current].left != EMPTY)\n\t\t{\n\t\t\tassert(tree[tree[current].left].parent == cmap->tlen);\n\t\t\ttree[tree[current].left].parent = current;\n\t\t}\n\t\tif (tree[current].right != EMPTY)\n\t\t{\n\t\t\tassert(tree[tree[current].right].parent == cmap->tlen);\n\t\t\ttree[tree[current].right].parent = current;\n\t\t}\n\t}\n\n\t\/* Return the node that we should continue searching from *\/\n\treturn replacement;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static inline void cached_cmyk_conv(unsigned char *restrict const pr, unsigned char *restrict const pg, unsigned char *restrict const pb,\n\t\t\t\tunsigned int *restrict const C, unsigned int *restrict const M, unsigned int *restrict const Y, unsigned int *restrict const K,\n\t\t\t\tunsigned int c, unsigned int m, unsigned int y, unsigned int k)\n{\n#ifdef SLOWCMYK\n\tunsigned int r, g, b;\n\tunsigned int cm, c1m, cm1, c1m1, c1m1y, c1m1y1, c1my, c1my1, cm1y, cm1y1, cmy, cmy1;\n\tunsigned int x0, x1;\n\n\tif (c == *C && m == *M && y == *Y && k == *K)\n\t{\n\t\t\/* Nothing to do *\/\n\t}\n\telse if (k == 0 && c == 0 && m == 0 && y == 0)\n\t{\n\t\t*C = 0;\n\t\t*M = 0;\n\t\t*Y = 0;\n\t\t*K = 0;\n\t\t*pr = *pg = *pb = 255;\n\t}\n\telse if (k == 255)\n\t{\n\t\t*C = 0;\n\t\t*M = 0;\n\t\t*Y = 0;\n\t\t*K = 255;\n\t\t*pr = *pg = *pb = 0;\n\t}\n\telse\n\t{\n\t\t*C = c;\n\t\t*M = m;\n\t\t*Y = y;\n\t\t*K = k;\n\t\tc += c>>7;\n\t\tm += m>>7;\n\t\ty += y>>7;\n\t\tk += k>>7;\n\t\ty >>= 1; \/* Ditch 1 bit of Y to avoid overflow *\/\n\t\tcm = c * m;\n\t\tc1m = (m<<8) - cm;\n\t\tcm1 = (c<<8) - cm;\n\t\tc1m1 = ((256 - m)<<8) - cm1;\n\t\tc1m1y = c1m1 * y;\n\t\tc1m1y1 = (c1m1<<7) - c1m1y;\n\t\tc1my = c1m * y;\n\t\tc1my1 = (c1m<<7) - c1my;\n\t\tcm1y = cm1 * y;\n\t\tcm1y1 = (cm1<<7) - cm1y;\n\t\tcmy = cm * y;\n\t\tcmy1 = (cm<<7) - cmy;\n\n\t\t\/* this is a matrix multiplication, unrolled for performance *\/\n\t\tx1 = c1m1y1 * k;\t\/* 0 0 0 1 *\/\n\t\tx0 = (c1m1y1<<8) - x1;\t\/* 0 0 0 0 *\/\n\t\tx1 = x1>>8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tr = g = b = x0;\n\t\tr += 35 * x1;\t\/* 0.1373f *\/\n\t\tg += 31 * x1;\t\/* 0.1216f *\/\n\t\tb += 32 * x1;\t\/* 0.1255f *\/\n\n\t\tx1 = c1m1y * k;\t\t\/* 0 0 1 1 *\/\n\t\tx0 = (c1m1y<<8) - x1;\t\/* 0 0 1 0 *\/\n\t\tx1 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tr += 28 * x1;\t\/* 0.1098f *\/\n\t\tg += 26 * x1;\t\/* 0.1020f *\/\n\t\tr += x0;\n\t\tx0 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tg += 243 * x0;\t\/* 0.9490f *\/\n\n\t\tx1 = c1my1 * k;\t\t\/* 0 1 0 1 *\/\n\t\tx0 = (c1my1<<8) - x1;\t\/* 0 1 0 0 *\/\n\t\tx1 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tx0 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tr += 36 * x1;\t\/* 0.1412f *\/\n\t\tr += 237 * x0;\t\/* 0.9255f *\/\n\t\tb += 141 * x0;\t\/* 0.5490f *\/\n\n\t\tx1 = c1my * k;\t\t\/* 0 1 1 1 *\/\n\t\tx0 = (c1my<<8) - x1;\t\/* 0 1 1 0 *\/\n\t\tx1 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tx0 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tr += 34 * x1;\t\/* 0.1333f *\/\n\t\tr += 238 * x0;\t\/* 0.9294f *\/\n\t\tg += 28 * x0;\t\/* 0.1098f *\/\n\t\tb += 36 * x0;\t\/* 0.1412f *\/\n\n\t\tx1 = cm1y1 * k;\t\t\/* 1 0 0 1 *\/\n\t\tx0 = (cm1y1<<8) - x1;\t\/* 1 0 0 0 *\/\n\t\tx1 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tx0 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tg += 15 * x1;\t\/* 0.0588f *\/\n\t\tb += 36 * x1;\t\/* 0.1412f *\/\n\t\tg += 174 * x0;\t\/* 0.6784f *\/\n\t\tb += 240 * x0;\t\/* 0.9373f *\/\n\n\t\tx1 = cm1y * k;\t\t\/* 1 0 1 1 *\/\n\t\tx0 = (cm1y<<8) - x1;\t\/* 1 0 1 0 *\/\n\t\tx1 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tx0 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tg += 19 * x1;\t\/* 0.0745f *\/\n\t\tg += 167 * x0;\t\/* 0.6510f *\/\n\t\tb += 80 * x0;\t\/* 0.3137f *\/\n\n\t\tx1 = cmy1 * k;\t\t\/* 1 1 0 1 *\/\n\t\tx0 = (cmy1<<8) - x1;\t\/* 1 1 0 0 *\/\n\t\tx1 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tx0 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tb += 2 * x1;\t\/* 0.0078f *\/\n\t\tr += 46 * x0;\t\/* 0.1804f *\/\n\t\tg += 49 * x0;\t\/* 0.1922f *\/\n\t\tb += 147 * x0;\t\/* 0.5725f *\/\n\n\t\tx0 = cmy * (256-k);\t\/* 1 1 1 0 *\/\n\t\tx0 >>= 8;\t\t\/* From 23 fractional bits to 15 *\/\n\t\tr += 54 * x0;\t\/* 0.2118f *\/\n\t\tg += 54 * x0;\t\/* 0.2119f *\/\n\t\tb += 57 * x0;\t\/* 0.2235f *\/\n\n\t\tr -= (r>>8);\n\t\tg -= (g>>8);\n\t\tb -= (b>>8);\n\t\t*pr = r>>23;\n\t\t*pg = g>>23;\n\t\t*pb = b>>23;\n\t}\n#else\n\t*pr = 255 - (unsigned char)fz_mini(c + k, 255);\n\t*pg = 255 - (unsigned char)fz_mini(m + k, 255);\n\t*pb = 255 - (unsigned char)fz_mini(y + k, 255);\n#endif\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_parse (struct peer *peer, struct attr *attr, bgp_size_t size,\n\t\tstruct bgp_nlri *mp_update, struct bgp_nlri *mp_withdraw)\n{\n  int ret;\n  u_char flag = 0;\n  u_char type = 0;\n  bgp_size_t length;\n  u_char *startp, *endp;\n  u_char *attr_endp;\n  u_char seen[BGP_ATTR_BITMAP_SIZE];\n  \/* we need the as4_path only until we have synthesized the as_path with it *\/\n  \/* same goes for as4_aggregator *\/\n  struct aspath *as4_path = NULL;\n  as_t as4_aggregator = 0;\n  struct in_addr as4_aggregator_addr = { 0 };\n\n  \/* Initialize bitmap. *\/\n  memset (seen, 0, BGP_ATTR_BITMAP_SIZE);\n\n  \/* End pointer of BGP attribute. *\/\n  endp = BGP_INPUT_PNT (peer) + size;\n  \n  \/* Get attributes to the end of attribute length. *\/\n  while (BGP_INPUT_PNT (peer) < endp)\n    {\n      \/* Check remaining length check.*\/\n      if (endp - BGP_INPUT_PNT (peer) < BGP_ATTR_MIN_LEN)\n\t{\n\t  \/* XXX warning: long int format, int arg (arg 5) *\/\n\t  zlog (peer->log, LOG_WARNING, \n\t\t\"%s: error BGP attribute length %lu is smaller than min len\",\n\t\tpeer->host,\n\t\t(unsigned long) (endp - STREAM_PNT (BGP_INPUT (peer))));\n\n\t  bgp_notify_send (peer, \n\t\t\t   BGP_NOTIFY_UPDATE_ERR, \n\t\t\t   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t  return BGP_ATTR_PARSE_ERROR;\n\t}\n\n      \/* Fetch attribute flag and type. *\/\n      startp = BGP_INPUT_PNT (peer);\n      \/* \"The lower-order four bits of the Attribute Flags octet are\n         unused.  They MUST be zero when sent and MUST be ignored when\n         received.\" *\/\n      flag = 0xF0 & stream_getc (BGP_INPUT (peer));\n      type = stream_getc (BGP_INPUT (peer));\n\n      \/* Check whether Extended-Length applies and is in bounds *\/\n      if (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN)\n          && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1)))\n\t{\n\t  zlog (peer->log, LOG_WARNING, \n\t\t\"%s: Extended length set, but just %lu bytes of attr header\",\n\t\tpeer->host,\n\t\t(unsigned long) (endp - STREAM_PNT (BGP_INPUT (peer))));\n\n\t  bgp_notify_send (peer, \n\t\t\t   BGP_NOTIFY_UPDATE_ERR, \n\t\t\t   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t  return BGP_ATTR_PARSE_ERROR;\n\t}\n      \n      \/* Check extended attribue length bit. *\/\n      if (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN))\n\tlength = stream_getw (BGP_INPUT (peer));\n      else\n\tlength = stream_getc (BGP_INPUT (peer));\n      \n      \/* If any attribute appears more than once in the UPDATE\n\t message, then the Error Subcode is set to Malformed Attribute\n\t List. *\/\n\n      if (CHECK_BITMAP (seen, type))\n\t{\n\t  zlog (peer->log, LOG_WARNING,\n\t\t\"%s: error BGP attribute type %d appears twice in a message\",\n\t\tpeer->host, type);\n\n\t  bgp_notify_send (peer, \n\t\t\t   BGP_NOTIFY_UPDATE_ERR, \n\t\t\t   BGP_NOTIFY_UPDATE_MAL_ATTR);\n\t  return BGP_ATTR_PARSE_ERROR;\n\t}\n\n      \/* Set type to bitmap to check duplicate attribute.  `type' is\n\t unsigned char so it never overflow bitmap range. *\/\n\n      SET_BITMAP (seen, type);\n\n      \/* Overflow check. *\/\n      attr_endp =  BGP_INPUT_PNT (peer) + length;\n\n      if (attr_endp > endp)\n\t{\n\t  zlog (peer->log, LOG_WARNING, \n\t\t\"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\", peer->host, type, length, size, attr_endp, endp);\n\t  bgp_notify_send (peer, \n\t\t\t   BGP_NOTIFY_UPDATE_ERR, \n\t\t\t   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t  return BGP_ATTR_PARSE_ERROR;\n\t}\n\t\n        struct bgp_attr_parser_args attr_args = {\n          .peer = peer,\n          .length = length,\n          .attr = attr,\n          .type = type,\n          .flags = flag,\n          .startp = startp,\n          .total = attr_endp - startp,\n        };\n      \n\t\n      \/* If any recognized attribute has Attribute Flags that conflict\n         with the Attribute Type Code, then the Error Subcode is set to\n         Attribute Flags Error.  The Data field contains the erroneous\n         attribute (type, length and value). *\/\n      if (bgp_attr_flag_invalid (&attr_args))\n        {\n          bgp_attr_parse_ret_t ret;\n          ret = bgp_attr_malformed (&attr_args,\n                                    BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n                                    attr_args.total);\n          if (ret == BGP_ATTR_PARSE_PROCEED)\n            continue;\n          return ret;\n        }\n\n      \/* OK check attribute and store it's value. *\/\n      switch (type)\n\t{\n\tcase BGP_ATTR_ORIGIN:\n\t  ret = bgp_attr_origin (&attr_args);\n\t  break;\n\tcase BGP_ATTR_AS_PATH:\n\t  ret = bgp_attr_aspath (&attr_args);\n\t  break;\n\tcase BGP_ATTR_AS4_PATH:\n\t  ret = bgp_attr_as4_path (&attr_args, &as4_path);\n\t  break;\n\tcase BGP_ATTR_NEXT_HOP:\t\n\t  ret = bgp_attr_nexthop (&attr_args);\n\t  break;\n\tcase BGP_ATTR_MULTI_EXIT_DISC:\n\t  ret = bgp_attr_med (&attr_args);\n\t  break;\n\tcase BGP_ATTR_LOCAL_PREF:\n\t  ret = bgp_attr_local_pref (&attr_args);\n\t  break;\n\tcase BGP_ATTR_ATOMIC_AGGREGATE:\n\t  ret = bgp_attr_atomic (&attr_args);\n\t  break;\n\tcase BGP_ATTR_AGGREGATOR:\n\t  ret = bgp_attr_aggregator (&attr_args);\n\t  break;\n\tcase BGP_ATTR_AS4_AGGREGATOR:\n\t  ret = bgp_attr_as4_aggregator (&attr_args,\n\t                                 &as4_aggregator,\n\t                                 &as4_aggregator_addr);\n\t  break;\n\tcase BGP_ATTR_COMMUNITIES:\n\t  ret = bgp_attr_community (&attr_args);\n\t  break;\n\tcase BGP_ATTR_ORIGINATOR_ID:\n\t  ret = bgp_attr_originator_id (&attr_args);\n\t  break;\n\tcase BGP_ATTR_CLUSTER_LIST:\n\t  ret = bgp_attr_cluster_list (&attr_args);\n\t  break;\n\tcase BGP_ATTR_MP_REACH_NLRI:\n\t  ret = bgp_mp_reach_parse (&attr_args, mp_update);\n\t  break;\n\tcase BGP_ATTR_MP_UNREACH_NLRI:\n\t  ret = bgp_mp_unreach_parse (&attr_args, mp_withdraw);\n\t  break;\n\tcase BGP_ATTR_EXT_COMMUNITIES:\n\t  ret = bgp_attr_ext_communities (&attr_args);\n\t  break;\n\tdefault:\n\t  ret = bgp_attr_unknown (&attr_args);\n\t  break;\n\t}\n      \n      \/* If hard error occured immediately return to the caller. *\/\n      if (ret == BGP_ATTR_PARSE_ERROR)\n        {\n          zlog (peer->log, LOG_WARNING,\n                \"%s: Attribute %s, parse error\", \n                peer->host, \n                LOOKUP (attr_str, type));\n          bgp_notify_send (peer, \n                           BGP_NOTIFY_UPDATE_ERR,\n                           BGP_NOTIFY_UPDATE_MAL_ATTR);\n          if (as4_path)\n            aspath_unintern (&as4_path);\n          return ret;\n        }\n      if (ret == BGP_ATTR_PARSE_WITHDRAW)\n        {\n          \n          zlog (peer->log, LOG_WARNING,\n                \"%s: Attribute %s, parse error - treating as withdrawal\",\n                peer->host,\n                LOOKUP (attr_str, type));\n          if (as4_path)\n            aspath_unintern (&as4_path);\n          return ret;\n        }\n      \n      \/* Check the fetched length. *\/\n      if (BGP_INPUT_PNT (peer) != attr_endp)\n\t{\n\t  zlog (peer->log, LOG_WARNING, \n\t\t\"%s: BGP attribute %s, fetch error\", \n                peer->host, LOOKUP (attr_str, type));\n\t  bgp_notify_send (peer, \n\t\t\t   BGP_NOTIFY_UPDATE_ERR, \n\t\t\t   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n          if (as4_path)\n            aspath_unintern (&as4_path);\n\t  return BGP_ATTR_PARSE_ERROR;\n\t}\n    }\n\n  \/* Check final read pointer is same as end pointer. *\/\n  if (BGP_INPUT_PNT (peer) != endp)\n    {\n      zlog (peer->log, LOG_WARNING, \n\t    \"%s: BGP attribute %s, length mismatch\",\n\t    peer->host, LOOKUP (attr_str, type));\n      bgp_notify_send (peer, \n\t\t       BGP_NOTIFY_UPDATE_ERR, \n\t\t       BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n      if (as4_path)\n        aspath_unintern (&as4_path);\n      return BGP_ATTR_PARSE_ERROR;\n    }\n\n  \/* \n   * At this place we can see whether we got AS4_PATH and\/or\n   * AS4_AGGREGATOR from a 16Bit peer and act accordingly.\n   * We can not do this before we've read all attributes because\n   * the as4 handling does not say whether AS4_PATH has to be sent\n   * after AS_PATH or not - and when AS4_AGGREGATOR will be send\n   * in relationship to AGGREGATOR.\n   * So, to be defensive, we are not relying on any order and read\n   * all attributes first, including these 32bit ones, and now,\n   * afterwards, we look what and if something is to be done for as4.\n   *\/\n  if (bgp_attr_munge_as4_attrs (peer, attr, as4_path,\n                                as4_aggregator, &as4_aggregator_addr))\n    {\n      if (as4_path)\n        aspath_unintern (&as4_path);\n      return BGP_ATTR_PARSE_ERROR;\n    }\n\n  \/* At this stage, we have done all fiddling with as4, and the\n   * resulting info is in attr->aggregator resp. attr->aspath\n   * so we can chuck as4_aggregator and as4_path alltogether in\n   * order to save memory\n   *\/\n  if (as4_path)\n    {\n      aspath_unintern (&as4_path); \/* unintern - it is in the hash *\/\n      \/* The flag that we got this is still there, but that does not\n       * do any trouble\n       *\/\n    }\n  \/*\n   * The \"rest\" of the code does nothing with as4_aggregator.\n   * there is no memory attached specifically which is not part\n   * of the attr.\n   * so ignoring just means do nothing.\n   *\/\n  \/*\n   * Finally do the checks on the aspath we did not do yet\n   * because we waited for a potentially synthesized aspath.\n   *\/\n  if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))\n    {\n      ret = bgp_attr_aspath_check (peer, attr);\n      if (ret != BGP_ATTR_PARSE_PROCEED)\n\treturn ret;\n    }\n\n  \/* Finally intern unknown attribute. *\/\n  if (attr->extra && attr->extra->transit)\n    attr->extra->transit = transit_intern (attr->extra->transit);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)\n{\n  uerr_t err;\n  char *uf;                     \/* url file name *\/\n  char *lf;                     \/* list file name *\/\n  char *old_target = con->target;\n\n  con->st &= ~ON_YOUR_OWN;\n  con->cmd |= (DO_LIST | LEAVE_PENDING);\n  con->cmd &= ~DO_RETR;\n\n  \/* Find the listing file name.  We do it by taking the file name of\n     the URL and replacing the last component with the listing file\n     name.  *\/\n  uf = url_file_name (u, NULL);\n  lf = file_merge (uf, LIST_FILENAME);\n  xfree (uf);\n  DEBUGP ((_(\"Using %s as listing tmp file.\\n\"), quote (lf)));\n\n  con->target = xstrdup (lf);\n  xfree (lf);\n  err = ftp_loop_internal (u, NULL, con, NULL, false);\n  lf = xstrdup (con->target);\n  xfree (con->target);\n  con->target = old_target;\n\n  if (err == RETROK)\n    {\n      *f = ftp_parse_ls (lf, con->rs);\n      if (opt.remove_listing)\n        {\n          if (unlink (lf))\n            logprintf (LOG_NOTQUIET, \"unlink: %s\\n\", strerror (errno));\n          else\n            logprintf (LOG_VERBOSE, _(\"Removed %s.\\n\"), quote (lf));\n        }\n    }\n  else\n    *f = NULL;\n  xfree (lf);\n  con->cmd &= ~DO_LIST;\n  return err;\n}\n","project":"savannah","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_drop_cmap_imp(fz_context *ctx, fz_storable *cmap_)\n{\n\tpdf_cmap *cmap = (pdf_cmap *)cmap_;\n\tpdf_drop_cmap(ctx, cmap->usecmap);\n\tfz_free(ctx, cmap->ranges);\n\tfz_free(ctx, cmap->xranges);\n\tfz_free(ctx, cmap->mranges);\n\tfz_free(ctx, cmap->dict);\n\tfz_free(ctx, cmap->tree);\n\tfz_free(ctx, cmap);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const SeekHead::VoidElement* SeekHead::GetVoidElement(int idx) const\n{\n    if (idx < 0)\n        return 0;\n    if (idx >= m_void_element_count)\n        return 0;\n    return m_void_elements + idx;\n}\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::useBuffer(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b\/25884056\");\n return BAD_VALUE;\n\n     }\n \n     Mutex::Autolock autoLock(mLock);\n    if (allottedSize > params->size()) {\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n     OMX_ERRORTYPE err = OMX_UseBuffer(\n             mHandle, &header, portIndex, buffer_meta,\n            allottedSize, static_cast<OMX_U8 *>(params->pointer()));\n \n     if (err != OMX_ErrorNone) {\n         CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(\n                portIndex, (size_t)allottedSize, params->pointer()));\n \n         delete buffer_meta;\n         buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, buffer_meta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u(%zu)@%p\", allottedSize, params->size(), params->pointer()));\n return OK;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"int php_openssl_apply_verification_policy(SSL *ssl, X509 *peer, php_stream *stream TSRMLS_DC) \/* {{{ *\/\n{\n\tzval **val = NULL;\n\tchar *cnmatch = NULL;\n\tX509_NAME *name;\n\tchar buf[1024];\n\tint err;\n\n\t\/* verification is turned off *\/\n\tif (!(GET_VER_OPT(\"verify_peer\") && zval_is_true(*val))) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (peer == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not get peer certificate\");\n\t\treturn FAILURE;\n\t}\n\n\terr = SSL_get_verify_result(ssl);\n\tswitch (err) {\n\t\tcase X509_V_OK:\n\t\t\t\/* fine *\/\n\t\t\tbreak;\n\t\tcase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n\t\t\tif (GET_VER_OPT(\"allow_self_signed\") && zval_is_true(*val)) {\n\t\t\t\t\/* allowed *\/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\/* not allowed, so fall through *\/\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not verify peer: code:%d %s\", err, X509_verify_cert_error_string(err));\n\t\t\treturn FAILURE;\n\t}\n\n\t\/* if the cert passed the usual checks, apply our own local policies now *\/\n\n\tname = X509_get_subject_name(peer);\n\n\t\/* Does the common name match ? (used primarily for https:\/\/) *\/\n\tGET_VER_OPT_STRING(\"CN_match\", cnmatch);\n\tif (cnmatch) {\n\t\tint match = 0;\n\t\tint name_len = X509_NAME_get_text_by_NID(name, NID_commonName, buf, sizeof(buf));\n\n\t\tif (name_len == -1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to locate peer certificate CN\");\n\t\t\treturn FAILURE;\n\t\t} else if (name_len != strlen(buf)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Peer certificate CN=`%.*s' is malformed\", name_len, buf);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tmatch = strcmp(cnmatch, buf) == 0;\n\t\tif (!match && strlen(buf) > 3 && buf[0] == '*' && buf[1] == '.') {\n\t\t\t\/* Try wildcard *\/\n\n\t\t\tif (strchr(buf+2, '.')) {\n\t\t\t\tchar *tmp = strstr(cnmatch, buf+1);\n\n\t\t\t\tmatch = tmp && strcmp(tmp, buf+2) && tmp == strchr(cnmatch, '.');\n\t\t\t}\n\t\t}\n\n\t\tif (!match) {\n\t\t\t\/* didn't match *\/\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Peer certificate CN=`%.*s' did not match expected CN=`%s'\", name_len, buf, cnmatch);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkey_new)\n{\n\tstruct php_x509_request req;\n\tzval * args = NULL;\n\tzval **data;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|a!\", &args) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tif (args && Z_TYPE_P(args) == IS_ARRAY) {\n\t\tEVP_PKEY *pkey;\n\n\t\tif (zend_hash_find(Z_ARRVAL_P(args), \"rsa\", sizeof(\"rsa\"), (void**)&data) == SUCCESS &&\n\t\t    Z_TYPE_PP(data) == IS_ARRAY) {\n\t\t    pkey = EVP_PKEY_new();\n\t\t    if (pkey) {\n\t\t\t\tRSA *rsa = RSA_new();\n\t\t\t\tif (rsa) {\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, n);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, e);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, d);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, p);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, q);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, dmp1);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, dmq1);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, iqmp);\n\t\t\t\t\tif (rsa->n && rsa->d) {\n\t\t\t\t\t\tif (EVP_PKEY_assign_RSA(pkey, rsa)) {\n\t\t\t\t\t\t\tRETURN_RESOURCE(zend_list_insert(pkey, le_key));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tRSA_free(rsa);\n\t\t\t\t}\n\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t}\n\t\t\tRETURN_FALSE;\n\t\t} else if (zend_hash_find(Z_ARRVAL_P(args), \"dsa\", sizeof(\"dsa\"), (void**)&data) == SUCCESS &&\n\t\t           Z_TYPE_PP(data) == IS_ARRAY) {\n\t\t    pkey = EVP_PKEY_new();\n\t\t    if (pkey) {\n\t\t\t\tDSA *dsa = DSA_new();\n\t\t\t\tif (dsa) {\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, p);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, q);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, g);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, priv_key);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, pub_key);\n\t\t\t\t\tif (dsa->p && dsa->q && dsa->g) {\n\t\t\t\t\t\tif (!dsa->priv_key && !dsa->pub_key) {\n\t\t\t\t\t\t\tDSA_generate_key(dsa);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (EVP_PKEY_assign_DSA(pkey, dsa)) {\n\t\t\t\t\t\t\tRETURN_RESOURCE(zend_list_insert(pkey, le_key));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDSA_free(dsa);\n\t\t\t\t}\n\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t}\n\t\t\tRETURN_FALSE;\n\t\t} else if (zend_hash_find(Z_ARRVAL_P(args), \"dh\", sizeof(\"dh\"), (void**)&data) == SUCCESS &&\n\t\t           Z_TYPE_PP(data) == IS_ARRAY) {\n\t\t    pkey = EVP_PKEY_new();\n\t\t    if (pkey) {\n\t\t\t\tDH *dh = DH_new();\n\t\t\t\tif (dh) {\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dh, p);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dh, g);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dh, priv_key);\n\t\t\t\t\tOPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dh, pub_key);\n\t\t\t\t\tif (dh->p && dh->g) {\n\t\t\t\t\t\tif (!dh->pub_key) {\n\t\t\t\t\t\t\tDH_generate_key(dh);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (EVP_PKEY_assign_DH(pkey, dh)) {\n\t\t\t\t\t\t\tRETURN_RESOURCE(zend_list_insert(pkey, le_key));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDH_free(dh);\n\t\t\t\t}\n\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t}\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} \n\n\tPHP_SSL_REQ_INIT(&req);\n\n\tif (PHP_SSL_REQ_PARSE(&req, args) == SUCCESS)\n\t{\n\t\tif (php_openssl_generate_private_key(&req TSRMLS_CC)) {\n\t\t\t\/* pass back a key resource *\/\n\t\t\tRETVAL_RESOURCE(zend_list_insert(req.priv_key, le_key));\n\t\t\t\/* make sure the cleanup code doesn't zap it! *\/\n\t\t\treq.priv_key = NULL;\n\t\t}\n\t}\n\tPHP_SSL_REQ_DISPOSE(&req);\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Chapters::Edition::~Edition()\n{\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void bgr_to_rgb(fz_context *ctx, const fz_colorspace *cs, const float *bgr, float *rgb)\n{\n\trgb[0] = bgr[2];\n\trgb[1] = bgr[1];\n\trgb[2] = bgr[0];\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"SSL *php_SSL_new_from_context(SSL_CTX *ctx, php_stream *stream TSRMLS_DC) \/* {{{ *\/\n{\n\tzval **val = NULL;\n\tchar *cafile = NULL;\n\tchar *capath = NULL;\n\tchar *certfile = NULL;\n\tchar *cipherlist = NULL;\n\tint ok = 1;\n\n\tERR_clear_error();\n\n\t\/* look at context options in the stream and set appropriate verification flags *\/\n\tif (GET_VER_OPT(\"verify_peer\") && zval_is_true(*val)) {\n\n\t\t\/* turn on verification callback *\/\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verify_callback);\n\n\t\t\/* CA stuff *\/\n\t\tGET_VER_OPT_STRING(\"cafile\", cafile);\n\t\tGET_VER_OPT_STRING(\"capath\", capath);\n\n\t\tif (cafile || capath) {\n\t\t\tif (!SSL_CTX_load_verify_locations(ctx, cafile, capath)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to set verify locations `%s' `%s'\", cafile, capath);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (GET_VER_OPT(\"verify_depth\")) {\n\t\t\tconvert_to_long_ex(val);\n\t\t\tSSL_CTX_set_verify_depth(ctx, Z_LVAL_PP(val));\n\t\t}\n\t} else {\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\t\/* callback for the passphrase (for localcert) *\/\n\tif (GET_VER_OPT(\"passphrase\")) {\n\t\tSSL_CTX_set_default_passwd_cb_userdata(ctx, stream);\n\t\tSSL_CTX_set_default_passwd_cb(ctx, passwd_callback);\n\t}\n\n\tGET_VER_OPT_STRING(\"ciphers\", cipherlist);\n\tif (!cipherlist) {\n\t\tcipherlist = \"DEFAULT\";\n\t}\n\tif (SSL_CTX_set_cipher_list(ctx, cipherlist) != 1) {\n\t\treturn NULL;\n\t}\n\n\tGET_VER_OPT_STRING(\"local_cert\", certfile);\n\tif (certfile) {\n\t\tX509 *cert = NULL;\n\t\tEVP_PKEY *key = NULL;\n\t\tSSL *tmpssl;\n\t\tchar resolved_path_buff[MAXPATHLEN];\n\t\tconst char * private_key = NULL;\n\n\t\tif (VCWD_REALPATH(certfile, resolved_path_buff)) {\n\t\t\t\/* a certificate to use for authentication *\/\n\t\t\tif (SSL_CTX_use_certificate_chain_file(ctx, resolved_path_buff) != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to set local cert chain file `%s'; Check that your cafile\/capath settings include details of your certificate and its issuer\", certfile);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tGET_VER_OPT_STRING(\"local_pk\", private_key);\n\n\t\t\tif (private_key) {\n\t\t\t\tchar resolved_path_buff_pk[MAXPATHLEN];\n\t\t\t\tif (VCWD_REALPATH(private_key, resolved_path_buff_pk)) {\n\t\t\t\t\tif (SSL_CTX_use_PrivateKey_file(ctx, resolved_path_buff_pk, SSL_FILETYPE_PEM) != 1) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to set private key file `%s'\", resolved_path_buff_pk);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (SSL_CTX_use_PrivateKey_file(ctx, resolved_path_buff, SSL_FILETYPE_PEM) != 1) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to set private key file `%s'\", resolved_path_buff);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\t\t\n\t\t\t}\n\n\t\t\ttmpssl = SSL_new(ctx);\n\t\t\tcert = SSL_get_certificate(tmpssl);\n\n\t\t\tif (cert) {\n\t\t\t\tkey = X509_get_pubkey(cert);\n\t\t\t\tEVP_PKEY_copy_parameters(key, SSL_get_privatekey(tmpssl));\n\t\t\t\tEVP_PKEY_free(key);\n\t\t\t}\n\t\t\tSSL_free(tmpssl);\n\n\t\t\tif (!SSL_CTX_check_private_key(ctx)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Private key does not match certificate!\");\n\t\t\t}\n\t\t}\n\t}\n\tif (ok) {\n\t\tSSL *ssl = SSL_new(ctx);\n\n\t\tif (ssl) {\n\t\t\t\/* map SSL => stream *\/\n\t\t\tSSL_set_ex_data(ssl, ssl_stream_data_index, stream);\n\t\t}\n\t\treturn ssl;\n\t}\n\n\treturn NULL;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"45737cb776625f17384540523674761e6313e6d4","func":"SampleTable::~SampleTable() {\n delete[] mSampleToChunkEntries;\n    mSampleToChunkEntries = NULL;\n\n delete[] mSyncSamples;\n    mSyncSamples = NULL;\n\n delete mCompositionDeltaLookup;\n    mCompositionDeltaLookup = NULL;\n\n delete[] mCompositionTimeDeltaEntries;\n    mCompositionTimeDeltaEntries = NULL;\n\n\n     delete[] mSampleTimeEntries;\n     mSampleTimeEntries = NULL;\n \n    delete[] mTimeToSample;\n    mTimeToSample = NULL;\n     delete mSampleIterator;\n     mSampleIterator = NULL;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"BlockEntry::~BlockEntry()\n{\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAACEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            aacParams->nBitRate = mBitRate;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = OMX_AUDIO_AACObjectMain;\n            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n            aacParams->nChannels = mNumChannels;\n            aacParams->nSampleRate = mSampleRate;\n            aacParams->nFrameLength = 0;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunFwdTxfm(const int16_t *in, int16_t *out, int stride) {\n     fwd_txfm_(in, out, stride, tx_type_);\n   }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_gsave(fz_context *ctx, pdf_run_processor *pr)\n{\n\tif (pr->gtop == pr->gcap-1)\n\t{\n\t\tpr->gstate = fz_resize_array(ctx, pr->gstate, pr->gcap*2, sizeof(pdf_gstate));\n\t\tpr->gcap *= 2;\n\t}\n\n\tmemcpy(&pr->gstate[pr->gtop + 1], &pr->gstate[pr->gtop], sizeof(pdf_gstate));\n\n\tpr->gtop++;\n\tpdf_keep_gstate(ctx, &pr->gstate[pr->gtop]);\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_DP(fz_context *ctx, pdf_processor *proc, const char *tag, pdf_obj *raw, pdf_obj *cooked)\n{\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_pixmap_converter *fz_lookup_pixmap_converter(fz_context *ctx, fz_colorspace *ds, fz_colorspace *ss)\n{\n\tif (ds == NULL)\n\t\treturn fast_any_to_alpha;\n\n\tif (ss == default_gray)\n\t{\n\t\tif (ds == default_rgb) return fast_gray_to_rgb;\n\t\telse if (ds == default_bgr) return fast_gray_to_rgb; \/* bgr == rgb here *\/\n\t\telse if (ds == default_cmyk) return fast_gray_to_cmyk;\n\t\telse return std_conv_pixmap;\n\t}\n\n\telse if (ss == default_rgb)\n\t{\n\t\tif (ds == default_gray) return fast_rgb_to_gray;\n\t\telse if (ds == default_bgr) return fast_rgb_to_bgr;\n\t\telse if (ds == default_cmyk) return fast_rgb_to_cmyk;\n\t\telse return std_conv_pixmap;\n\t}\n\n\telse if (ss == default_bgr)\n\t{\n\t\tif (ds == default_gray) return fast_bgr_to_gray;\n\t\telse if (ds == default_rgb) return fast_rgb_to_bgr; \/* bgr = rgb here *\/\n\t\telse if (ds == default_cmyk) return fast_bgr_to_cmyk;\n\t\telse return std_conv_pixmap;\n\t}\n\n\telse if (ss == default_cmyk)\n\t{\n\t\tif (ds == default_gray) return fast_cmyk_to_gray;\n\t\telse if (ds == default_bgr) return fast_cmyk_to_bgr;\n\t\telse if (ds == default_rgb) return fast_cmyk_to_rgb;\n\t\telse return std_conv_pixmap;\n\t}\n\telse if ((ss == fz_device_rgb(ctx) && ds == fz_device_bgr(ctx)) ||\n\t\t(ds == fz_device_rgb(ctx) && ss == fz_device_bgr(ctx)))\n\t{\n\t\treturn fast_rgb_to_bgr;\n\t}\n\telse\n\t{\n\t\tconst fz_colorspace *ss_base = fz_source_colorspace_cm(ctx, ss);\n\t\tif (ss_base != NULL && fz_colorspace_is_icc(ctx, ds))\n\t\t{\n\t\t\tif (ss_base == ss)\n\t\t\t\treturn icc_conv_pixmap;\n\t\t\telse\n\t\t\t\treturn icc_base_conv_pixmap;\n\t\t}\n\t\telse return std_conv_pixmap;\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"int max_name_length(struct name_list *names)\n{\n\tint max_len = 0;\n\twhile (names != NULL) {\n\t\tstruct name_list *next = names->next;\n\t\tint len = strlen(names->name);\n\n\t\tif (len > max_len)\n\t\t\tmax_len = len;\n\t\tnames = next;\n\t}\n\treturn max_len;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_bgr_to_cmyk(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tint sn = src->n;\n\tint ss = src->s;\n\tint sa = src->alpha;\n\tint dn = dst->n;\n\tint ds = dst->s;\n\tint da = dst->alpha;\n\tptrdiff_t d_line_inc = dst->stride - w * dn;\n\tptrdiff_t s_line_inc = src->stride - w * sn;\n\n\t\/* Spots must match, and we can never drop alpha (but we can invent it) *\/\n\tif ((copy_spots && ss != ds) || (!da && sa))\n\t{\n\t\tassert(\"This should never happen\" == NULL);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Cannot convert between incompatible pixmaps\");\n\t}\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\tif (ss == 0 && ds == 0)\n\t{\n\t\t\/* Common, no spots case *\/\n\t\tif (da)\n\t\t{\n\t\t\tif (sa)\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char c = s[2];\n\t\t\t\t\t\tunsigned char m = s[1];\n\t\t\t\t\t\tunsigned char y = s[0];\n\t\t\t\t\t\tunsigned char k = (unsigned char)fz_mini(c, fz_mini(m, y));\n\t\t\t\t\t\td[0] = c - k;\n\t\t\t\t\t\td[1] = m - k;\n\t\t\t\t\t\td[2] = y - k;\n\t\t\t\t\t\td[3] = k;\n\t\t\t\t\t\td[4] = s[3];\n\t\t\t\t\t\ts += 4;\n\t\t\t\t\t\td += 5;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char c = s[2];\n\t\t\t\t\t\tunsigned char m = s[1];\n\t\t\t\t\t\tunsigned char y = s[0];\n\t\t\t\t\t\tunsigned char k = (unsigned char)fz_mini(c, fz_mini(m, y));\n\t\t\t\t\t\td[0] = c - k;\n\t\t\t\t\t\td[1] = m - k;\n\t\t\t\t\t\td[2] = y - k;\n\t\t\t\t\t\td[3] = k;\n\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\ts += 3;\n\t\t\t\t\t\td += 5;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\tunsigned char c = s[2];\n\t\t\t\t\tunsigned char m = s[1];\n\t\t\t\t\tunsigned char y = s[0];\n\t\t\t\t\tunsigned char k = (unsigned char)fz_mini(c, fz_mini(m, y));\n\t\t\t\t\td[0] = c - k;\n\t\t\t\t\td[1] = m - k;\n\t\t\t\t\td[2] = y - k;\n\t\t\t\t\td[3] = k;\n\t\t\t\t\ts += 3;\n\t\t\t\t\td += 4;\n\t\t\t\t}\n\t\t\t\td += d_line_inc;\n\t\t\t\ts += s_line_inc;\n\t\t\t}\n\t\t}\n\t}\n\telse if (copy_spots)\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\twhile (h--)\n\t\t{\n\t\t\tint i;\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tunsigned char c = s[2];\n\t\t\t\tunsigned char m = s[1];\n\t\t\t\tunsigned char y = s[0];\n\t\t\t\tunsigned char k = (unsigned char)fz_mini(c, fz_mini(m, y));\n\t\t\t\td[0] = c - k;\n\t\t\t\td[1] = m - k;\n\t\t\t\td[2] = y - k;\n\t\t\t\td[3] = k;\n\t\t\t\ts += 3;\n\t\t\t\td += 4;\n\t\t\t\tfor (i=ss; i > 0; i--)\n\t\t\t\t\t*d++ = *s++;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = sa ? *s++ : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tunsigned char c = s[2];\n\t\t\t\tunsigned char m = s[1];\n\t\t\t\tunsigned char y = s[0];\n\t\t\t\tunsigned char k = (unsigned char)(255 - fz_maxi(c, fz_maxi(m, y)));\n\t\t\t\td[0] = c + k;\n\t\t\t\td[1] = m + k;\n\t\t\t\td[2] = y + k;\n\t\t\t\td[3] = 255 - k;\n\t\t\t\ts += sn;\n\t\t\t\td += dn;\n\t\t\t\tif (da)\n\t\t\t\t\td[-1] = sa ? s[-1] : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Block* Track::EOSBlock::GetBlock() const\n{\n    return NULL;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"unsigned int subpel_avg_variance_ref(const uint8_t *ref,\n                                     const uint8_t *src,\n                                     const uint8_t *second_pred,\n                                     int l2w, int l2h,\n                                     int xoff, int yoff,\n                                     unsigned int *sse_ptr) {\n  int se = 0;\n  unsigned int sse = 0;\n  const int w = 1 << l2w, h = 1 << l2h;\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) {\n      const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n      const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n      const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n      const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n      const int r = a + (((b - a) * yoff + 8) >> 4);\n      int diff = ((r + second_pred[w * y + x] + 1) >> 1) - src[w * y + x];\n      se += diff;\n      sse += diff * diff;\n    }\n  }\n  *sse_ptr = sse;\n  return sse - (((int64_t) se * se) >> (l2w + l2h));\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void usage_exit() {\n   fprintf(stderr,\n           \"Usage: %s <codec> <width> <height> <infile> <outfile> \"\n               \"<keyframe-interval> [<error-resilient>]\\nSee comments in \"\n \"simple_encoder.c for more information.\\n\",\n          exec_name);\n\n   exit(EXIT_FAILURE);\n }\n","project":"Android","target":1},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_retrieve_dirs (struct url *u, struct fileinfo *f, ccon *con)\n{\n  char *container = NULL;\n  int container_size = 0;\n\n  for (; f; f = f->next)\n    {\n      int size;\n      char *odir, *newdir;\n\n      if (opt.quota && total_downloaded_bytes > opt.quota)\n        break;\n      if (f->type != FT_DIRECTORY)\n        continue;\n\n      \/* Allocate u->dir off stack, but reallocate only if a larger\n         string is needed.  It's a pity there's no \"realloca\" for an\n         item on the bottom of the stack.  *\/\n      size = strlen (u->dir) + 1 + strlen (f->name) + 1;\n      if (size > container_size)\n        container = (char *)alloca (size);\n      newdir = container;\n\n      odir = u->dir;\n      if (*odir == '\\0'\n          || (*odir == '\/' && *(odir + 1) == '\\0'))\n        \/* If ODIR is empty or just \"\/\", simply append f->name to\n           ODIR.  (In the former case, to preserve u->dir being\n           relative; in the latter case, to avoid double slash.)  *\/\n        sprintf (newdir, \"%s%s\", odir, f->name);\n      else\n        \/* Else, use a separator. *\/\n        sprintf (newdir, \"%s\/%s\", odir, f->name);\n\n      DEBUGP ((\"Composing new CWD relative to the initial directory.\\n\"));\n      DEBUGP ((\"  odir = '%s'\\n  f->name = '%s'\\n  newdir = '%s'\\n\\n\",\n               odir, f->name, newdir));\n      if (!accdir (newdir))\n        {\n          logprintf (LOG_VERBOSE, _(\"\\\nNot descending to %s as it is excluded\/not-included.\\n\"),\n                     quote (newdir));\n          continue;\n        }\n\n      con->st &= ~DONE_CWD;\n\n      odir = xstrdup (u->dir);  \/* because url_set_dir will free\n                                   u->dir. *\/\n      url_set_dir (u, newdir);\n      ftp_retrieve_glob (u, con, GLOB_GETALL);\n      url_set_dir (u, odir);\n      xfree (odir);\n\n      \/* Set the time-stamp?  *\/\n    }\n\n  if (opt.quota && total_downloaded_bytes > opt.quota)\n    return QUOTEXC;\n  else\n    return RETROK;\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  ConvolveFunctions(convolve_fn_t h8, convolve_fn_t h8_avg,\n                    convolve_fn_t v8, convolve_fn_t v8_avg,\n                    convolve_fn_t hv8, convolve_fn_t hv8_avg)\n      : h8_(h8), v8_(v8), hv8_(hv8), h8_avg_(h8_avg), v8_avg_(v8_avg),\n        hv8_avg_(hv8_avg) {}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Chapters::Display::Display()\n{\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_random_pseudo_bytes)\n{\n\tlong buffer_length;\n\tunsigned char *buffer = NULL;\n\tzval *zstrong_result_returned = NULL;\n\tint strong_result = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|z\", &buffer_length, &zstrong_result_returned) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (buffer_length <= 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zstrong_result_returned) {\n\t\tzval_dtor(zstrong_result_returned);\n\t\tZVAL_BOOL(zstrong_result_returned, 0);\n\t}\n\n\tbuffer = emalloc(buffer_length + 1);\n\n\tif ((strong_result = RAND_pseudo_bytes(buffer, buffer_length)) < 0) {\n\t\tefree(buffer);\n\t\tRETURN_FALSE;\n\t}\n\n\tbuffer[buffer_length] = 0;\n\tRETVAL_STRINGL((char *)buffer, buffer_length, 0);\n\n\tif (zstrong_result_returned) {\n\t\tZVAL_BOOL(zstrong_result_returned, strong_result);\n\t}\n}\n","project":"php","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_pending(const SSL *s)\n\t{\n\tif (s->rstate == SSL_ST_READ_BODY)\n\t\treturn 0;\n\t\n\treturn (s->s3->rrec.type == SSL3_RT_APPLICATION_DATA) ? s->s3->rrec.length : 0;\n\t}\n","project":"openssl","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Segment::GetDuration() const\n{\n    assert(m_pInfo);\n    return m_pInfo->GetDuration();\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"const char *fz_colorspace_colorant(fz_context *ctx, const fz_colorspace *cs, int i)\n{\n\tif (!cs || i < 0 || i >= cs->n)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Colorant out of range\");\n\n\treturn cs->colorant[i];\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n     if (video->frame() == 1) {\n       encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n     }\n   }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int php_openssl_is_private_key(EVP_PKEY* pkey TSRMLS_DC)\n{\n\tassert(pkey != NULL);\n\n\tswitch (pkey->type) {\n#ifndef NO_RSA\n\t\tcase EVP_PKEY_RSA:\n\t\tcase EVP_PKEY_RSA2:\n\t\t\tassert(pkey->pkey.rsa != NULL);\n\t\t\tif (pkey->pkey.rsa != NULL && (NULL == pkey->pkey.rsa->p || NULL == pkey->pkey.rsa->q)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifndef NO_DSA\n\t\tcase EVP_PKEY_DSA:\n\t\tcase EVP_PKEY_DSA1:\n\t\tcase EVP_PKEY_DSA2:\n\t\tcase EVP_PKEY_DSA3:\n\t\tcase EVP_PKEY_DSA4:\n\t\t\tassert(pkey->pkey.dsa != NULL);\n\n\t\t\tif (NULL == pkey->pkey.dsa->p || NULL == pkey->pkey.dsa->q || NULL == pkey->pkey.dsa->priv_key){ \n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifndef NO_DH\n\t\tcase EVP_PKEY_DH:\n\t\t\tassert(pkey->pkey.dh != NULL);\n\n\t\t\tif (NULL == pkey->pkey.dh->p || NULL == pkey->pkey.dh->priv_key) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key type not supported in this PHP build!\");\n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Segment::DoParseNext(\n    const Cluster*& pResult,\n    long long& pos,\n    long& len)\n{\n    long long total, avail;\n \n    long status = m_pReader->Length(&total, &avail);\n \n    if (status < 0)  \/\/error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n \n \n    long long off_next = 0;\n    long long cluster_size = -1;\n \n    for (;;)\n     {\n        if ((total >= 0) && (pos >= total))\n            return 1;  \/\/EOF\n \n        if ((segment_stop >= 0) && (pos >= segment_stop))\n            return 1;  \/\/EOF\n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(m_pReader, pos, len);\n \n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n \n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n \n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long idpos = pos;             \/\/absolute\n        const long long idoff = pos - m_start;   \/\/relative\n \n        const long long id = ReadUInt(m_pReader, idpos, len);  \/\/absolute\n \n        if (id < 0)  \/\/error\n            return static_cast<long>(id);\n \n        if (id == 0)  \/\/weird\n            return -1;  \/\/generic error\n \n        pos += len;  \/\/consume ID\n \n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        result = GetUIntLength(m_pReader, pos, len);\n \n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n \n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n \n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long size = ReadUInt(m_pReader, pos, len);\n \n        if (size < 0)  \/\/error\n            return static_cast<long>(size);\n \n        pos += len;  \/\/consume length of size of element\n \n \n        if (size == 0)  \/\/weird\n            continue;\n \n        const long long unknown_size = (1LL << (7 * len)) - 1;\n \n        if ((segment_stop >= 0) &&\n            (size != unknown_size) &&\n            ((pos + size) > segment_stop))\n        {\n            return E_FILE_FORMAT_INVALID;\n        }\n \n        if (id == 0x0C53BB6B)  \/\/Cues ID\n        {\n            if (size == unknown_size)\n                return E_FILE_FORMAT_INVALID;\n \n            const long long element_stop = pos + size;\n \n            if ((segment_stop >= 0) && (element_stop > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n \n            const long long element_start = idpos;\n            const long long element_size = element_stop - element_start;\n \n            if (m_pCues == NULL)\n            {\n                m_pCues = new Cues(this,\n                                    pos,\n                                    size,\n                                    element_start,\n                                    element_size);\n                assert(m_pCues);  \/\/TODO\n            }\n \n            pos += size;  \/\/consume payload\n            assert((segment_stop < 0) || (pos <= segment_stop));\n \n            continue;\n        }\n \n        if (id != 0x0F43B675)  \/\/not a Cluster ID\n        {\n            if (size == unknown_size)\n                return E_FILE_FORMAT_INVALID;\n \n            pos += size;  \/\/consume payload\n            assert((segment_stop < 0) || (pos <= segment_stop));\n \n            continue;\n        }\n \n#if 0 \/\/this is commented-out to support incremental cluster parsing\n         len = static_cast<long>(size);\n \n         if (element_stop > avail)\n             return E_BUFFER_NOT_FULL;\n #endif\n \n \n        off_next = idoff;\n \n        if (size != unknown_size)\n            cluster_size = size;\n \n         break;\n    }\n \n    assert(off_next > 0);  \/\/have cluster\n \n \n    Cluster** const ii = m_clusters + m_clusterCount;\n    Cluster** i = ii;\n \n    Cluster** const jj = ii + m_clusterPreloadCount;\n    Cluster** j = jj;\n \n    while (i < j)\n    {\n \n        Cluster** const k = i + (j - i) \/ 2;\n        assert(k < jj);\n \n        const Cluster* const pNext = *k;\n        assert(pNext);\n        assert(pNext->m_index < 0);\n \n        pos = pNext->GetPosition();\n        assert(pos >= 0);\n \n        if (pos < off_next)\n            i = k + 1;\n        else if (pos > off_next)\n            j = k;\n        else\n        {\n            pResult = pNext;\n            return 0;  \/\/success\n        }\n    }\n \n    assert(i == j);\n \n    long long pos_;\n    long len_;\n \n    status = Cluster::HasBlockEntries(this, off_next, pos_, len_);\n \n    if (status < 0)  \/\/error or underflow\n    {\n        pos = pos_;\n        len = len_;\n \n        return status;\n    }\n \n    if (status > 0)  \/\/means \"found at least one block entry\"\n    {\n        Cluster* const pNext = Cluster::Create(this,\n                                                -1,   \/\/preloaded\n                                                off_next);\n        assert(pNext);\n \n        const ptrdiff_t idx_next = i - m_clusters;  \/\/insertion position\n \n        PreloadCluster(pNext, idx_next);\n        assert(m_clusters);\n        assert(idx_next < m_clusterSize);\n        assert(m_clusters[idx_next] == pNext);\n \n        pResult = pNext;\n        return 0;  \/\/success\n    }\n \n \n    if (cluster_size < 0)  \/\/unknown size\n    {\n        const long long payload_pos = pos;  \/\/absolute pos of cluster payload\n \n        for (;;)  \/\/determine cluster size\n        {\n            if ((total >= 0) && (pos >= total))\n                break;\n \n            if ((segment_stop >= 0) && (pos >= segment_stop))\n                break;  \/\/no more clusters\n \n \n            if ((pos + 1) > avail)\n            {\n                len = 1;\n                return E_BUFFER_NOT_FULL;\n            }\n \n            long long result = GetUIntLength(m_pReader, pos, len);\n \n            if (result < 0)  \/\/error\n                return static_cast<long>(result);\n \n            if (result > 0)  \/\/weird\n                return E_BUFFER_NOT_FULL;\n \n            if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n \n            if ((pos + len) > avail)\n                return E_BUFFER_NOT_FULL;\n \n            const long long idpos = pos;\n            const long long id = ReadUInt(m_pReader, idpos, len);\n \n            if (id < 0)  \/\/error (or underflow)\n                return static_cast<long>(id);\n \n \n            if (id == 0x0F43B675)  \/\/Cluster ID\n                break;\n \n            if (id == 0x0C53BB6B)  \/\/Cues ID\n                break;\n            pos += len;  \/\/consume ID (of sub-element)\n            if ((pos + 1) > avail)\n            {\n                len = 1;\n                return E_BUFFER_NOT_FULL;\n            }\n            result = GetUIntLength(m_pReader, pos, len);\n            if (result < 0)  \/\/error\n                return static_cast<long>(result);\n            if (result > 0)  \/\/weird\n                return E_BUFFER_NOT_FULL;\n            if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n            if ((pos + len) > avail)\n                return E_BUFFER_NOT_FULL;\n            const long long size = ReadUInt(m_pReader, pos, len);\n            if (size < 0)  \/\/error\n                return static_cast<long>(size);\n            pos += len;  \/\/consume size field of element\n            if (size == 0)  \/\/weird\n                continue;\n            const long long unknown_size = (1LL << (7 * len)) - 1;\n            if (size == unknown_size)\n                return E_FILE_FORMAT_INVALID;  \/\/not allowed for sub-elements\n            if ((segment_stop >= 0) && ((pos + size) > segment_stop))  \/\/weird\n                return E_FILE_FORMAT_INVALID;\n            pos += size;  \/\/consume payload of sub-element\n            assert((segment_stop < 0) || (pos <= segment_stop));\n        }  \/\/determine cluster size\n        cluster_size = pos - payload_pos;\n        assert(cluster_size >= 0);  \/\/TODO: handle cluster_size = 0\n        pos = payload_pos;  \/\/reset and re-parse original cluster\n    }\n    pos += cluster_size;  \/\/consume payload\n    assert((segment_stop < 0) || (pos <= segment_stop));\n    return 2;             \/\/try to find a cluster that follows next\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_new_indexed_colorspace(fz_context *ctx, fz_colorspace *base, int high, unsigned char *lookup)\n{\n\tfz_colorspace *cs = NULL;\n\tstruct indexed *idx;\n\n\tidx = fz_malloc_struct(ctx, struct indexed);\n\tidx->lookup = lookup;\n\tidx->base = fz_keep_colorspace(ctx, base);\n\tidx->high = high;\n\n\tfz_try(ctx)\n\t\tcs = fz_new_colorspace(ctx, \"Indexed\", FZ_COLORSPACE_INDEXED, 0, 1, fz_colorspace_is_icc(ctx, fz_device_rgb(ctx)) ? indexed_to_alt : indexed_to_rgb, NULL, base_indexed, clamp_indexed, free_indexed, idx, sizeof(*idx) + (base->n * (idx->high + 1)) + base->size);\n\tfz_catch(ctx)\n\t{\n\t\tfz_free(ctx, idx);\n\t\tfz_rethrow(ctx);\n\t}\n\treturn cs;\n}\n","project":"ghostscript","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"int phar_wrapper_mkdir(php_stream_wrapper *wrapper, char *url_from, int mode, int options, php_stream_context *context TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_entry_info entry, *e;\n\tphar_archive_data *phar = NULL;\n\tchar *error, *arch, *entry2;\n\tint arch_len, entry_len;\n\tphp_url *resource = NULL;\n\tuint host_len;\n\n\t\/* pre-readonly check, we need to know if this is a data phar *\/\n\tif (FAILURE == phar_split_fname(url_from, strlen(url_from), &arch, &arch_len, &entry2, &entry_len, 2, 2 TSRMLS_CC)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot create directory \\\"%s\\\", no phar archive specified\", url_from);\n\t\treturn 0;\n\t}\n\n\tif (FAILURE == phar_get_archive(&phar, arch, arch_len, NULL, 0, NULL TSRMLS_CC)) {\n\t\tphar = NULL;\n\t}\n\n\tefree(arch);\n\tefree(entry2);\n\n\tif (PHAR_G(readonly) && (!phar || !phar->is_data)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot create directory \\\"%s\\\", write operations disabled\", url_from);\n\t\treturn 0;\n\t}\n\n\tif ((resource = phar_parse_url(wrapper, url_from, \"w\", options TSRMLS_CC)) == NULL) {\n\t\treturn 0;\n\t}\n\n\t\/* we must have at the very least phar:\/\/alias.phar\/internalfile.php *\/\n\tif (!resource->scheme || !resource->host || !resource->path) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: invalid url \\\"%s\\\"\", url_from);\n\t\treturn 0;\n\t}\n\n\tif (strcasecmp(\"phar\", resource->scheme)) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: not a phar stream url \\\"%s\\\"\", url_from);\n\t\treturn 0;\n\t}\n\n\thost_len = strlen(resource->host);\n\n\tif (FAILURE == phar_get_archive(&phar, resource->host, host_len, NULL, 0, &error TSRMLS_CC)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", error retrieving phar information: %s\", resource->path+1, resource->host, error);\n\t\tefree(error);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\n\tif ((e = phar_get_entry_info_dir(phar, resource->path + 1, strlen(resource->path + 1), 2, &error, 1 TSRMLS_CC))) {\n\t\t\/* directory exists, or is a subdirectory of an existing file *\/\n\t\tif (e->is_temp_dir) {\n\t\t\tefree(e->filename);\n\t\t\tefree(e);\n\t\t}\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", directory already exists\", resource->path+1, resource->host);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\n\tif (error) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", %s\", resource->path+1, resource->host, error);\n\t\tefree(error);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\n\tif (phar_get_entry_info_dir(phar, resource->path + 1, strlen(resource->path + 1), 0, &error, 1 TSRMLS_CC)) {\n\t\t\/* entry exists as a file *\/\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", file already exists\", resource->path+1, resource->host);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\n\tif (error) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", %s\", resource->path+1, resource->host, error);\n\t\tefree(error);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\n\tmemset((void *) &entry, 0, sizeof(phar_entry_info));\n\n\t\/* strip leading \"\/\" *\/\n\tif (phar->is_zip) {\n\t\tentry.is_zip = 1;\n\t}\n\n\tentry.filename = estrdup(resource->path + 1);\n\n\tif (phar->is_tar) {\n\t\tentry.is_tar = 1;\n\t\tentry.tar_type = TAR_DIR;\n\t}\n\n\tentry.filename_len = strlen(resource->path + 1);\n\tphp_url_free(resource);\n\tentry.is_dir = 1;\n\tentry.phar = phar;\n\tentry.is_modified = 1;\n\tentry.is_crc_checked = 1;\n\tentry.flags = PHAR_ENT_PERM_DEF_DIR;\n\tentry.old_flags = PHAR_ENT_PERM_DEF_DIR;\n\n\tif (SUCCESS != zend_hash_add(&phar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", adding to manifest failed\", entry.filename, phar->fname);\n\t\tefree(error);\n\t\tefree(entry.filename);\n\t\treturn 0;\n\t}\n\n\tphar_flush(phar, 0, 0, 0, &error TSRMLS_CC);\n\n\tif (error) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot create directory \\\"%s\\\" in phar \\\"%s\\\", %s\", entry.filename, phar->fname, error);\n\t\tzend_hash_del(&phar->manifest, entry.filename, entry.filename_len);\n\t\tefree(error);\n\t\treturn 0;\n\t}\n\n\tphar_add_virtual_dirs(phar, entry.filename, entry.filename_len TSRMLS_CC);\n\treturn 1;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"delelement (struct fileinfo *f, struct fileinfo **start)\n{\n  struct fileinfo *prev = f->prev;\n  struct fileinfo *next = f->next;\n\n  xfree (f->name);\n  xfree (f->linkto);\n  xfree (f);\n\n  if (next)\n    next->prev = prev;\n  if (prev)\n    prev->next = next;\n  else\n    *start = next;\n  return next;\n}\n","project":"savannah","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_open_entry_fp(phar_entry_info *entry, char **error, int follow_links TSRMLS_DC) \/* {{{ *\/\n{\n\tphp_stream_filter *filter;\n\tphar_archive_data *phar = entry->phar;\n\tchar *filtername;\n\toff_t loc;\n\tphp_stream *ufp;\n\tphar_entry_data dummy;\n\n\tif (follow_links && entry->link) {\n\t\tphar_entry_info *link_entry = phar_get_link_source(entry TSRMLS_CC);\n\t\tif (link_entry && link_entry != entry) {\n\t\t\treturn phar_open_entry_fp(link_entry, error, 1 TSRMLS_CC);\n\t\t}\n\t}\n\n\tif (entry->is_modified) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->fp_type == PHAR_TMP) {\n\t\tif (!entry->fp) {\n\t\t\tentry->fp = php_stream_open_wrapper(entry->tmp, \"rb\", STREAM_MUST_SEEK|0, NULL);\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->fp_type != PHAR_FP) {\n\t\t\/* either newly created or already modified *\/\n\t\treturn SUCCESS;\n\t}\n\n\tif (!phar_get_pharfp(phar TSRMLS_CC)) {\n\t\tif (FAILURE == phar_open_archive_fp(phar TSRMLS_CC)) {\n\t\t\tspprintf(error, 4096, \"phar error: Cannot open phar archive \\\"%s\\\" for reading\", phar->fname);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif ((entry->old_flags && !(entry->old_flags & PHAR_ENT_COMPRESSION_MASK)) || !(entry->flags & PHAR_ENT_COMPRESSION_MASK)) {\n\t\tdummy.internal_file = entry;\n\t\tdummy.phar = phar;\n\t\tdummy.zero = entry->offset;\n\t\tdummy.fp = phar_get_pharfp(phar TSRMLS_CC);\n\t\tif (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tif (!phar_get_entrypufp(entry TSRMLS_CC)) {\n\t\tphar_set_entrypufp(entry, php_stream_fopen_tmpfile() TSRMLS_CC);\n\t\tif (!phar_get_entrypufp(entry TSRMLS_CC)) {\n\t\t\tspprintf(error, 4096, \"phar error: Cannot open temporary file for decompressing phar archive \\\"%s\\\" file \\\"%s\\\"\", phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tdummy.internal_file = entry;\n\tdummy.phar = phar;\n\tdummy.zero = entry->offset;\n\tdummy.fp = phar_get_pharfp(phar TSRMLS_CC);\n\tif (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tufp = phar_get_entrypufp(entry TSRMLS_CC);\n\n\tif ((filtername = phar_decompress_filter(entry, 0)) != NULL) {\n\t\tfilter = php_stream_filter_create(filtername, NULL, 0 TSRMLS_CC);\n\t} else {\n\t\tfilter = NULL;\n\t}\n\n\tif (!filter) {\n\t\tspprintf(error, 4096, \"phar error: unable to read phar \\\"%s\\\" (cannot create %s filter while decompressing file \\\"%s\\\")\", phar->fname, phar_decompress_filter(entry, 1), entry->filename);\n\t\treturn FAILURE;\n\t}\n\n\t\/* now we can safely use proper decompression *\/\n\t\/* save the new offset location within ufp *\/\n\tphp_stream_seek(ufp, 0, SEEK_END);\n\tloc = php_stream_tell(ufp);\n\tphp_stream_filter_append(&ufp->writefilters, filter);\n\tphp_stream_seek(phar_get_entrypfp(entry TSRMLS_CC), phar_get_fp_offset(entry TSRMLS_CC), SEEK_SET);\n\n\tif (entry->uncompressed_filesize) {\n\t\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_entrypfp(entry TSRMLS_CC), ufp, entry->compressed_filesize, NULL)) {\n\t\t\tspprintf(error, 4096, \"phar error: internal corruption of phar \\\"%s\\\" (actual filesize mismatch on file \\\"%s\\\")\", phar->fname, entry->filename);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tphp_stream_filter_flush(filter, 1);\n\tphp_stream_flush(ufp);\n\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\n\tif (php_stream_tell(ufp) - loc != (off_t) entry->uncompressed_filesize) {\n\t\tspprintf(error, 4096, \"phar error: internal corruption of phar \\\"%s\\\" (actual filesize mismatch on file \\\"%s\\\")\", phar->fname, entry->filename);\n\t\treturn FAILURE;\n\t}\n\n\tentry->old_flags = entry->flags;\n\n\t\/* this is now the new location of the file contents within this fp *\/\n\tphar_set_fp_type(entry, PHAR_UFP, loc TSRMLS_CC);\n\tdummy.zero = entry->offset;\n\tdummy.fp = ufp;\n\tif (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 0 TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"void apply_mask(char *perm, const char *mask)\n{\n\twhile (*perm) {\n\t\tif (*mask == '-' && *perm >= 'a' && *perm <= 'z')\n\t\t\t*perm = *perm - 'a' + 'A';\n\t\tperm++;\n\t\tif (*mask)\n\t\t\tmask++;\n\t}\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" int main(int argc, char **argv) {\n FILE *infile = NULL;\n vpx_codec_ctx_t codec;\n vpx_codec_enc_cfg_t cfg;\n int frame_count = 0;\n vpx_image_t raw;\n vpx_codec_err_t res;\n VpxVideoInfo info = {0};\n VpxVideoWriter *writer = NULL;\n const VpxInterface *encoder = NULL;\n const int fps = 30; \/\/ TODO(dkovalev) add command line argument\n const int bitrate = 200; \/\/ kbit\/s TODO(dkovalev) add command line argument\n int keyframe_interval = 0;\n\n const char *codec_arg = NULL;\n const char *width_arg = NULL;\n const char *height_arg = NULL;\n const char *infile_arg = NULL;\n const char *outfile_arg = NULL;\n const char *keyframe_interval_arg = NULL;\n\n  exec_name = argv[0];\n\n if (argc < 7)\n    die(\"Invalid number of arguments\");\n\n  codec_arg = argv[1];\n  width_arg = argv[2];\n  height_arg = argv[3];\n  infile_arg = argv[4];\n  outfile_arg = argv[5];\n  keyframe_interval_arg = argv[6];\n\n  encoder = get_vpx_encoder_by_name(codec_arg);\n if (!encoder)\n     die(\"Unsupported codec.\");\n\n  info.codec_fourcc = encoder->fourcc;\n  info.frame_width = strtol(width_arg, NULL, 0);\n  info.frame_height = strtol(height_arg, NULL, 0);\n  info.time_base.numerator = 1;\n  info.time_base.denominator = fps;\n\n if (info.frame_width <= 0 ||\n      info.frame_height <= 0 ||\n (info.frame_width % 2) != 0 ||\n (info.frame_height % 2) != 0) {\n    die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);\n }\n\n if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n                                             info.frame_height, 1)) {\n    die(\"Failed to allocate image.\");\n }\n\n  keyframe_interval = strtol(keyframe_interval_arg, NULL, 0);\n\n   if (keyframe_interval < 0)\n     die(\"Invalid keyframe interval value.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));\n \n  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \"Failed to get default codec config.\");\n \n  cfg.g_w = info.frame_width;\n  cfg.g_h = info.frame_height;\n  cfg.g_timebase.num = info.time_base.numerator;\n  cfg.g_timebase.den = info.time_base.denominator;\n  cfg.rc_target_bitrate = bitrate;\n  cfg.g_error_resilient = argc > 7 ? strtol(argv[7], NULL, 0) : 0;\n\n  writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);\n if (!writer)\n    die(\"Failed to open %s for writing.\", outfile_arg);\n\n\n   if (!(infile = fopen(infile_arg, \"rb\")))\n     die(\"Failed to open %s for reading.\", infile_arg);\n \n  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n     die_codec(&codec, \"Failed to initialize encoder\");\n \n   while (vpx_img_read(&raw, infile)) {\n     int flags = 0;\n     if (keyframe_interval > 0 && frame_count % keyframe_interval == 0)\n       flags |= VPX_EFLAG_FORCE_KF;\n     encode_frame(&codec, &raw, frame_count++, flags, writer);\n   }\n  encode_frame(&codec, NULL, -1, 0, writer);  \/\/ flush the encoder\n \n   printf(\"\\n\");\n   fclose(infile);\n  printf(\"Processed %d frames.\\n\", frame_count);\n\n  vpx_img_free(&raw);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_writer_close(writer);\n\n return EXIT_SUCCESS;\n}\n","project":"Android","target":1},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"void free_list(struct name_list *names)\n{\n\tstruct name_list *next;\n\n\twhile (names) {\n\t\tnext = names->next;\n\t\tfree(names);\n\t\tnames = next;\n\t}\n}\n","project":"savannah","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_malformed (struct bgp_attr_parser_args *args, u_char subcode,\n                    bgp_size_t length)\n{\n  struct peer *const peer = args->peer; \n  const u_int8_t flags = args->flags;\n  \/* startp and length must be special-cased, as whether or not to\n   * send the attribute data with the NOTIFY depends on the error,\n   * the caller therefore signals this with the seperate length argument\n   *\/\n  u_char *notify_datap = (length > 0 ? args->startp : NULL);\n  \n  \/* Only relax error handling for eBGP peers *\/\n  if (peer_sort (peer) != BGP_PEER_EBGP)\n    {\n      bgp_notify_send_with_data (peer, BGP_NOTIFY_UPDATE_ERR, subcode,\n                                 notify_datap, length);\n      return BGP_ATTR_PARSE_ERROR;\n\n    }\n  \n  \/* Adjust the stream getp to the end of the attribute, in case we can\n   * still proceed but the caller hasn't read all the attribute.\n   *\/\n  stream_set_getp (BGP_INPUT (peer),\n                   (args->startp - STREAM_DATA (BGP_INPUT (peer)))\n                    + args->total);\n  \n  switch (args->type) {\n    \/* where an attribute is relatively inconsequential, e.g. it does not\n     * affect route selection, and can be safely ignored, then any such\n     * attributes which are malformed should just be ignored and the route\n     * processed as normal.\n     *\/\n    case BGP_ATTR_AS4_AGGREGATOR:\n    case BGP_ATTR_AGGREGATOR:\n    case BGP_ATTR_ATOMIC_AGGREGATE:\n      return BGP_ATTR_PARSE_PROCEED;\n    \n    \/* Core attributes, particularly ones which may influence route\n     * selection, should always cause session resets\n     *\/\n    case BGP_ATTR_ORIGIN:\n    case BGP_ATTR_AS_PATH:\n    case BGP_ATTR_NEXT_HOP:\n    case BGP_ATTR_MULTI_EXIT_DISC:\n    case BGP_ATTR_LOCAL_PREF:\n    case BGP_ATTR_COMMUNITIES:\n    case BGP_ATTR_ORIGINATOR_ID:\n    case BGP_ATTR_CLUSTER_LIST:\n    case BGP_ATTR_MP_REACH_NLRI:\n    case BGP_ATTR_MP_UNREACH_NLRI:\n    case BGP_ATTR_EXT_COMMUNITIES:\n      bgp_notify_send_with_data (peer, BGP_NOTIFY_UPDATE_ERR, subcode,\n                                 notify_datap, length);\n      return BGP_ATTR_PARSE_ERROR;\n  }\n  \n  \/* Partial optional attributes that are malformed should not cause\n   * the whole session to be reset. Instead treat it as a withdrawal\n   * of the routes, if possible.\n   *\/\n  if (CHECK_FLAG (flags, BGP_ATTR_FLAG_TRANS)\n      && CHECK_FLAG (flags, BGP_ATTR_FLAG_OPTIONAL)\n      && CHECK_FLAG (flags, BGP_ATTR_FLAG_PARTIAL))\n    return BGP_ATTR_PARSE_WITHDRAW;\n  \n  \/* default to reset *\/\n  return BGP_ATTR_PARSE_ERROR;\n}\n","project":"savannah","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_aggregator (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  int wantedlen = 6;\n  struct attr_extra *attre = bgp_attr_extra_get (attr);\n  \n  \/* peer with AS4 will send 4 Byte AS, peer without will send 2 Byte *\/\n  if (CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV))\n    wantedlen = 8;\n  \n  if (length != wantedlen)\n    {\n      zlog (peer->log, LOG_ERR, \"AGGREGATOR attribute length isn't %u [%u]\",\n            wantedlen, length);\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n  \n  if ( CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV ) )\n    attre->aggregator_as = stream_getl (peer->ibuf);\n  else\n    attre->aggregator_as = stream_getw (peer->ibuf);\n  attre->aggregator_addr.s_addr = stream_get_ipv4 (peer->ibuf);\n\n  \/* Set atomic aggregate flag. *\/\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void fht8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n   vp9_fht8x8_c(in, out, stride, tx_type);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_cmp_link_key(fz_context *ctx, void *k0_, void *k1_)\n{\n\tfz_link_key *k0 = (fz_link_key *)k0_;\n\tfz_link_key *k1 = (fz_link_key *)k1_;\n\treturn k0->proof == k1->proof &&\n\t\tk0->src_extras == k1->src_extras &&\n\t\tk0->dst_extras == k1->dst_extras &&\n\t\tk0->copy_spots == k1->copy_spots &&\n\t\tk0->depth == k1->depth &&\n\t\tk0->rend.bp == k1->rend.bp &&\n\t\tk0->rend.ri == k1->rend.ri &&\n\t\tmemcmp(k0->dst_md5, k1->dst_md5, 16) == 0 &&\n\t\tmemcmp(k0->src_md5, k1->src_md5, 16);\n}\n","project":"ghostscript","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"phar_entry_data *phar_get_or_create_entry_data(char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_archive_data *phar;\n\tphar_entry_info *entry, etemp;\n\tphar_entry_data *ret;\n\tconst char *pcr_error;\n\tchar is_dir;\n\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(path, path_len);\n#endif\n\n\tis_dir = (path_len && path[path_len - 1] == '\/') ? 1 : 0;\n\n\tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {\n\t\treturn NULL;\n\t}\n\n\tif (FAILURE == phar_get_entry_data(&ret, fname, fname_len, path, path_len, mode, allow_dir, error, security TSRMLS_CC)) {\n\t\treturn NULL;\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\n\tif (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar error: invalid path \\\"%s\\\" contains %s\", path, pcr_error);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (phar->is_persistent && FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be created, could not make cached phar writeable\", path, fname);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\t\/* create a new phar data holder *\/\n\tret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));\n\n\t\/* create an entry, this is a new file *\/\n\tmemset(&etemp, 0, sizeof(phar_entry_info));\n\tetemp.filename_len = path_len;\n\tetemp.fp_type = PHAR_MOD;\n\tetemp.fp = php_stream_fopen_tmpfile();\n\n\tif (!etemp.fp) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\t}\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\tetemp.fp_refcount = 1;\n\n\tif (allow_dir == 2) {\n\t\tetemp.is_dir = 1;\n\t\tetemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_DIR;\n\t} else {\n\t\tetemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_FILE;\n\t}\n\tif (is_dir) {\n\t\tetemp.filename_len--; \/* strip trailing \/ *\/\n\t\tpath_len--;\n\t}\n\n\tphar_add_virtual_dirs(phar, path, path_len TSRMLS_CC);\n\tetemp.is_modified = 1;\n\tetemp.timestamp = time(0);\n\tetemp.is_crc_checked = 1;\n\tetemp.phar = phar;\n\tetemp.filename = estrndup(path, path_len);\n\tetemp.is_zip = phar->is_zip;\n\n\tif (phar->is_tar) {\n\t\tetemp.is_tar = phar->is_tar;\n\t\tetemp.tar_type = etemp.is_dir ? TAR_DIR : TAR_FILE;\n\t}\n\n\tif (FAILURE == zend_hash_add(&phar->manifest, etemp.filename, path_len, (void*)&etemp, sizeof(phar_entry_info), (void **) &entry)) {\n\t\tphp_stream_close(etemp.fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar error: unable to add new entry \\\"%s\\\" to phar \\\"%s\\\"\", etemp.filename, phar->fname);\n\t\t}\n\t\tefree(ret);\n\t\tefree(etemp.filename);\n\t\treturn NULL;\n\t}\n\n\tif (!entry) {\n\t\tphp_stream_close(etemp.fp);\n\t\tefree(etemp.filename);\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\t++(phar->refcount);\n\tret->phar = phar;\n\tret->fp = entry->fp;\n\tret->position = ret->zero = 0;\n\tret->for_write = 1;\n\tret->is_zip = entry->is_zip;\n\tret->is_tar = entry->is_tar;\n\tret->internal_file = entry;\n\n\treturn ret;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_colorspace *fz_new_icc_colorspace_from_stream(fz_context *ctx, const char *name, fz_stream *in)\n{\n\tfz_colorspace *cs = NULL;\n\tfz_buffer *buffer = fz_read_all(ctx, in, 1024);\n\tfz_try(ctx)\n\t\tcs = fz_new_icc_colorspace(ctx, name, 0, buffer);\n\tfz_always(ctx)\n\t\tfz_drop_buffer(ctx, buffer);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n\treturn cs;\n}\n","project":"ghostscript","target":0},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"static long timelib_get_zone(char **ptr, int *dst, timelib_time *t, int *tz_not_found, const timelib_tzdb *tzdb)\n{\n\tlong retval = 0;\n\n\t*tz_not_found = 0;\n\n\twhile (**ptr == ' ' || **ptr == '\\t' || **ptr == '(') {\n\t\t++*ptr;\n\t}\n\tif ((*ptr)[0] == 'G' && (*ptr)[1] == 'M' && (*ptr)[2] == 'T' && ((*ptr)[3] == '+' || (*ptr)[3] == '-')) {\n\t\t*ptr += 3;\n\t}\n\tif (**ptr == '+') {\n\t\t++*ptr;\n\t\tt->is_localtime = 1;\n\t\tt->zone_type = TIMELIB_ZONETYPE_OFFSET;\n\t\t*tz_not_found = 0;\n\t\tt->dst = 0;\n\n\t\tretval = -1 * timelib_parse_tz_cor(ptr);\n\t} else if (**ptr == '-') {\n\t\t++*ptr;\n\t\tt->is_localtime = 1;\n\t\tt->zone_type = TIMELIB_ZONETYPE_OFFSET;\n\t\t*tz_not_found = 0;\n\t\tt->dst = 0;\n\n\t\tretval = timelib_parse_tz_cor(ptr);\n\t}\n\twhile (**ptr == ')') {\n\t\t++*ptr;\n\t}\n\treturn retval;\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"free_icc(fz_context *ctx, fz_colorspace *cs)\n{\n\tfz_iccprofile *profile = cs->data;\n\tfz_drop_buffer(ctx, profile->buffer);\n\tfz_cmm_fin_profile(ctx, profile);\n\tfz_free(ctx, profile);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"rgb2bgr(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tdv[0] = sv[2];\n\tdv[1] = sv[1];\n\tdv[2] = sv[0];\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_colorspace_type(fz_context *ctx, fz_colorspace *cs)\n{\n\treturn cs ? cs->type : FZ_COLORSPACE_NONE;\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_drop_cmap(fz_context *ctx, pdf_cmap *cmap)\n{\n\tfz_drop_storable(ctx, &cmap->storable);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool VideoTrack::VetEntry(const BlockEntry* pBlockEntry) const\n{\n    return Track::VetEntry(pBlockEntry) && pBlockEntry->GetBlock()->IsKey();\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_set_default_output_intent(fz_context *ctx, fz_default_colorspaces *default_cs, fz_colorspace *cs)\n{\n\tfz_drop_colorspace(ctx, default_cs->oi);\n\tdefault_cs->oi = fz_keep_colorspace(ctx, cs);\n\n\tswitch (cs->n)\n\t{\n\tcase 1:\n\t\tif (default_cs->gray == fz_device_gray(ctx))\n\t\t{\n\t\t\tfz_drop_colorspace(ctx, default_cs->gray);\n\t\t\tdefault_cs->gray = fz_keep_colorspace(ctx, cs);\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (default_cs->rgb == fz_device_rgb(ctx))\n\t\t{\n\t\t\tfz_drop_colorspace(ctx, default_cs->rgb);\n\t\t\tdefault_cs->rgb = fz_keep_colorspace(ctx, cs);\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tif (default_cs->cmyk == fz_device_cmyk(ctx))\n\t\t{\n\t\t\tfz_drop_colorspace(ctx, default_cs->cmyk);\n\t\t\tdefault_cs->cmyk = fz_keep_colorspace(ctx, cs);\n\t\t}\n\t\tbreak;\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_set_usecmap(fz_context *ctx, pdf_cmap *cmap, pdf_cmap *usecmap)\n{\n\tint i;\n\n\tpdf_drop_cmap(ctx, cmap->usecmap);\n\tcmap->usecmap = pdf_keep_cmap(ctx, usecmap);\n\n\tif (cmap->codespace_len == 0)\n\t{\n\t\tcmap->codespace_len = usecmap->codespace_len;\n\t\tfor (i = 0; i < usecmap->codespace_len; i++)\n\t\t\tcmap->codespace[i] = usecmap->codespace[i];\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_device_n_has_cmyk(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->flags & FZ_CS_HAS_CMYK);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long SimpleBlock::Parse()\n{\n    return m_block.Parse(m_pCluster);\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Chapters::Display::Clear()\n{\n    delete[] m_string;\n    m_string = NULL;\n    delete[] m_language;\n    m_language = NULL;\n    delete[] m_country;\n    m_country = NULL;\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftMP3::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.mp3\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (const OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mNumChannels = pcmParams->nChannels;\n            mSamplingRate = pcmParams->nSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long mkvparser::UnserializeFloat(\n    IMkvReader* pReader,\n    long long pos,\n    long long size_,\n    double& result)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    if ((size_ != 4) && (size_ != 8))\n        return E_FILE_FORMAT_INVALID;\n \n    const long size = static_cast<long>(size_);\n \n    unsigned char buf[8];\n \n    const int status = pReader->Read(pos, size, buf);\n \n    if (status < 0)  \/\/error\n        return status;\n \n    if (size == 4)\n    {\n        union\n        {\n            float f;\n            unsigned long ff;\n        };\n \n        ff = 0;\n \n        for (int i = 0;;)\n        {\n            ff |= buf[i];\n \n            if (++i >= 4)\n                break;\n \n            ff <<= 8;\n        }\n        result = f;\n    }\n    else\n    {\n        assert(size == 8);\n        union\n        {\n            double d;\n            unsigned long long dd;\n        };\n        dd = 0;\n        for (int i = 0;;)\n        {\n            dd |= buf[i];\n            if (++i >= 8)\n                break;\n            dd <<= 8;\n        }\n        result = d;\n    }\n    return 0;\n }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_separate_entry_fp(phar_entry_info *entry, char **error TSRMLS_DC) \/* {{{ *\/\n{\n\tphp_stream *fp;\n\tphar_entry_info *link;\n\n\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->fp_type == PHAR_MOD) {\n\t\treturn SUCCESS;\n\t}\n\n\tfp = php_stream_fopen_tmpfile();\n\tif (fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn FAILURE;\n\t}\n\tphar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);\n\tlink = phar_get_link_source(entry TSRMLS_CC);\n\n\tif (!link) {\n\t\tlink = entry;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: cannot separate entry file \\\"%s\\\" contents in phar archive \\\"%s\\\" for write access\", entry->filename, entry->phar->fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->link) {\n\t\tefree(entry->link);\n\t\tentry->link = NULL;\n\t\tentry->tar_type = (entry->is_tar ? TAR_FILE : '\\0');\n\t}\n\n\tentry->offset = 0;\n\tentry->fp = fp;\n\tentry->fp_type = PHAR_MOD;\n\tentry->is_modified = 1;\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::CreateBlock(\n    long long id,\n    long long pos,   \/\/absolute pos of payload\n    long long size,\n    long long discard_padding)\n{\n    assert((id == 0x20) || (id == 0x23));  \/\/BlockGroup or SimpleBlock\n    if (m_entries_count < 0)  \/\/haven't parsed anything yet\n    {\n        assert(m_entries == NULL);\n        assert(m_entries_size == 0);\n        m_entries_size = 1024;\n        m_entries = new BlockEntry*[m_entries_size];\n        m_entries_count = 0;\n    }\n    else\n    {\n        assert(m_entries);\n        assert(m_entries_size > 0);\n        assert(m_entries_count <= m_entries_size);\n        if (m_entries_count >= m_entries_size)\n        {\n            const long entries_size = 2 * m_entries_size;\n            BlockEntry** const entries = new BlockEntry*[entries_size];\n            assert(entries);\n            BlockEntry** src = m_entries;\n            BlockEntry** const src_end = src + m_entries_count;\n            BlockEntry** dst = entries;\n            while (src != src_end)\n                *dst++ = *src++;\n            delete[] m_entries;\n            m_entries = entries;\n            m_entries_size = entries_size;\n        }\n     }\n \n    if (id == 0x20)  \/\/BlockGroup ID\n        return CreateBlockGroup(pos, size, discard_padding);\n    else  \/\/SimpleBlock ID\n        return CreateSimpleBlock(pos, size);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"icc_conv_pixmap(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tfz_colorspace *srcs = src->colorspace;\n\tfz_colorspace *dsts = dst->colorspace;\n\tfz_icclink *link;\n\tint i;\n\tunsigned char *inputpos, *outputpos;\n\tint src_n;\n\n\t\/* Handle DeviceGray to CMYK as K only. See note in Section 6.3 of PDF spec 1.7. *\/\n\tif (fz_colorspace_is_device_gray(ctx, srcs) && fz_colorspace_is_cmyk(ctx, dsts))\n\t{\n\t\tfast_gray_to_cmyk(ctx, dst, src, prf, default_cs, color_params, copy_spots);\n\t\treturn;\n\t}\n\n\t\/* Check if we have to do a color space default substitution *\/\n\tif (default_cs)\n\t{\n\t\tswitch (fz_colorspace_type(ctx, src->colorspace))\n\t\t{\n\t\tcase FZ_COLORSPACE_GRAY:\n\t\t\tif (src->colorspace == fz_device_gray(ctx))\n\t\t\t\tsrcs = fz_default_gray(ctx, default_cs);\n\t\t\tbreak;\n\t\tcase FZ_COLORSPACE_RGB:\n\t\t\tif (src->colorspace == fz_device_rgb(ctx))\n\t\t\t\tsrcs = fz_default_rgb(ctx, default_cs);\n\t\t\tbreak;\n\t\tcase FZ_COLORSPACE_CMYK:\n\t\t\tif (src->colorspace == fz_device_cmyk(ctx))\n\t\t\t\tsrcs = fz_default_cmyk(ctx, default_cs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinputpos = src->samples;\n\toutputpos = dst->samples;\n\n\tlink = fz_get_icc_link(ctx, dsts, dst->s + dst->alpha, srcs, src->s + src->alpha, prf, color_params, 1, copy_spots, &src_n);\n\n\tif (link->is_identity)\n\t{\n\t\tfor (i = 0; i < src->h; i++)\n\t\t{\n\t\t\tmemcpy(outputpos, inputpos, src->stride);\n\t\t\tinputpos = inputpos + src->stride;\n\t\t\toutputpos = outputpos + dst->stride;\n\t\t}\n\t}\n\telse\n\t\tfz_cmm_transform_pixmap(ctx, link, dst, src);\n\n\tfz_drop_icclink(ctx, link);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void TearDown() {\n    vpx_svc_release(&svc_);\n     delete(decoder_);\n     if (codec_initialized_) vpx_codec_destroy(&codec_);\n   }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" int GetFreeFrameBuffer(size_t min_size, vpx_codec_frame_buffer_t *fb) {\n    EXPECT_TRUE(fb != NULL);\n const int idx = FindFreeBufferIndex();\n if (idx == num_buffers_)\n return -1;\n\n\n     if (ext_fb_list_[idx].size < min_size) {\n       delete [] ext_fb_list_[idx].data;\n       ext_fb_list_[idx].data = new uint8_t[min_size];\n       ext_fb_list_[idx].size = min_size;\n     }\n \n SetFrameBuffer(idx, fb);\n return 0;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_cmm_fin_link(fz_context *ctx, fz_icclink *link)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->fin_link(ctx->cmm_instance, link);\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_decode_cmap(pdf_cmap *cmap, unsigned char *buf, unsigned char *end, unsigned int *cpt)\n{\n\tunsigned int c;\n\tint k, n;\n\tint len = end - buf;\n\n\tif (len > 4)\n\t\tlen = 4;\n\n\tc = 0;\n\tfor (n = 0; n < len; n++)\n\t{\n\t\tc = (c << 8) | buf[n];\n\t\tfor (k = 0; k < cmap->codespace_len; k++)\n\t\t{\n\t\t\tif (cmap->codespace[k].n == n + 1)\n\t\t\t{\n\t\t\t\tif (c >= cmap->codespace[k].low && c <= cmap->codespace[k].high)\n\t\t\t\t{\n\t\t\t\t\t*cpt = c;\n\t\t\t\t\treturn n + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*cpt = 0;\n\treturn 1;\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_B(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_path(ctx, pr, 0, 1, 1, 0);\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_TJ(fz_context *ctx, pdf_processor *proc, pdf_obj *obj)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_text(ctx, pr, obj);\n}\n","project":"ghostscript","target":0},{"commit_id":"d2f47191538837e796e2b10c1ff7e1ee35f6e0ab","func":"void SoftAVC::drainOneOutputBuffer(int32_t picId, uint8_t* data) {\n     List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n     BufferInfo *outInfo = *outQueue.begin();\n    outQueue.erase(outQueue.begin());\n     OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n     OMX_BUFFERHEADERTYPE *header = mPicToHeaderMap.valueFor(picId);\n     outHeader->nTimeStamp = header->nTimeStamp;\n     outHeader->nFlags = header->nFlags;\n    outHeader->nFilledLen = mWidth * mHeight * 3 \/ 2;\n \n     uint8_t *dst = outHeader->pBuffer + outHeader->nOffset;\n     const uint8_t *srcY = data;\n const uint8_t *srcU = srcY + mWidth * mHeight;\n const uint8_t *srcV = srcU + mWidth * mHeight \/ 4;\n size_t srcYStride = mWidth;\n size_t srcUStride = mWidth \/ 2;\n size_t srcVStride = srcUStride;\n    copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);\n\n    mPicToHeaderMap.removeItem(picId);\n\n     delete header;\n     outInfo->mOwnedByUs = false;\n     notifyFillBufferDone(outHeader);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_icc_from_cal(fz_context *ctx, const fz_colorspace *cs)\n{\n\tfz_cal_colorspace *cal_data = cs->data;\n\tfz_iccprofile *profile;\n\n\tif (cal_data->profile != NULL)\n\t\treturn cal_data->profile;\n\tprofile = fz_malloc_struct(ctx, fz_iccprofile);\n\n\tfz_try(ctx)\n\t{\n\t\tprofile->buffer = fz_new_icc_data_from_cal_colorspace(ctx, cal_data);\n\t\tfz_md5_icc(ctx, profile);\n\t\tcal_data->profile = profile;\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_free(ctx, profile);\n\t\tfz_rethrow(ctx);\n\t}\n\n\treturn profile;\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_unintern (struct attr **attr)\n{\n  struct attr *ret;\n  struct attr tmp;\n  \n  \/* Decrement attribute reference. *\/\n  (*attr)->refcnt--;\n  \n  tmp = *(*attr);\n  \n  if ((*attr)->extra)\n    {\n      tmp.extra = bgp_attr_extra_new ();\n      memcpy (tmp.extra, (*attr)->extra, sizeof (struct attr_extra));\n    }\n  \n  \/* If reference becomes zero then free attribute object. *\/\n  if ((*attr)->refcnt == 0)\n    {    \n      ret = hash_release (attrhash, *attr);\n      assert (ret != NULL);\n      bgp_attr_extra_free (*attr);\n      XFREE (MTYPE_ATTR, *attr);\n      *attr = NULL;\n    }\n\n  bgp_attr_unintern_sub (&tmp);\n  bgp_attr_extra_free (&tmp);\n}\n","project":"savannah","target":0},{"commit_id":"24d7c408c52143bce7b49de82f3913fd8d1219cf","func":"void WT_InterpolateNoLoop (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 phaseFrac;\n    EAS_I32 acc0;\n const EAS_SAMPLE *pSamples;\n    EAS_I32 samp1;\n    EAS_I32 samp2;\n    EAS_I32 numSamples;\n\n \/* initialize some local variables *\/\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b\/26366256\");\n         return;\n     }\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;\n    phaseFrac = (EAS_I32)pWTVoice->phaseFrac;\n\n \/* fetch adjacent samples *\/\n#if defined(_8_BIT_SAMPLES)\n \/*lint -e{701} <avoid multiply for performance>*\/\n    samp1 = pSamples[0] << 8;\n \/*lint -e{701} <avoid multiply for performance>*\/\n    samp2 = pSamples[1] << 8;\n#else\n    samp1 = pSamples[0];\n    samp2 = pSamples[1];\n#endif\n\n while (numSamples--) {\n\n\n \/* linear interpolation *\/\n        acc0 = samp2 - samp1;\n        acc0 = acc0 * phaseFrac;\n \/*lint -e{704} <avoid divide>*\/\n        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);\n\n \/* save new output sample in buffer *\/\n \/*lint -e{704} <avoid divide>*\/\n *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);\n\n \/* increment phase *\/\n        phaseFrac += phaseInc;\n \/*lint -e{704} <avoid divide>*\/\n        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;\n\n \/* next sample *\/\n if (acc0 > 0) {\n\n \/* advance sample pointer *\/\n            pSamples += acc0;\n            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);\n\n \/* fetch new samples *\/\n#if defined(_8_BIT_SAMPLES)\n \/*lint -e{701} <avoid multiply for performance>*\/\n            samp1 = pSamples[0] << 8;\n \/*lint -e{701} <avoid multiply for performance>*\/\n            samp2 = pSamples[1] << 8;\n#else\n            samp1 = pSamples[0];\n            samp2 = pSamples[1];\n#endif\n }\n }\n\n \/* save pointer and phase *\/\n    pWTVoice->phaseAccum = (EAS_U32) pSamples;\n    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;\n}\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"     void CopyFromOMX(const OMX_BUFFERHEADERTYPE *header) {\n        if (!mIsBackup) {\n             return;\n         }\n \n        sp<ABuffer> codec = getBuffer(header, false \/* backup *\/, true \/* limit *\/);\n\n        memcpy((OMX_U8 *)mMem->pointer() + header->nOffset, codec->data(), codec->size());\n\n     }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_device_lab(fz_context *ctx)\n{\n\treturn ctx->colorspace->lab;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool mkvparser::Match(\n    IMkvReader* pReader,\n    long long& pos,\n    unsigned long id_,\n    unsigned char*& buf,\n    size_t& buflen)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    long long total, available;\n \n    long status = pReader->Length(&total, &available);\n    assert(status >= 0);\n    assert((total < 0) || (available <= total));\n    if (status < 0)\n        return false;\n \n    long len;\n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);\n    assert(len > 0);\n    assert(len <= 8);\n    assert((pos + len) <= available);\n \n    if ((unsigned long)id != id_)\n        return false;\n \n    pos += len;  \/\/consume id\n \n    const long long size_ = ReadUInt(pReader, pos, len);\n    assert(size_ >= 0);\n    assert(len > 0);\n    assert(len <= 8);\n    assert((pos + len) <= available);\n \n    pos += len;  \/\/consume length of size of payload\n    assert((pos + size_) <= available);\n \n    const long buflen_ = static_cast<long>(size_);\n \n    buf = new (std::nothrow) unsigned char[buflen_];\n    assert(buf);  \/\/TODO\n \n    status = pReader->Read(pos, buflen_, buf);\n    assert(status == 0);  \/\/TODO\n \n    buflen = buflen_;\n \n    pos += size_;  \/\/consume size of payload\n    return true;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_default_gray(fz_context *ctx, const fz_default_colorspaces *default_cs)\n{\n\tif (default_cs)\n\t\treturn default_cs->gray;\n\telse\n\t\treturn fz_device_gray(ctx);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const CuePoint* Cues::GetFirst() const\n{\n    if (m_cue_points == NULL)\n        return NULL;\n    if (m_count == 0)\n        return NULL;\n \n #if 0\n     LoadCuePoint();  \/\/init cues\n\n const size_t count = m_count + m_preload_count;\n\n if (count == 0) \/\/weird\n\n         return NULL;\n #endif\n \n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n \n    CuePoint* const pCP = pp[0];\n    assert(pCP);\n    assert(pCP->GetTimeCode() >= 0);\n \n    return pCP;\n }\n","project":"Android","target":1},{"commit_id":"3944c65637dfed14a5a895685edfa4bacaf9f76e","func":"void unmarshallAudioAttributes(const Parcel& parcel, audio_attributes_t *attributes)\n{\n    attributes->usage = (audio_usage_t) parcel.readInt32();\n    attributes->content_type = (audio_content_type_t) parcel.readInt32();\n    attributes->source = (audio_source_t) parcel.readInt32();\n    attributes->flags = (audio_flags_mask_t) parcel.readInt32();\n const bool hasFlattenedTag = (parcel.readInt32() == kAudioAttributesMarshallTagFlattenTags);\n if (hasFlattenedTag) {\n String16 tags = parcel.readString16();\n ssize_t realTagSize = utf16_to_utf8_length(tags.string(), tags.size());\n if (realTagSize <= 0) {\n            strcpy(attributes->tags, \"\");\n } else {\n\n             size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ?\n                     AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize;\n            utf16_to_utf8(tags.string(), tagSize, attributes->tags);\n         }\n     } else {\n         ALOGE(\"unmarshallAudioAttributes() received unflattened tags, ignoring tag values\");\n        strcpy(attributes->tags, \"\");\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Cues::Cues(\n    Segment* pSegment,\n    long long start_,\n    long long size_,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_start(start_),\n    m_size(size_),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    m_cue_points(NULL),\n    m_count(0),\n    m_preload_count(0),\n    m_pos(start_)\n{\n }\n","project":"Android","target":1},{"commit_id":"268068f25673242d1d5130d96202d3288c91b700","func":"static void local_socket_close_locked(asocket* s) {\n    D(\"entered local_socket_close_locked. LS(%d) fd=%d\", s->id, s->fd);\n     if (s->peer) {\n         D(\"LS(%d): closing peer. peer->id=%d peer->fd=%d\", s->id, s->peer->id, s->peer->fd);\n         \/* Note: it's important to call shutdown before disconnecting from\n         * the peer, this ensures that remote sockets can still get the id\n         * of the local socket they're connected to, to send a CLOSE()\n         * protocol event. *\/\n\n         if (s->peer->shutdown) {\n             s->peer->shutdown(s->peer);\n         }\n        s->peer->peer = 0;\n        if (s->peer->close == local_socket_close) {\n            local_socket_close_locked(s->peer);\n        } else {\n            s->peer->close(s->peer);\n        }\n        s->peer = 0;\n     }\n \n     \/* If we are already closing, or if there are no\n    ** pending packets, destroy immediately\n    *\/\n if (s->closing || s->has_write_error || s->pkt_first == NULL) {\n int id = s->id;\n        local_socket_destroy(s);\n        D(\"LS(%d): closed\", id);\n return;\n }\n\n \/* otherwise, put on the closing list\n    *\/\n    D(\"LS(%d): closing\", s->id);\n    s->closing = 1;\n    fdevent_del(&s->fde, FDE_READ);\n    remove_socket(s);\n    D(\"LS(%d): put on socket_closing_list fd=%d\", s->id, s->fd);\n    insert_local_socket(s, &local_socket_closing_list);\n    CHECK_EQ(FDE_WRITE, s->fde.state & FDE_WRITE);\n}\n","project":"Android","target":1},{"commit_id":"6c327afb263837bc90760c55c6605b26161a4eb9","func":"WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,\n                                 UWORD8 u1_nal_ref_idc,\n dec_struct_t *ps_dec \/* Decoder parameters *\/\n )\n{\n dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;\n dec_pic_params_t *ps_pps;\n dec_seq_params_t *ps_seq;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n pocstruct_t s_tmp_poc;\n    WORD32 i_delta_poc[2];\n    WORD32 i4_poc = 0;\n    UWORD16 u2_first_mb_in_slice, u2_frame_num;\n    UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;\n    UWORD32 u4_idr_pic_id = 0;\n    UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;\n\n    UWORD8 u1_nal_unit_type;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    WORD8 i1_is_end_of_poc;\n\n    WORD32 ret, end_of_frame;\n    WORD32 prev_slice_err, num_mb_skipped;\n    UWORD8 u1_mbaff;\n pocstruct_t *ps_cur_poc;\n\n    UWORD32 u4_temp;\n    WORD32 i_temp;\n    UWORD32 u4_call_end_of_pic = 0;\n\n \/* read FirstMbInSlice  and slice type*\/\n    ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;\n    u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n if(u2_first_mb_in_slice\n > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))\n {\n\n return ERROR_CORRUPTED_SLICE;\n }\n\n \/*we currently don not support ASO*\/\n if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)\n <= ps_dec->u2_cur_mb_addr) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n    COPYTHECONTEXT(\"SH: first_mb_in_slice\",u2_first_mb_in_slice);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > 9)\n return ERROR_INV_SLC_TYPE_T;\n\n    u1_slice_type = u4_temp;\n    COPYTHECONTEXT(\"SH: slice_type\",(u1_slice_type));\n \/* Find Out the Slice Type is 5 to 9 or not then Set the Flag   *\/\n \/* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*\/\n \/* will be of same type of current                            *\/\n if(u1_slice_type > 4)\n {\n        u1_slice_type -= 5;\n }\n\n {\n        UWORD32 skip;\n\n if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)\n || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))\n {\n            UWORD32 u4_bit_stream_offset = 0;\n\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else if((I_SLICE == u1_slice_type)\n && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else\n {\n                skip = 1;\n }\n\n \/* If one frame worth of data is already skipped, do not skip the next one *\/\n if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))\n {\n                skip = 0;\n }\n\n if(skip)\n {\n                ps_dec->u4_prev_nal_skipped = 1;\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;\n return 0;\n }\n else\n {\n \/* If the previous NAL was skipped, then\n                 do not process that buffer in this call.\n                 Return to app and process it in the next call.\n                 This is necessary to handle cases where I\/IDR is not complete in\n                 the current buffer and application intends to fill the remaining part of the bitstream\n                 later. This ensures we process only frame worth of data in every call *\/\n if(1 == ps_dec->u4_prev_nal_skipped)\n {\n                    ps_dec->u4_return_to_app = 1;\n return 0;\n }\n }\n }\n\n }\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp & MASK_ERR_PIC_SET_ID)\n return ERROR_INV_SLICE_HDR_T;\n \/* discard slice if pic param is invalid *\/\n    COPYTHECONTEXT(\"SH: pic_parameter_set_id\", u4_temp);\n    ps_pps = &ps_dec->ps_pps[u4_temp];\n if(FALSE == ps_pps->u1_is_valid)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n    ps_seq = ps_pps->ps_sps;\n if(!ps_seq)\n return ERROR_INV_SLICE_HDR_T;\n if(FALSE == ps_seq->u1_is_valid)\n return ERROR_INV_SLICE_HDR_T;\n\n \/* Get the frame num *\/\n    u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,\n                                         ps_seq->u1_bits_in_frm_num);\n\n    COPYTHECONTEXT(\"SH: frame_num\", u2_frame_num);\n if(!ps_dec->u1_first_slice_in_stream && ps_dec->u4_first_slice_in_pic)\n {\n pocstruct_t *ps_prev_poc = &ps_dec->s_prev_pic_poc;\n pocstruct_t *ps_cur_poc = &ps_dec->s_cur_pic_poc;\n\n        ps_dec->u2_mbx = 0xffff;\n        ps_dec->u2_mby = 0;\n\n if((0 == u1_is_idr_slice) && ps_cur_slice->u1_nal_ref_idc)\n            ps_dec->u2_prev_ref_frame_num = ps_cur_slice->u2_frame_num;\n\n if(u1_is_idr_slice || ps_cur_slice->u1_mmco_equalto5)\n            ps_dec->u2_prev_ref_frame_num = 0;\n\n if(ps_dec->ps_cur_sps->u1_gaps_in_frame_num_value_allowed_flag)\n {\n            ih264d_decode_gaps_in_frame_num(ps_dec, u2_frame_num);\n }\n\n        ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\n        ps_prev_poc->u2_frame_num = ps_cur_poc->u2_frame_num;\n        ps_prev_poc->u1_mmco_equalto5 = ps_cur_slice->u1_mmco_equalto5;\n if(ps_cur_slice->u1_nal_ref_idc)\n {\n            ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\n            ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\n            ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                            ps_cur_poc->i4_delta_pic_order_cnt_bottom;\n            ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                            ps_cur_poc->i4_delta_pic_order_cnt[0];\n            ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                            ps_cur_poc->i4_delta_pic_order_cnt[1];\n            ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field;\n }\n\n        ps_dec->u2_total_mbs_coded = 0;\n }\n \/* Get the field related flags  *\/\n if(!ps_seq->u1_frame_mbs_only_flag)\n {\n\n        u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);\n        COPYTHECONTEXT(\"SH: field_pic_flag\", u1_field_pic_flag);\n        u1_bottom_field_flag = 0;\n\n if(u1_field_pic_flag)\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;\n            u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: bottom_field_flag\", u1_bottom_field_flag);\n\n }\n else\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n }\n else\n {\n        u1_field_pic_flag = 0;\n        u1_bottom_field_flag = 0;\n\n        ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n\n    u1_nal_unit_type = SLICE_NAL;\n if(u1_is_idr_slice)\n {\n        u1_nal_unit_type = IDR_SLICE_NAL;\n        u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,\n                                   pu4_bitstrm_buf);\n if(u4_idr_pic_id > 65535)\n return ERROR_INV_SLICE_HDR_T;\n        COPYTHECONTEXT(\"SH:  \", u4_idr_pic_id);\n }\n\n \/* read delta pic order count information*\/\n    i_delta_poc[0] = i_delta_poc[1] = 0;\n    s_tmp_poc.i4_pic_order_cnt_lsb = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;\n    u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;\n if(u1_pic_order_cnt_type == 0)\n {\n        i_temp = ih264d_get_bits_h264(\n                        ps_bitstrm,\n                        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);\n if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)\n return ERROR_INV_SLICE_HDR_T;\n        s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;\n        COPYTHECONTEXT(\"SH: pic_order_cnt_lsb\", s_tmp_poc.i4_pic_order_cnt_lsb);\n\n if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))\n {\n            s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt_bottom\",\n                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);\n }\n }\n\n    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;\n if(u1_pic_order_cnt_type == 1\n && (!ps_seq->u1_delta_pic_order_always_zero_flag))\n {\n        s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SH: delta_pic_order_cnt[0]\",\n                        s_tmp_poc.i4_delta_pic_order_cnt[0]);\n\n if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)\n {\n            s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt[1]\",\n                            s_tmp_poc.i4_delta_pic_order_cnt[1]);\n }\n }\n\n if(ps_pps->u1_redundant_pic_cnt_present_flag)\n {\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_REDUNDANT_PIC_CNT)\n return ERROR_INV_SLICE_HDR_T;\n        u1_redundant_pic_cnt = u4_temp;\n        COPYTHECONTEXT(\"SH: redundant_pic_cnt\", u1_redundant_pic_cnt);\n }\n\n \/*--------------------------------------------------------------------*\/\n \/* Check if the slice is part of new picture                          *\/\n \/*--------------------------------------------------------------------*\/\n \/* First slice of a picture is always considered as part of new picture *\/\n    i1_is_end_of_poc = 1;\n    ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;\n\n if(ps_dec->u4_first_slice_in_pic == 0)\n {\n        i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,\n &s_tmp_poc, &ps_dec->s_cur_pic_poc,\n                                            ps_cur_slice, u1_pic_order_cnt_type,\n                                            u1_nal_unit_type, u4_idr_pic_id,\n                                            u1_field_pic_flag,\n                                            u1_bottom_field_flag);\n if(i1_is_end_of_poc)\n {\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_INCOMPLETE_FRAME;\n }\n\n }\n\n \/*--------------------------------------------------------------------*\/\n \/* Check for error in slice and parse the missing\/corrupted MB's      *\/\n \/* as skip-MB's in an inserted P-slice                                *\/\n \/*--------------------------------------------------------------------*\/\n    u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);\n    prev_slice_err = 0;\n\n if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)\n {\n if(u2_frame_num != ps_dec->u2_prv_frame_num\n && ps_dec->u1_top_bottom_decoded != 0\n && ps_dec->u1_top_bottom_decoded\n != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))\n {\n            ps_dec->u1_dangling_field = 1;\n if(ps_dec->u4_first_slice_in_pic)\n {\n                prev_slice_err = 1;\n }\n else\n {\n                prev_slice_err = 2;\n }\n\n if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)\n                ps_cur_slice->u1_bottom_field_flag = 1;\n else\n                ps_cur_slice->u1_bottom_field_flag = 0;\n\n            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &ps_dec->s_cur_pic_poc;\n\n            u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;\n }\n else if(ps_dec->u4_first_slice_in_pic)\n {\n if(u2_first_mb_in_slice > 0)\n {\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n                ps_cur_poc = &s_tmp_poc;\n\n                ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n                ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n                ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n                ps_cur_slice->i4_pic_order_cnt_lsb =\n                        s_tmp_poc.i4_pic_order_cnt_lsb;\n                ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n                ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n                ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n                ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n                ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n }\n }\n else\n {\n \/* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame\n             * completely *\/\n            prev_slice_err = 2;\n            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs\n * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &s_tmp_poc;\n }\n }\n else\n {\n if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)\n {\n            prev_slice_err = 2;\n            num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &s_tmp_poc;\n }\n else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)\n {\n return ERROR_CORRUPTED_SLICE;\n }\n }\n\n if(prev_slice_err)\n {\n        ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);\n\n if(ps_dec->u1_dangling_field == 1)\n {\n            ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;\n            ps_dec->u1_first_slice_in_stream = 0;\n            ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n return ERROR_DANGLING_FIELD_IN_PIC;\n }\n\n if(prev_slice_err == 2)\n {\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_INCOMPLETE_FRAME;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n \/* return if all MBs in frame are parsed*\/\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_IN_LAST_SLICE_OF_PIC;\n }\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n            ih264d_err_pic_dispbuf_mgr(ps_dec);\n return ERROR_NEW_FRAME_EXPECTED;\n }\n\n if(ret != OK)\n return ret;\n\n        i1_is_end_of_poc = 0;\n }\n\n if (ps_dec->u4_first_slice_in_pic == 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n if((ps_dec->u1_separate_parse == 0) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n        ps_dec->ps_decode_cur_slice++;\n }\n    ps_dec->u1_slice_header_done = 0;\n\n\n if(u1_field_pic_flag)\n {\n        ps_dec->u2_prv_frame_num = u2_frame_num;\n }\n\n if(ps_cur_slice->u1_mmco_equalto5)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n\n if(!ps_cur_slice->u1_field_pic_flag) \/\/ or a complementary field pair\n {\n            i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n            i4_bot_field_order_poc =\n                            ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n            i4_temp_poc = MIN(i4_top_field_order_poc,\n                                     i4_bot_field_order_poc);\n }\n else if(!ps_cur_slice->u1_bottom_field_flag)\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n else\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n\n        ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n if(ps_dec->u4_first_slice_in_pic)\n {\n        ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,\n &ps_dec->s_prev_pic_poc,\n &s_tmp_poc, ps_cur_slice, ps_pps,\n                                          u1_nal_ref_idc,\n                                          u1_bottom_field_flag,\n                                          u1_field_pic_flag, &i4_poc);\n if(ret != OK)\n return ret;\n \/* Display seq no calculations *\/\n if(i4_poc >= ps_dec->i4_max_poc)\n            ps_dec->i4_max_poc = i4_poc;\n \/* IDR Picture or POC wrap around *\/\n if(i4_poc == 0)\n {\n            ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq\n + ps_dec->i4_max_poc\n + ps_dec->u1_max_dec_frame_buffering + 1;\n            ps_dec->i4_max_poc = 0;\n }\n }\n\n \/*--------------------------------------------------------------------*\/\n \/* Copy the values read from the bitstream to the slice header and then*\/\n \/* If the slice is first slice in picture, then do Start of Picture   *\/\n \/* processing.                                                        *\/\n \/*--------------------------------------------------------------------*\/\n    ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];\n    ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];\n    ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n    ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;\n    ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n    ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n    ps_cur_slice->u1_slice_type = u1_slice_type;\n    ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;\n\n    ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n    ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n    ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n    ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n\n if(ps_seq->u1_frame_mbs_only_flag)\n        ps_cur_slice->u1_direct_8x8_inference_flag =\n                        ps_seq->u1_direct_8x8_inference_flag;\n else\n        ps_cur_slice->u1_direct_8x8_inference_flag = 1;\n\n if(u1_slice_type == B_SLICE)\n {\n        ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SH: direct_spatial_mv_pred_flag\",\n                        ps_cur_slice->u1_direct_spatial_mv_pred_flag);\n\n if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;\n else\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;\n }\n else\n {\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n }\n\n if(ps_dec->u4_first_slice_in_pic)\n {\n if(u2_first_mb_in_slice == 0)\n {\n            ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);\n if(ret != OK)\n return ret;\n }\n\n        ps_dec->u4_output_present = 0;\n\n {\n            ih264d_get_next_display_field(ps_dec,\n                                          ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n \/* If error code is non-zero then there is no buffer available for display,\n             hence avoid format conversion *\/\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                ps_dec->u4_output_present = 1;\n }\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                ps_dec->u4_start_recon_deblk = 0;\n                ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n\n }\n\n \/* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions *\/\n {\n        UWORD8 uc_nofield_nombaff;\n\n\n\n        uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)\n && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)\n && (u1_slice_type != B_SLICE)\n && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));\n\n \/* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc *\/\n\n if(uc_nofield_nombaff)\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n }\n else\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;\n }\n\n\n }\n\n \/*\n     * Decide whether to decode the current picture or not\n     *\/\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_err->u4_frm_sei_sync == u2_frame_num)\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n            ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;\n }\n        ps_err->u4_cur_frm = u2_frame_num;\n }\n\n \/* Decision for decoding if the picture is to be skipped *\/\n {\n        WORD32 i4_skip_b_pic, i4_skip_p_pic;\n\n        i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)\n && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n        i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)\n && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n \/**************************************************************\/\n \/* Skip the B picture if skip mask is set for B picture and   *\/\n \/* Current B picture is a non reference B picture or there is *\/\n \/* no user for reference B picture                            *\/\n \/**************************************************************\/\n if(i4_skip_b_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n \/* Don't decode the picture in SKIP-B mode if that picture is B *\/\n \/* and also it is not to be used as a reference picture         *\/\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n \/**************************************************************\/\n \/* Skip the P picture if skip mask is set for P picture and   *\/\n \/* Current P picture is a non reference P picture or there is *\/\n \/* no user for reference P picture                            *\/\n \/**************************************************************\/\n if(i4_skip_p_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n \/* Don't decode the picture in SKIP-P mode if that picture is P *\/\n \/* and also it is not to be used as a reference picture         *\/\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n }\n\n {\n        UWORD16 u2_mb_x, u2_mb_y;\n\n        ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice\n << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)\n - SUB_BLK_SIZE;\n if(u2_first_mb_in_slice)\n {\n            UWORD8 u1_mb_aff;\n            UWORD8 u1_field_pic;\n            UWORD16 u2_frm_wd_in_mbs;\n            u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n            u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;\n            u1_field_pic = ps_cur_slice->u1_field_pic_flag;\n\n {\n                UWORD32 x_offset;\n                UWORD32 y_offset;\n                UWORD32 u4_frame_stride;\n tfr_ctxt_t *ps_trns_addr; \/\/ = &ps_dec->s_tran_addrecon_parse;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n                u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n                u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n\n                u2_mb_y <<= u1_mb_aff;\n\n if((u2_mb_x > u2_frm_wd_in_mbs - 1)\n || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n                u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;\n                x_offset = u2_mb_x << 4;\n                y_offset = (u2_mb_y * u4_frame_stride) << 4;\n\n                ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset\n + y_offset;\n\n                u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;\n                x_offset >>= 1;\n                y_offset = (u2_mb_y * u4_frame_stride) << 3;\n\n                x_offset *= YUV420SP_FACTOR;\n\n                ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset\n + y_offset;\n                ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset\n + y_offset;\n\n                ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n                ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n                ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n\n if(ps_dec->u1_separate_parse == 1)\n {\n                    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n else\n {\n                        ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n\n                ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);\n\n                ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv\n + ((u2_first_mb_in_slice << u1_mb_aff) << 4);\n }\n }\n else\n {\n tfr_ctxt_t *ps_trns_addr;\n\n if(ps_dec->u1_separate_parse)\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n\n            u2_mb_x = 0xffff;\n            u2_mb_y = 0;\n            ps_dec->u2_cur_mb_addr = 0;\n            ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n            ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n            ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n            ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n            ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n            ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n            ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n            ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n }\n\n        ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n        ps_dec->u2_mbx =\n (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby =\n (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;\n        ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n        ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n }\n\n \/* RBSP stop bit is used for CABAC decoding*\/\n    ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;\n\n    ps_dec->u1_B = (u1_slice_type == B_SLICE);\n    ps_dec->u4_next_mb_skip = 0;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =\n                    ps_dec->ps_cur_slice->u2_first_mb_in_slice;\n    ps_dec->ps_parse_cur_slice->slice_type =\n                    ps_dec->ps_cur_slice->u1_slice_type;\n\n\n    ps_dec->u4_start_recon_deblk = 1;\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MAX_FRAMES;\n if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n (0 == ps_dec->i4_display_delay))\n {\n            num_entries = 1;\n }\n        num_entries = ((2 * num_entries) + 1);\n        num_entries *= 2;\n\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;\n }\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n if(u1_slice_type == I_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;\n\n        ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);\n\n if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)\n            ps_dec->i4_pic_type = I_SLICE;\n\n }\n else if(u1_slice_type == P_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n        ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n if(ps_dec->i4_pic_type != B_SLICE)\n            ps_dec->i4_pic_type = P_SLICE;\n }\n else if(u1_slice_type == B_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n        ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n        ps_dec->i4_pic_type = B_SLICE;\n }\n else\n return ERROR_INV_SLC_TYPE_T;\n\n if(ps_dec->u1_slice_header_done)\n {\n \/* set to zero to indicate a valid slice has been decoded *\/\n        ps_dec->u1_first_slice_in_stream = 0;\n }\n\n\n     if(ret != OK)\n         return ret;\n \n     \/* storing last Mb X and MbY of the slice *\/\n     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n \/* End of Picture detection *\/\n\n if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))\n {\n        ps_dec->u1_pic_decode_done = 1;\n\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if((ps_err->u1_err_flag & REJECT_PB_PICS)\n && (ps_err->u1_cur_pic_type == PIC_TYPE_I))\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n    PRINT_BIN_BIT_RATIO(ps_dec)\n\n return ret;\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftG711::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n if (pcmParams->nPortIndex == 0) {\n                pcmParams->ePCMMode = mIsMLaw ? OMX_AUDIO_PCMModeMULaw\n : OMX_AUDIO_PCMModeALaw;\n } else {\n                pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n }\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_find_color_converter(fz_context *ctx, fz_color_converter *cc, const fz_colorspace *is, const fz_colorspace *ds, const fz_colorspace *ss, const fz_color_params *params)\n{\n\tif (ds == NULL)\n\t\tds = fz_device_gray(ctx);\n\tif (ss == NULL)\n\t\tss = fz_device_gray(ctx);\n\tcc->ds = ds;\n\tcc->ss = ss;\n\tcc->is = is;\n\tcc->link = NULL;\n\tif (ss == default_gray)\n\t{\n\t\tif ((ds == default_rgb) || (ds == default_bgr))\n\t\t\tcc->convert = g2rgb;\n\t\telse if (ds == default_cmyk)\n\t\t\tcc->convert = g2cmyk;\n\t\telse\n\t\t\tcc->convert = std_conv_color;\n\t}\n\n\telse if (ss == default_rgb)\n\t{\n\t\tif (ds == default_gray)\n\t\t\tcc->convert = rgb2g;\n\t\telse if (ds == default_bgr)\n\t\t\tcc->convert = rgb2bgr;\n\t\telse if (ds == default_cmyk)\n\t\t\tcc->convert = rgb2cmyk;\n\t\telse\n\t\t\tcc->convert = std_conv_color;\n\t}\n\n\telse if (ss == default_bgr)\n\t{\n\t\tif (ds == default_gray)\n\t\t\tcc->convert = bgr2g;\n\t\telse if (ds == default_rgb)\n\t\t\tcc->convert = rgb2bgr;\n\t\telse if (ds == default_cmyk)\n\t\t\tcc->convert = bgr2cmyk;\n\t\telse\n\t\t\tcc->convert = std_conv_color;\n\t}\n\n\telse if (ss == default_cmyk)\n\t{\n\t\tif (ds == default_gray)\n\t\t\tcc->convert = cmyk2g;\n\t\telse if (ds == default_rgb)\n\t\t\tcc->convert = cmyk2rgb;\n\t\telse if (ds == default_bgr)\n\t\t\tcc->convert = cmyk2bgr;\n\t\telse\n\t\t\tcc->convert = std_conv_color;\n\t}\n\telse if ((ss == fz_device_rgb(ctx) && ds == fz_device_bgr(ctx)) ||\n\t\t(ss == fz_device_bgr(ctx) && ds == fz_device_rgb(ctx)))\n\t{\n\t\tcc->convert = rgb2bgr;\n\t}\n\telse\n\t{\n\t\tconst fz_colorspace *ss_base = fz_source_colorspace_cm(ctx, ss);\n\t\tif (ss_base != NULL && fz_colorspace_is_icc(ctx, ds))\n\t\t{\n\t\t\tif (ss_base == ss)\n\t\t\t\tcc->convert = icc_conv_color;\n\t\t\telse\n\t\t\t\tcc->convert = icc_base_conv_color;\n\n\t\t\t\/* Special case: Do not set link if we are doing DeviceGray to CMYK. *\/\n\t\t\t\/* Handle DeviceGray to CMYK as K only. See note in Section 6.3 of PDF spec 1.7. *\/\n\t\t\tif (!(fz_colorspace_is_device_gray(ctx, ss_base) && fz_colorspace_is_cmyk(ctx, ds)))\n\t\t\t\tcc->link = fz_get_icc_link(ctx, ds, 0, ss_base, 0, is, params, 2, 0, &cc->n);\n\t\t}\n\t\telse\n\t\t\tcc->convert = std_conv_color;\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_file,\n                   bool force_full_retrieve)\n{\n  int count, orig_lp;\n  wgint restval, len = 0, qtyread = 0;\n  char *tms, *locf;\n  const char *tmrate = NULL;\n  uerr_t err;\n  struct_stat st;\n\n  \/* Declare WARC variables. *\/\n  bool warc_enabled = (opt.warc_filename != NULL);\n  FILE *warc_tmp = NULL;\n  ip_address *warc_ip = NULL;\n  wgint last_expected_bytes = 0;\n\n  \/* Get the target, and set the name for the message accordingly. *\/\n  if ((f == NULL) && (con->target))\n    {\n      \/* Explicit file (like \".listing\"). *\/\n      locf = con->target;\n    }\n  else\n    {\n      \/* URL-derived file.  Consider \"-O file\" name. *\/\n      xfree (con->target);\n      con->target = url_file_name (u, NULL);\n      if (!opt.output_document)\n        locf = con->target;\n      else\n        locf = opt.output_document;\n    }\n\n  \/* If the output_document was given, then this check was already done and\n     the file didn't exist. Hence the !opt.output_document *\/\n\n  \/* If we receive .listing file it is necessary to determine system type of the ftp\n     server even if opn.noclobber is given. Thus we must ignore opt.noclobber in\n     order to establish connection with the server and get system type. *\/\n  if (opt.noclobber && !opt.output_document && file_exists_p (con->target)\n      && !((con->cmd & DO_LIST) && !(con->cmd & DO_RETR)))\n    {\n      logprintf (LOG_VERBOSE,\n                 _(\"File %s already there; not retrieving.\\n\"), quote (con->target));\n      \/* If the file is there, we suppose it's retrieved OK.  *\/\n      return RETROK;\n    }\n\n  \/* Remove it if it's a link.  *\/\n  remove_link (con->target);\n\n  count = 0;\n\n  if (con->st & ON_YOUR_OWN)\n    con->st = ON_YOUR_OWN;\n\n  orig_lp = con->cmd & LEAVE_PENDING ? 1 : 0;\n\n  \/* THE loop.  *\/\n  do\n    {\n      \/* Increment the pass counter.  *\/\n      ++count;\n      sleep_between_retrievals (count);\n      if (con->st & ON_YOUR_OWN)\n        {\n          con->cmd = 0;\n          con->cmd |= (DO_RETR | LEAVE_PENDING);\n          if (con->csock != -1)\n            con->cmd &= ~ (DO_LOGIN | DO_CWD);\n          else\n            con->cmd |= (DO_LOGIN | DO_CWD);\n        }\n      else \/* not on your own *\/\n        {\n          if (con->csock != -1)\n            con->cmd &= ~DO_LOGIN;\n          else\n            con->cmd |= DO_LOGIN;\n          if (con->st & DONE_CWD)\n            con->cmd &= ~DO_CWD;\n          else\n            con->cmd |= DO_CWD;\n        }\n\n      \/* For file RETR requests, we can write a WARC record.\n         We record the file contents to a temporary file. *\/\n      if (warc_enabled && (con->cmd & DO_RETR) && warc_tmp == NULL)\n        {\n          warc_tmp = warc_tempfile ();\n          if (warc_tmp == NULL)\n            return WARC_TMP_FOPENERR;\n\n          if (!con->proxy && con->csock != -1)\n            {\n              warc_ip = (ip_address *) alloca (sizeof (ip_address));\n              socket_ip_address (con->csock, warc_ip, ENDPOINT_PEER);\n            }\n        }\n\n      \/* Decide whether or not to restart.  *\/\n      if (con->cmd & DO_LIST)\n        restval = 0;\n      else if (force_full_retrieve)\n        restval = 0;\n      else if (opt.start_pos >= 0)\n        restval = opt.start_pos;\n      else if (opt.always_rest\n          && stat (locf, &st) == 0\n          && S_ISREG (st.st_mode))\n        \/* When -c is used, continue from on-disk size.  (Can't use\n           hstat.len even if count>1 because we don't want a failed\n           first attempt to clobber existing data.)  *\/\n        restval = st.st_size;\n      else if (count > 1)\n        restval = qtyread;          \/* start where the previous run left off *\/\n      else\n        restval = 0;\n\n      \/* Get the current time string.  *\/\n      tms = datetime_str (time (NULL));\n      \/* Print fetch message, if opt.verbose.  *\/\n      if (opt.verbose)\n        {\n          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n          char tmp[256];\n          strcpy (tmp, \"        \");\n          if (count > 1)\n            sprintf (tmp, _(\"(try:%2d)\"), count);\n          logprintf (LOG_VERBOSE, \"--%s--  %s\\n  %s => %s\\n\",\n                     tms, hurl, tmp, quote (locf));\n#ifdef WINDOWS\n          ws_changetitle (hurl);\n#endif\n          xfree (hurl);\n        }\n      \/* Send getftp the proper length, if fileinfo was provided.  *\/\n      if (f && f->type != FT_SYMLINK)\n        len = f->size;\n      else\n        len = 0;\n\n      \/* If we are working on a WARC record, getftp should also write\n         to the warc_tmp file. *\/\n      err = getftp (u, len, &qtyread, restval, con, count, &last_expected_bytes,\n                    warc_tmp);\n\n      if (con->csock == -1)\n        con->st &= ~DONE_CWD;\n      else\n        con->st |= DONE_CWD;\n\n      switch (err)\n        {\n        case HOSTERR: case CONIMPOSSIBLE: case FWRITEERR: case FOPENERR:\n        case FTPNSFOD: case FTPLOGINC: case FTPNOPASV: case CONTNOTSUPPORTED:\n        case UNLINKERR: case WARC_TMP_FWRITEERR:\n          \/* Fatal errors, give up.  *\/\n          if (warc_tmp != NULL)\n              fclose (warc_tmp);\n          return err;\n        case CONSOCKERR: case CONERROR: case FTPSRVERR: case FTPRERR:\n        case WRITEFAILED: case FTPUNKNOWNTYPE: case FTPSYSERR:\n        case FTPPORTERR: case FTPLOGREFUSED: case FTPINVPASV:\n        case FOPEN_EXCL_ERR:\n          printwhat (count, opt.ntry);\n          \/* non-fatal errors *\/\n          if (err == FOPEN_EXCL_ERR)\n            {\n              \/* Re-determine the file name. *\/\n              xfree (con->target);\n              con->target = url_file_name (u, NULL);\n              locf = con->target;\n            }\n          continue;\n        case FTPRETRINT:\n          \/* If the control connection was closed, the retrieval\n             will be considered OK if f->size == len.  *\/\n          if (!f || qtyread != f->size)\n            {\n              printwhat (count, opt.ntry);\n              continue;\n            }\n          break;\n        case RETRFINISHED:\n          \/* Great!  *\/\n          break;\n        default:\n          \/* Not as great.  *\/\n          abort ();\n        }\n      tms = datetime_str (time (NULL));\n      if (!opt.spider)\n        tmrate = retr_rate (qtyread - restval, con->dltime);\n\n      \/* If we get out of the switch above without continue'ing, we've\n         successfully downloaded a file.  Remember this fact. *\/\n      downloaded_file (FILE_DOWNLOADED_NORMALLY, locf);\n\n      if (con->st & ON_YOUR_OWN)\n        {\n          fd_close (con->csock);\n          con->csock = -1;\n        }\n      if (!opt.spider)\n        {\n          bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));\n\n          logprintf (LOG_VERBOSE,\n                     write_to_stdout\n                     ? _(\"%s (%s) - written to stdout %s[%s]\\n\\n\")\n                     : _(\"%s (%s) - %s saved [%s]\\n\\n\"),\n                     tms, tmrate,\n                     write_to_stdout ? \"\" : quote (locf),\n                     number_to_static_string (qtyread));\n        }\n      if (!opt.verbose && !opt.quiet)\n        {\n          \/* Need to hide the password from the URL.  The `if' is here\n             so that we don't do the needless allocation every\n             time. *\/\n          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n          logprintf (LOG_NONVERBOSE, \"%s URL: %s [%s] -> \\\"%s\\\" [%d]\\n\",\n                     tms, hurl, number_to_static_string (qtyread), locf, count);\n          xfree (hurl);\n        }\n\n      if (warc_enabled && (con->cmd & DO_RETR))\n        {\n          \/* Create and store a WARC resource record for the retrieved file. *\/\n          bool warc_res;\n\n          warc_res = warc_write_resource_record (NULL, u->url, NULL, NULL,\n                                                  warc_ip, NULL, warc_tmp, -1);\n\n          if (! warc_res)\n            return WARC_ERR;\n\n          \/* warc_write_resource_record has also closed warc_tmp. *\/\n          warc_tmp = NULL;\n        }\n\n      if (con->cmd & DO_LIST)\n        \/* This is a directory listing file. *\/\n        {\n          if (!opt.remove_listing)\n            \/* --dont-remove-listing was specified, so do count this towards the\n               number of bytes and files downloaded. *\/\n            {\n              total_downloaded_bytes += qtyread;\n              numurls++;\n            }\n\n          \/* Deletion of listing files is not controlled by --delete-after, but\n             by the more specific option --dont-remove-listing, and the code\n             to do this deletion is in another function. *\/\n        }\n      else if (!opt.spider)\n        \/* This is not a directory listing file. *\/\n        {\n          \/* Unlike directory listing files, don't pretend normal files weren't\n             downloaded if they're going to be deleted.  People seeding proxies,\n             for instance, may want to know how many bytes and files they've\n             downloaded through it. *\/\n          total_downloaded_bytes += qtyread;\n          numurls++;\n\n          if (opt.delete_after && !input_file_url (opt.input_filename))\n            {\n              DEBUGP ((\"\\\nRemoving file due to --delete-after in ftp_loop_internal():\\n\"));\n              logprintf (LOG_VERBOSE, _(\"Removing %s.\\n\"), locf);\n              if (unlink (locf))\n                logprintf (LOG_NOTQUIET, \"unlink: %s\\n\", strerror (errno));\n            }\n        }\n\n      \/* Restore the original leave-pendingness.  *\/\n      if (orig_lp)\n        con->cmd |= LEAVE_PENDING;\n      else\n        con->cmd &= ~LEAVE_PENDING;\n\n      if (local_file)\n        *local_file = xstrdup (locf);\n\n      if (warc_tmp != NULL)\n        fclose (warc_tmp);\n\n      return RETROK;\n    } while (!opt.ntry || (count < opt.ntry));\n\n  if (con->csock != -1 && (con->st & ON_YOUR_OWN))\n    {\n      fd_close (con->csock);\n      con->csock = -1;\n    }\n\n  if (warc_tmp != NULL)\n    fclose (warc_tmp);\n\n  return TRYLIMEXC;\n}\n","project":"savannah","target":0},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_do_pasv (int csock, ip_address *addr, int *port)\n{\n  uerr_t err;\n\n  \/* We need to determine the address family and need to call\n     getpeername, so while we're at it, store the address to ADDR.\n     ftp_pasv and ftp_lpsv can simply override it.  *\/\n  if (!socket_ip_address (csock, addr, ENDPOINT_PEER))\n    abort ();\n\n  \/* If our control connection is over IPv6, then we first try EPSV and then\n   * LPSV if the former is not supported. If the control connection is over\n   * IPv4, we simply issue the good old PASV request. *\/\n  switch (addr->family)\n    {\n    case AF_INET:\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, \"==> PASV ... \");\n      err = ftp_pasv (csock, addr, port);\n      break;\n    case AF_INET6:\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, \"==> EPSV ... \");\n      err = ftp_epsv (csock, addr, port);\n\n      \/* If EPSV is not supported try LPSV *\/\n      if (err == FTPNOPASV)\n        {\n          if (!opt.server_response)\n            logputs (LOG_VERBOSE, \"==> LPSV ... \");\n          err = ftp_lpsv (csock, addr, port);\n        }\n      break;\n    default:\n      abort ();\n    }\n\n  return err;\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"double AudioTrack::GetSamplingRate() const\n{\n    return m_rate;\n }\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":" status_t OMXNodeInstance::storeMetaDataInBuffers_l(\n         OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type) {\n     if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n         android_errorWriteLog(0x534e4554, \"26324358\");\n         if (type != NULL) {\n *type = kMetadataBufferTypeInvalid;\n }\n return BAD_VALUE;\n }\n\n    OMX_INDEXTYPE index;\n    OMX_STRING name = const_cast<OMX_STRING>(\n \"OMX.google.android.index.storeMetaDataInBuffers\");\n\n    OMX_STRING nativeBufferName = const_cast<OMX_STRING>(\n \"OMX.google.android.index.storeANWBufferInMetadata\");\n MetadataBufferType negotiatedType;\n MetadataBufferType requestedType = type != NULL ? *type : kMetadataBufferTypeANWBuffer;\n\n StoreMetaDataInBuffersParams params;\n InitOMXParams(&params);\n    params.nPortIndex = portIndex;\n    params.bStoreMetaData = enable;\n\n    OMX_ERRORTYPE err =\n        requestedType == kMetadataBufferTypeANWBuffer\n ? OMX_GetExtensionIndex(mHandle, nativeBufferName, &index)\n : OMX_ErrorUnsupportedIndex;\n    OMX_ERRORTYPE xerr = err;\n if (err == OMX_ErrorNone) {\n        err = OMX_SetParameter(mHandle, index, &params);\n if (err == OMX_ErrorNone) {\n            name = nativeBufferName; \/\/ set name for debugging\n            negotiatedType = requestedType;\n }\n }\n if (err != OMX_ErrorNone) {\n        err = OMX_GetExtensionIndex(mHandle, name, &index);\n        xerr = err;\n if (err == OMX_ErrorNone) {\n            negotiatedType =\n                requestedType == kMetadataBufferTypeANWBuffer\n ? kMetadataBufferTypeGrallocSource : requestedType;\n            err = OMX_SetParameter(mHandle, index, &params);\n }\n }\n\n if (err != OMX_ErrorNone) {\n if (err == OMX_ErrorUnsupportedIndex && portIndex == kPortIndexOutput) {\n            CLOGW(\"component does not support metadata mode; using fallback\");\n } else if (xerr != OMX_ErrorNone) {\n            CLOG_ERROR(getExtensionIndex, xerr, \"%s\", name);\n } else {\n            CLOG_ERROR(setParameter, err, \"%s(%#x): %s:%u en=%d type=%d\", name, index,\n                    portString(portIndex), portIndex, enable, negotiatedType);\n }\n        negotiatedType = mMetadataType[portIndex];\n } else {\n if (!enable) {\n            negotiatedType = kMetadataBufferTypeInvalid;\n }\n        mMetadataType[portIndex] = negotiatedType;\n }\n    CLOG_CONFIG(storeMetaDataInBuffers, \"%s:%u %srequested %s:%d negotiated %s:%d\",\n            portString(portIndex), portIndex, enable ? \"\" : \"UN\",\n            asString(requestedType), requestedType, asString(negotiatedType), negotiatedType);\n\n if (type != NULL) {\n *type = negotiatedType;\n }\n\n return StatusFromOMXError(err);\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long mkvparser::UnserializeString(\n    IMkvReader* pReader,\n    long long pos,\n    long long size_,\n    char*& str)\n{\n     delete[] str;\n     str = NULL;\n \n    if (size_ >= LONG_MAX)  \/\/we need (size+1) chars\n        return E_FILE_FORMAT_INVALID;\n \n    const long size = static_cast<long>(size_);\n \n    str = new (std::nothrow) char[size+1];\n    if (str == NULL)\n        return -1;\n    unsigned char* const buf = reinterpret_cast<unsigned char*>(str);\n    const long status = pReader->Read(pos, size, buf);\n    if (status)\n    {\n        delete[] str;\n        str = NULL;\n        return status;\n    }\n    str[size] = '\\0';\n    return 0;  \/\/success\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Chapters::ExpandEditionsArray()\n{\n    if (m_editions_size > m_editions_count)\n        return true;  \/\/ nothing else to do\n \n    const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;\n \n    Edition* const editions = new (std::nothrow) Edition[size];\n \n    if (editions == NULL)\n        return false;\n \n    for (int idx = 0; idx < m_editions_count; ++idx)\n    {\n        m_editions[idx].ShallowCopy(editions[idx]);\n     }\n \n    delete[] m_editions;\n    m_editions = editions;\n \n    m_editions_size = size;\n    return true;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"static void encode_frame(vpx_codec_ctx_t *codec,\n                         vpx_image_t *img,\n                         int frame_index,\n                         VpxVideoWriter *writer) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,\n                                               VPX_DL_GOOD_QUALITY);\n if (res != VPX_CODEC_OK)\n\n     die_codec(codec, \"Failed to encode frame\");\n \n   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n       if (!vpx_video_writer_write_frame(writer,\n                                        pkt->data.frame.buf,\n                                        pkt->data.frame.sz,\n                                        pkt->data.frame.pts)) {\n        die_codec(codec, \"Failed to write compressed frame\");\n }\n\n      printf(keyframe ? \"K\" : \".\");\n\n       fflush(stdout);\n     }\n   }\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void SetUp() {\n     source_stride_ = (width_ + 31) & ~31;\n     reference_stride_ = width_ * 2;\n     rnd_.Reset(ACMRandom::DeterministicSeed());\n   }\n","project":"Android","target":1},{"commit_id":"918eeaa29d99d257282fafec931b4bda0e3bae12","func":"void SoftAVC::setDecodeArgs(\n         ivd_video_decode_ip_t *ps_dec_ip,\n         ivd_video_decode_op_t *ps_dec_op,\n         OMX_BUFFERHEADERTYPE *inHeader,\n        OMX_BUFFERHEADERTYPE *outHeader,\n\n         size_t timeStampIx) {\n     size_t sizeY = outputBufferWidth() * outputBufferHeight();\n     size_t sizeUV;\n    uint8_t *pBuf;\n \n     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);\n     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n\n    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;\n\n \/* When in flush and after EOS with zero byte input,\n     * inHeader is set to zero. Hence check for non-null *\/\n if (inHeader) {\n        ps_dec_ip->u4_ts = timeStampIx;\n        ps_dec_ip->pv_stream_buffer =\n            inHeader->pBuffer + inHeader->nOffset;\n        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;\n } else {\n        ps_dec_ip->u4_ts = 0;\n        ps_dec_ip->pv_stream_buffer = NULL;\n\n         ps_dec_ip->u4_num_Bytes = 0;\n     }\n \n    if (outHeader) {\n        pBuf = outHeader->pBuffer;\n    } else {\n        pBuf = mFlushOutBuffer;\n    }\n     sizeUV = sizeY \/ 4;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;\n \n     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;\n     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;\n     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;\n     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;\n    return;\n }\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_check_user_account_control_invariants(struct samldb_ctx *ac,\n\t\t\t\t\t\t    uint32_t user_account_control)\n{\n\tint i, ret = 0;\n\tbool need_check = false;\n\tconst struct uac_to_guid {\n\t\tuint32_t uac;\n\t\tbool never;\n\t\tuint32_t needs;\n\t\tuint32_t not_with;\n\t\tconst char *error_string;\n\t} map[] = {\n\t\t{\n\t\t\t.uac = UF_TEMP_DUPLICATE_ACCOUNT,\n\t\t\t.never = true,\n\t\t\t.error_string = \"Updating the UF_TEMP_DUPLICATE_ACCOUNT flag is never allowed\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.needs = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_PARTIAL_SECRETS_ACCOUNT only permitted with UF_WORKSTATION_TRUST_ACCOUNT\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.not_with = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_NORMAL_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_NORMAL_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.not_with = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT\"\n\t\t}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tif (user_account_control & map[i].uac) {\n\t\t\tneed_check = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (need_check == false) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tuint32_t this_uac = user_account_control & map[i].uac;\n\t\tif (this_uac != 0) {\n\t\t\tif (map[i].never) {\n\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\tbreak;\n\t\t\t} else if (map[i].needs != 0) {\n\t\t\t\tif ((map[i].needs & user_account_control) == 0) {\n\t\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (map[i].not_with != 0) {\n\t\t\t\tif ((map[i].not_with & user_account_control) != 0) {\n\t\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\tswitch (ac->req->operation) {\n\t\tcase LDB_ADD:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to add %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tcase LDB_MODIFY:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to modify %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ldb_module_operr(ac->module);\n\t\t}\n\t}\n\treturn ret;\n}\n","project":"samba","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_x509_check_private_key)\n{\n\tzval ** zcert, **zkey;\n\tX509 * cert = NULL;\n\tEVP_PKEY * key = NULL;\n\tlong certresource = -1, keyresource = -1;\n\n\tRETVAL_FALSE;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ZZ\", &zcert, &zkey) == FAILURE) {\n\t\treturn;\n\t}\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tRETURN_FALSE;\n\t}\t\n\tkey = php_openssl_evp_from_zval(zkey, 0, \"\", 1, &keyresource TSRMLS_CC);\n\tif (key) {\n\t\tRETVAL_BOOL(X509_check_private_key(cert, key));\n\t}\n\n\tif (keyresource == -1 && key) {\n\t\tEVP_PKEY_free(key);\n\t}\n\tif (certresource == -1 && cert) {\n\t\tX509_free(cert);\n\t}\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" void VarianceTest<VarianceFunctionType>::OneQuarterTest() {\n  memset(src_, 255, block_size_);\n   const int half = block_size_ \/ 2;\n  memset(ref_, 255, half);\n  memset(ref_ + half, 0, half);\n   unsigned int sse;\n   unsigned int var;\n  REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n   const unsigned int expected = block_size_ * 255 * 255 \/ 4;\n   EXPECT_EQ(expected, var);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":" long ContentEncoding::ParseContentEncAESSettingsEntry(\n    long long start,\n    long long size,\n    IMkvReader* pReader,\n     ContentEncAESSettings* aes) {\n   assert(pReader);\n   assert(aes);\n\n long long pos = start;\n const long long stop = start + size;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  \/\/error\n       return status;\n \n     if (id == 0x7E8) {\n      aes->cipher_mode = UnserializeUInt(pReader, pos, size);\n if (aes->cipher_mode != 1)\n\n         return E_FILE_FORMAT_INVALID;\n     }\n \n    pos += size;  \/\/consume payload\n     assert(pos <= stop);\n   }\n \n   return 0;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_device_bgr(fz_context *ctx)\n{\n\treturn ctx->colorspace->bgr;\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_map_range_to_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, int out)\n{\n\tadd_range(ctx, cmap, low, high, out, 1, 0);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void CheckSADs() {\n     unsigned int reference_sad, exp_sad[4];\n \n     SADs(exp_sad);\n    for (int block = 0; block < 4; block++) {\n      reference_sad = ReferenceSAD(UINT_MAX, block);\n \n      EXPECT_EQ(exp_sad[block], reference_sad) << \"block \" << block;\n     }\n   }\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_find_for_defaultObjectCategory(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tac->res_dn = NULL;\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ac->dn, LDB_SCOPE_BASE, no_attrs,\n\t\t\t\t DSDB_SEARCH_SHOW_DN_IN_STORAGE_FORMAT\n\t\t\t\t | DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectClass=classSchema)\");\n\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\/* Don't be pricky when the DN doesn't exist if we have the *\/\n\t\t\/* RELAX control specified *\/\n\t\tif (ldb_request_get_control(ac->req,\n\t\t\t\t\t    LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb_find_defaultObjectCategory: \"\n\t\t\t\t\t  \"Invalid DN for 'defaultObjectCategory'!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\tif ((ret != LDB_ERR_NO_SUCH_OBJECT) && (ret != LDB_SUCCESS)) {\n\t\treturn ret;\n\t}\n\n\tif (ret == LDB_SUCCESS) {\n\t\t\/* ensure the defaultObjectCategory has a full GUID *\/\n\t\tstruct ldb_message *m;\n\t\tm = ldb_msg_new(ac->msg);\n\t\tif (m == NULL) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->dn = ac->msg->dn;\n\t\tif (ldb_msg_add_string(m, \"defaultObjectCategory\",\n\t\t\t\t       ldb_dn_get_extended_linearized(m, res->msgs[0]->dn, 1)) !=\n\t\t    LDB_SUCCESS) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->elements[0].flags = LDB_FLAG_MOD_REPLACE;\n\n\t\tret = dsdb_module_modify(ac->module, m,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t ac->req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\n\tac->res_dn = ac->dn;\n\n\treturn samldb_next_step(ac);\n}\n","project":"samba","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_renegotiate(SSL *s)\n\t{\n\tif (s->handshake_func == NULL)\n\t\treturn(1);\n\n\tif (s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)\n\t\treturn(0);\n\n\ts->s3->renegotiate=1;\n\treturn(1);\n\t}\n","project":"openssl","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_RG(fz_context *ctx, pdf_processor *proc, float r, float g, float b)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tfloat color[3] = {r, g, b};\n\tpr->dev->flags &= ~FZ_DEVFLAG_STROKECOLOR_UNDEFINED;\n\tpdf_set_colorspace(ctx, pr, PDF_STROKE, fz_device_rgb(ctx));\n\tpdf_set_color(ctx, pr, PDF_STROKE, color);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Cluster::GetFirstTime() const\n{\n    const BlockEntry* pEntry;\n    const long status = GetFirst(pEntry);\n    if (status < 0)  \/\/error\n        return status;\n    if (pEntry == NULL)  \/\/empty cluster\n        return GetTime();\n    const Block* const pBlock = pEntry->GetBlock();\n    assert(pBlock);\n    return pBlock->GetTime(this);\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_G(fz_context *ctx, pdf_processor *proc, float g)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpr->dev->flags &= ~FZ_DEVFLAG_STROKECOLOR_UNDEFINED;\n\tpdf_set_colorspace(ctx, pr, PDF_STROKE, fz_device_gray(ctx));\n\tpdf_set_color(ctx, pr, PDF_STROKE, &g);\n}\n","project":"ghostscript","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"static char * MS_CALLBACK srp_password_from_info_cb(SSL *s, void *arg)\n\t{\n\treturn BUF_strdup(s->srp_ctx.info) ;\n\t}\n","project":"openssl","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"static char *phar_get_link_location(phar_entry_info *entry TSRMLS_DC) \/* {{{ *\/\n{\n\tchar *p, *ret = NULL;\n\tif (!entry->link) {\n\t\treturn NULL;\n\t}\n\tif (entry->link[0] == '\/') {\n\t\treturn estrdup(entry->link + 1);\n\t}\n\tp = strrchr(entry->filename, '\/');\n\tif (p) {\n\t\t*p = '\\0';\n\t\tspprintf(&ret, 0, \"%s\/%s\", entry->filename, entry->link);\n\t\treturn ret;\n\t}\n\treturn entry->link;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_public_encrypt)\n{\n\tzval **key, *crypted;\n\tEVP_PKEY *pkey;\n\tint cryptedlen;\n\tunsigned char *cryptedbuf;\n\tint successful = 0;\n\tlong keyresource = -1;\n\tlong padding = RSA_PKCS1_PADDING;\n\tchar * data;\n\tint data_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"szZ|l\", &data, &data_len, &crypted, &key, &padding) == FAILURE)\n\t\treturn;\n\n\tRETVAL_FALSE;\n\t\n\tpkey = php_openssl_evp_from_zval(key, 1, NULL, 0, &keyresource TSRMLS_CC);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key parameter is not a valid public key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcryptedlen = EVP_PKEY_size(pkey);\n\tcryptedbuf = emalloc(cryptedlen + 1);\n\n\tswitch (pkey->type) {\n\t\tcase EVP_PKEY_RSA:\n\t\tcase EVP_PKEY_RSA2:\n\t\t\tsuccessful = (RSA_public_encrypt(data_len, \n\t\t\t\t\t\t(unsigned char *)data, \n\t\t\t\t\t\tcryptedbuf, \n\t\t\t\t\t\tpkey->pkey.rsa, \n\t\t\t\t\t\tpadding) == cryptedlen);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key type not supported in this PHP build!\");\n\n\t}\n\n\tif (successful) {\n\t\tzval_dtor(crypted);\n\t\tcryptedbuf[cryptedlen] = '\\0';\n\t\tZVAL_STRINGL(crypted, (char *)cryptedbuf, cryptedlen, 0);\n\t\tcryptedbuf = NULL;\n\t\tRETVAL_TRUE;\n\t}\n\tif (keyresource == -1) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tif (cryptedbuf) {\n\t\tefree(cryptedbuf);\n\t}\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Chapters::Display::Init()\n{\n    m_string = NULL;\n    m_language = NULL;\n    m_country = NULL;\n}\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::updateGraphicBufferInMeta(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id buffer) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n\n     return updateGraphicBufferInMeta_l(\n             portIndex, graphicBuffer, buffer, header,\n            portIndex == kPortIndexOutput \/* updateCodecBuffer *\/);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Segment::CreateInstance(\n    IMkvReader* pReader,\n    long long pos,\n    Segment*& pSegment)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    pSegment = NULL;\n \n    long long total, available;\n \n    const long status = pReader->Length(&total, &available);\n \n    if (status < 0) \/\/error\n        return status;\n \n    if (available < 0)\n         return -1;\n \n    if ((total >= 0) && (available > total))\n         return -1;\n \n \n    for (;;)\n    {\n        if ((total >= 0) && (pos >= total))\n            return E_FILE_FORMAT_INVALID;\n        long len;\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result)  \/\/error, or too few available bytes\n            return result;\n        if ((total >= 0) && ((pos + len) > total))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > available)\n            return pos + len;\n        const long long idpos = pos;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0)  \/\/error\n            return id;\n        pos += len;  \/\/consume ID\n        result = GetUIntLength(pReader, pos, len);\n        if (result)  \/\/error, or too few available bytes\n            return result;\n        if ((total >= 0) && ((pos + len) > total))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > available)\n            return pos + len;\n        long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  \/\/error\n            return size;\n        pos += len;  \/\/consume length of size of element\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (id == 0x08538067)  \/\/Segment ID\n        {\n            if (size == unknown_size)\n                size = -1;\n            else if (total < 0)\n                size = -1;\n            else if ((pos + size) > total)\n                size = -1;\n            pSegment = new (std::nothrow) Segment(\n                                            pReader,\n                                            idpos,\n                                            pos,\n                                            size);\n            if (pSegment == 0)\n                return -1;  \/\/generic error\n            return 0;    \/\/success\n        }\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;\n        if ((total >= 0) && ((pos + size) > total))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + size) > available)\n            return pos + size;\n        pos += size;  \/\/consume payload\n    }\n}\n","project":"Android","target":1},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"copy_node_types(cmap_splay *node, void *arg)\n{\n\tpdf_cmap *cmap = (pdf_cmap *)arg;\n\n\tif (node->many)\n\t{\n\t\tassert(node->low == node->high);\n\t\tcmap->mranges[cmap->mlen].low = node->low;\n\t\tcmap->mranges[cmap->mlen].out = node->out;\n\t\tcmap->mlen++;\n\t}\n\telse if (node->low <= 0xffff && node->high <= 0xFFFF && node->out <= 0xFFFF)\n\t{\n\t\tcmap->ranges[cmap->rlen].low = node->low;\n\t\tcmap->ranges[cmap->rlen].high = node->high;\n\t\tcmap->ranges[cmap->rlen].out = node->out;\n\t\tcmap->rlen++;\n\t}\n\telse\n\t{\n\t\tcmap->xranges[cmap->xlen].low = node->low;\n\t\tcmap->xranges[cmap->xlen].high = node->high;\n\t\tcmap->xranges[cmap->xlen].out = node->out;\n\t\tcmap->xlen++;\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_keep_colorspace_context(fz_context *ctx)\n{\n\tif (!ctx)\n\t\treturn NULL;\n\treturn fz_keep_imp(ctx, ctx->colorspace, &ctx->colorspace->ctx_refs);\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"transit_finish (void)\n{\n  hash_free (transit_hash);\n  transit_hash = NULL;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_colorspace *fz_new_icc_colorspace_from_file(fz_context *ctx, const char *name, const char *path)\n{\n\tfz_colorspace *cs = NULL;\n\tfz_buffer *buffer = fz_read_file(ctx, path);\n\tfz_try(ctx)\n\t\tcs = fz_new_icc_colorspace(ctx, name, 0, buffer);\n\tfz_always(ctx)\n\t\tfz_drop_buffer(ctx, buffer);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n\treturn cs;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"indexed_to_rgb(fz_context *ctx, const fz_colorspace *cs, const float *color, float *rgb)\n{\n\tfloat alt[FZ_MAX_COLORS];\n\tstruct indexed *idx = cs->data;\n\n\tindexed_to_alt(ctx, cs, color, alt);\n\tidx->base->to_ccs(ctx, idx->base, alt, rgb);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Cues::DoneParsing() const\n{\n    const long long stop = m_start + m_size;\n    return (m_pos >= stop);\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n     fwd_txfm_(in, out, stride);\n   }\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_GSHUTDOWN_FUNCTION(pcre) \/* {{{ *\/\n{\n\tzend_hash_destroy(&pcre_globals->pcre_cache);\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"rgb2g(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tdv[0] = sv[0] * 0.3f + sv[1] * 0.59f + sv[2] * 0.11f;\n}\n","project":"ghostscript","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SimpleSoftOMXComponent::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex >= mPorts.size()\n                     || defParams->nSize\n                             != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {\n return OMX_ErrorUndefined;\n }\n\n const PortInfo *port =\n &mPorts.itemAt(defParams->nPortIndex);\n\n            memcpy(defParams, &port->mDef, sizeof(port->mDef));\n\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n","project":"Android","target":1},{"commit_id":"268068f25673242d1d5130d96202d3288c91b700","func":"asocket* find_local_socket(unsigned local_id, unsigned peer_id) {\n\n     asocket* s;\n     asocket* result = NULL;\n \n    adb_mutex_lock(&socket_list_lock);\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->id != local_id) {\n             continue;\n }\n if (peer_id == 0 || (s->peer && s->peer->id == peer_id)) {\n            result = s;\n\n         }\n         break;\n     }\n    adb_mutex_unlock(&socket_list_lock);\n \n     return result;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Block::Parse(const Cluster* pCluster)\n{\n    if (pCluster == NULL)\n        return -1;\n \n    if (pCluster->m_pSegment == NULL)\n        return -1;\n \n    assert(m_start >= 0);\n    assert(m_size >= 0);\n    assert(m_track <= 0);\n    assert(m_frames == NULL);\n    assert(m_frame_count <= 0);\n \n    long long pos = m_start;\n    const long long stop = m_start + m_size;\n \n    long len;\n \n    IMkvReader* const pReader = pCluster->m_pSegment->m_pReader;\n \n    m_track = ReadUInt(pReader, pos, len);\n \n    if (m_track <= 0)\n        return E_FILE_FORMAT_INVALID;\n \n    if ((pos + len) > stop)\n        return E_FILE_FORMAT_INVALID;\n \n    pos += len;  \/\/consume track number\n \n    if ((stop - pos) < 2)\n        return E_FILE_FORMAT_INVALID;\n \n    long status;\n    long long value;\n \n    status = UnserializeInt(pReader, pos, 2, value);\n \n    if (status)\n        return E_FILE_FORMAT_INVALID;\n \n    if (value < SHRT_MIN)\n        return E_FILE_FORMAT_INVALID;\n \n    if (value > SHRT_MAX)\n        return E_FILE_FORMAT_INVALID;\n \n    m_timecode = static_cast<short>(value);\n \n    pos += 2;\n \n    if ((stop - pos) <= 0)\n        return E_FILE_FORMAT_INVALID;\n    status = pReader->Read(pos, 1, &m_flags);\n    if (status)\n        return E_FILE_FORMAT_INVALID;\n    const int lacing = int(m_flags & 0x06) >> 1;\n    ++pos;  \/\/consume flags byte\n    if (lacing == 0)  \/\/no lacing\n    {\n        if (pos > stop)\n            return E_FILE_FORMAT_INVALID;\n        m_frame_count = 1;\n        m_frames = new Frame[m_frame_count];\n        Frame& f = m_frames[0];\n        f.pos = pos;\n        const long long frame_size = stop - pos;\n        if (frame_size > LONG_MAX)\n            return E_FILE_FORMAT_INVALID;\n        f.len = static_cast<long>(frame_size);\n        return 0;  \/\/success\n    }\n    if (pos >= stop)\n        return E_FILE_FORMAT_INVALID;\n    unsigned char biased_count;\n    status = pReader->Read(pos, 1, &biased_count);\n    if (status)\n        return E_FILE_FORMAT_INVALID;\n    ++pos;  \/\/consume frame count\n    assert(pos <= stop);\n    m_frame_count = int(biased_count) + 1;\n     m_frames = new Frame[m_frame_count];\n    assert(m_frames);\n \n    if (lacing == 1)  \/\/Xiph\n    {\n        Frame* pf = m_frames;\n        Frame* const pf_end = pf + m_frame_count;\n \n        long size = 0;\n        int frame_count = m_frame_count;\n \n        while (frame_count > 1)\n        {\n            long frame_size = 0;\n \n            for (;;)\n            {\n                unsigned char val;\n \n                if (pos >= stop)\n                    return E_FILE_FORMAT_INVALID;\n \n                status = pReader->Read(pos, 1, &val);\n \n                if (status)\n                    return E_FILE_FORMAT_INVALID;\n \n                ++pos;  \/\/consume xiph size byte\n \n                frame_size += val;\n \n                if (val < 255)\n                    break;\n            }\n \n            Frame& f = *pf++;\n            assert(pf < pf_end);\n \n            f.pos = 0;  \/\/patch later\n \n            f.len = frame_size;\n            size += frame_size;  \/\/contribution of this frame\n \n            --frame_count;\n        }\n \n        assert(pf < pf_end);\n        assert(pos <= stop);\n \n        {\n            Frame& f = *pf++;\n            if (pf != pf_end)\n                return E_FILE_FORMAT_INVALID;\n            f.pos = 0;  \/\/patch later\n            const long long total_size = stop - pos;\n            if (total_size < size)\n                return E_FILE_FORMAT_INVALID;\n            const long long frame_size = total_size - size;\n            if (frame_size > LONG_MAX)\n                return E_FILE_FORMAT_INVALID;\n            f.len = static_cast<long>(frame_size);\n        }\n        pf = m_frames;\n        while (pf != pf_end)\n        {\n            Frame& f = *pf++;\n            assert((pos + f.len) <= stop);\n            f.pos = pos;\n            pos += f.len;\n        }\n        assert(pos == stop);\n    }\n    else if (lacing == 2)  \/\/fixed-size lacing\n    {\n        const long long total_size = stop - pos;\n        if ((total_size % m_frame_count) != 0)\n            return E_FILE_FORMAT_INVALID;\n        const long long frame_size = total_size \/ m_frame_count;\n        if (frame_size > LONG_MAX)\n            return E_FILE_FORMAT_INVALID;\n        Frame* pf = m_frames;\n        Frame* const pf_end = pf + m_frame_count;\n        while (pf != pf_end)\n        {\n            assert((pos + frame_size) <= stop);\n            Frame& f = *pf++;\n            f.pos = pos;\n            f.len = static_cast<long>(frame_size);\n            pos += frame_size;\n        }\n        assert(pos == stop);\n    }\n    else\n    {\n        assert(lacing == 3);  \/\/EBML lacing\n \n         if (pos >= stop)\n            return E_FILE_FORMAT_INVALID;\n \n        long size = 0;\n        int frame_count = m_frame_count;\n \n        long long frame_size = ReadUInt(pReader, pos, len);\n \n        if (frame_size < 0)\n            return E_FILE_FORMAT_INVALID;\n \n        if (frame_size > LONG_MAX)\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > stop)\n            return E_FILE_FORMAT_INVALID;\n \n        pos += len; \/\/consume length of size of first frame\n \n        if ((pos + frame_size) > stop)\n            return E_FILE_FORMAT_INVALID;\n \n        Frame* pf = m_frames;\n        Frame* const pf_end = pf + m_frame_count;\n \n        {\n            Frame& curr = *pf;\n            curr.pos = 0;  \/\/patch later\n            curr.len = static_cast<long>(frame_size);\n            size += curr.len;  \/\/contribution of this frame\n        }\n        --frame_count;\n        while (frame_count > 1)\n        {\n            if (pos >= stop)\n                return E_FILE_FORMAT_INVALID;\n            assert(pf < pf_end);\n            const Frame& prev = *pf++;\n            assert(prev.len == frame_size);\n            if (prev.len != frame_size)\n                return E_FILE_FORMAT_INVALID;\n            assert(pf < pf_end);\n            Frame& curr = *pf;\n            curr.pos = 0;  \/\/patch later\n            const long long delta_size_ = ReadUInt(pReader, pos, len);\n            if (delta_size_ < 0)\n                return E_FILE_FORMAT_INVALID;\n            if ((pos + len) > stop)\n                return E_FILE_FORMAT_INVALID;\n            pos += len;  \/\/consume length of (delta) size\n            assert(pos <= stop);\n            const int exp = 7*len - 1;\n            const long long bias = (1LL << exp) - 1LL;\n            const long long delta_size = delta_size_ - bias;\n            frame_size += delta_size;\n            if (frame_size < 0)\n                return E_FILE_FORMAT_INVALID;\n            if (frame_size > LONG_MAX)\n                return E_FILE_FORMAT_INVALID;\n            curr.len = static_cast<long>(frame_size);\n            size += curr.len;  \/\/contribution of this frame\n            --frame_count;\n        }\n        {\n            assert(pos <= stop);\n            assert(pf < pf_end);\n            const Frame& prev = *pf++;\n            assert(prev.len == frame_size);\n            if (prev.len != frame_size)\n                return E_FILE_FORMAT_INVALID;\n            assert(pf < pf_end);\n            Frame& curr = *pf++;\n            assert(pf == pf_end);\n            curr.pos = 0;  \/\/patch later\n            const long long total_size = stop - pos;\n            if (total_size < size)\n                return E_FILE_FORMAT_INVALID;\n            frame_size = total_size - size;\n            if (frame_size > LONG_MAX)\n                return E_FILE_FORMAT_INVALID;\n            curr.len = static_cast<long>(frame_size);\n        }\n        pf = m_frames;\n        while (pf != pf_end)\n        {\n            Frame& f = *pf++;\n            assert((pos + f.len) <= stop);\n            f.pos = pos;\n            pos += f.len;\n        }\n        assert(pos == stop);\n     }\n \n    return 0;  \/\/success\n }\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftGSM::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = 1;\n            pcmParams->nSamplingRate = 8000;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void SetUp() {\n\n     fwd_txfm_ = GET_PARAM(0);\n     inv_txfm_ = GET_PARAM(1);\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 16;\n     fwd_txfm_ref = fdct16x16_ref;\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Chapters::Edition::Edition()\n{\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Track::GetFirst(const BlockEntry*& pBlockEntry) const\n{\n    const Cluster* pCluster = m_pSegment->GetFirst();\n    for (int i = 0; ; )\n    {\n        if (pCluster == NULL)\n        {\n            pBlockEntry = GetEOS();\n            return 1;\n        }\n        if (pCluster->EOS())\n        {\n #if 0\n            if (m_pSegment->Unparsed() <= 0)  \/\/all clusters have been loaded\n            {\n                 pBlockEntry = GetEOS();\n                 return 1;\n             }\n #else\n            if (m_pSegment->DoneParsing())\n            {\n                pBlockEntry = GetEOS();\n                return 1;\n            }\n #endif\n \n            pBlockEntry = 0;\n            return E_BUFFER_NOT_FULL;\n        }\n        long status = pCluster->GetFirst(pBlockEntry);\n        if (status < 0)  \/\/error\n            return status;\n        if (pBlockEntry == 0)  \/\/empty cluster\n        {\n            pCluster = m_pSegment->GetNext(pCluster);\n            continue;\n        }\n        for (;;)\n        {\n            const Block* const pBlock = pBlockEntry->GetBlock();\n            assert(pBlock);\n            const long long tn = pBlock->GetTrackNumber();\n            if ((tn == m_info.number) && VetEntry(pBlockEntry))\n                return 0;\n            const BlockEntry* pNextEntry;\n            status = pCluster->GetNext(pBlockEntry, pNextEntry);\n            if (status < 0)  \/\/error\n                return status;\n            if (pNextEntry == 0)\n                break;\n            pBlockEntry = pNextEntry;\n        }\n        ++i;\n        if (i >= 100)\n            break;\n        pCluster = m_pSegment->GetNext(pCluster);\n     }\n \n \n    pBlockEntry = GetEOS();  \/\/so we can return a non-NULL value\n    return 1;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_x509_parse)\n{\n\tzval ** zcert;\n\tX509 * cert = NULL;\n\tlong certresource = -1;\n\tint i;\n\tzend_bool useshortnames = 1;\n\tchar * tmpstr;\n\tzval * subitem;\n\tX509_EXTENSION *extension;\n\tchar *extname;\n\tBIO  *bio_out;\n\tBUF_MEM *bio_buf;\n\tchar buf[256];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z|b\", &zcert, &useshortnames) == FAILURE) {\n\t\treturn;\n\t}\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tarray_init(return_value);\n\n\tif (cert->name) {\n\t\tadd_assoc_string(return_value, \"name\", cert->name, 1);\n\t}\n\/*\tadd_assoc_bool(return_value, \"valid\", cert->valid); *\/\n\n\tadd_assoc_name_entry(return_value, \"subject\", \t\tX509_get_subject_name(cert), useshortnames TSRMLS_CC);\n\t\/* hash as used in CA directories to lookup cert by subject name *\/\n\t{\n\t\tchar buf[32];\n\t\tsnprintf(buf, sizeof(buf), \"%08lx\", X509_subject_name_hash(cert));\n\t\tadd_assoc_string(return_value, \"hash\", buf, 1);\n\t}\n\t\n\tadd_assoc_name_entry(return_value, \"issuer\", \t\tX509_get_issuer_name(cert), useshortnames TSRMLS_CC);\n\tadd_assoc_long(return_value, \"version\", \t\t\tX509_get_version(cert));\n\n\tadd_assoc_string(return_value, \"serialNumber\", i2s_ASN1_INTEGER(NULL, X509_get_serialNumber(cert)), 1); \n\n\tadd_assoc_asn1_string(return_value, \"validFrom\", \tX509_get_notBefore(cert));\n\tadd_assoc_asn1_string(return_value, \"validTo\", \t\tX509_get_notAfter(cert));\n\n\tadd_assoc_long(return_value, \"validFrom_time_t\", \tasn1_time_to_time_t(X509_get_notBefore(cert) TSRMLS_CC));\n\tadd_assoc_long(return_value, \"validTo_time_t\", \t\tasn1_time_to_time_t(X509_get_notAfter(cert) TSRMLS_CC));\n\n\ttmpstr = (char *)X509_alias_get0(cert, NULL);\n\tif (tmpstr) {\n\t\tadd_assoc_string(return_value, \"alias\", tmpstr, 1);\n\t}\n\/*\n\tadd_assoc_long(return_value, \"signaturetypeLONG\", X509_get_signature_type(cert));\n\tadd_assoc_string(return_value, \"signaturetype\", OBJ_nid2sn(X509_get_signature_type(cert)), 1);\n\tadd_assoc_string(return_value, \"signaturetypeLN\", OBJ_nid2ln(X509_get_signature_type(cert)), 1);\n*\/\n\tMAKE_STD_ZVAL(subitem);\n\tarray_init(subitem);\n\n\t\/* NOTE: the purposes are added as integer keys - the keys match up to the X509_PURPOSE_SSL_XXX defines\n\t   in x509v3.h *\/\n\tfor (i = 0; i < X509_PURPOSE_get_count(); i++) {\n\t\tint id, purpset;\n\t\tchar * pname;\n\t\tX509_PURPOSE * purp;\n\t\tzval * subsub;\n\n\t\tMAKE_STD_ZVAL(subsub);\n\t\tarray_init(subsub);\n\n\t\tpurp = X509_PURPOSE_get0(i);\n\t\tid = X509_PURPOSE_get_id(purp);\n\n\t\tpurpset = X509_check_purpose(cert, id, 0);\n\t\tadd_index_bool(subsub, 0, purpset);\n\n\t\tpurpset = X509_check_purpose(cert, id, 1);\n\t\tadd_index_bool(subsub, 1, purpset);\n\n\t\tpname = useshortnames ? X509_PURPOSE_get0_sname(purp) : X509_PURPOSE_get0_name(purp);\n\t\tadd_index_string(subsub, 2, pname, 1);\n\n\t\t\/* NOTE: if purpset > 1 then it's a warning - we should mention it ? *\/\n\n\t\tadd_index_zval(subitem, id, subsub);\n\t}\n\tadd_assoc_zval(return_value, \"purposes\", subitem);\n\n\tMAKE_STD_ZVAL(subitem);\n\tarray_init(subitem);\n\n\n\tfor (i = 0; i < X509_get_ext_count(cert); i++) {\n\t\tint nid;\n\t\textension = X509_get_ext(cert, i);\n\t\tnid = OBJ_obj2nid(X509_EXTENSION_get_object(extension));\n\t\tif (nid != NID_undef) {\n\t\t\textname = (char *)OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(extension)));\n\t\t} else {\n\t\t\tOBJ_obj2txt(buf, sizeof(buf)-1, X509_EXTENSION_get_object(extension), 1);\n\t\t\textname = buf;\n\t\t}\n\t\tbio_out = BIO_new(BIO_s_mem());\n\t\tif (nid == NID_subject_alt_name) {\n\t\t\tif (openssl_x509v3_subjectAltName(bio_out, extension) == 0) {\n\t\t\t\tBIO_get_mem_ptr(bio_out, &bio_buf);\n\t\t\t\tadd_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);\n\t\t\t} else {\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tif (certresource == -1 && cert) {\n\t\t\t\t\tX509_free(cert);\n\t\t\t\t}\n\t\t\t\tBIO_free(bio_out);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t\telse if (X509V3_EXT_print(bio_out, extension, 0, 0)) {\n\t\t\tBIO_get_mem_ptr(bio_out, &bio_buf);\n\t\t\tadd_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);\n\t\t} else {\n\t\t\tadd_assoc_asn1_string(subitem, extname, X509_EXTENSION_get_data(extension));\n\t\t}\n\t\tBIO_free(bio_out);\n\t}\n\tadd_assoc_zval(return_value, \"extensions\", subitem);\n\n\tif (certresource == -1 && cert) {\n\t\tX509_free(cert);\n\t}\n}\n","project":"php","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"add_mrange(fz_context *ctx, pdf_cmap *cmap, unsigned int low, int *out, int len)\n{\n\tint out_pos;\n\n\tif (cmap->dlen + len + 1 > cmap->dcap)\n\t{\n\t\tint new_cap = cmap->dcap ? cmap->dcap * 2 : 256;\n\t\tcmap->dict = fz_resize_array(ctx, cmap->dict, new_cap, sizeof *cmap->dict);\n\t\tcmap->dcap = new_cap;\n\t}\n\tout_pos = cmap->dlen;\n\tcmap->dict[out_pos] = len;\n\tmemcpy(&cmap->dict[out_pos+1], out, sizeof(int)*len);\n\tcmap->dlen += len + 1;\n\n\tadd_range(ctx, cmap, low, low, out_pos, 1, 1);\n}\n","project":"ghostscript","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"phar_entry_info * phar_open_jit(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC) \/* {{{ *\/\n{\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\t\/* seek to start of internal file and read it *\/\n\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\treturn NULL;\n\t}\n\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC)) {\n\t\tspprintf(error, 4096, \"phar error: cannot seek to start of file \\\"%s\\\" in phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\treturn NULL;\n\t}\n\treturn entry;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_prim_group_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const attrs[] = {\n\t\t\"primaryGroupID\",\n\t\t\"memberOf\",\n\t\t\"userAccountControl\",\n\t\tNULL };\n\tstruct ldb_result *res, *group_res;\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *msg;\n\tuint32_t prev_rid, new_rid, uac;\n\tstruct dom_sid *prev_sid, *new_sid;\n\tstruct ldb_dn *prev_prim_group_dn, *new_prim_group_dn;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tel = dsdb_get_single_valued_attr(ac->msg, \"primaryGroupID\",\n\t\t\t\t\t ac->req->operation);\n\tif (el == NULL) {\n\t\t\/* we are not affected *\/\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* Fetch information from the existing object *\/\n\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tuac = ldb_msg_find_attr_as_uint(res->msgs[0], \"userAccountControl\", 0);\n\n\t\/* Finds out the DN of the old primary group *\/\n\n\tprev_rid = ldb_msg_find_attr_as_uint(res->msgs[0], \"primaryGroupID\",\n\t\t\t\t\t     (uint32_t) -1);\n\tif (prev_rid == (uint32_t) -1) {\n\t\t\/* User objects do always have a mandatory \"primaryGroupID\"\n\t\t * attribute. If this doesn't exist then the object is of the\n\t\t * wrong type. This is the exact Windows error code *\/\n\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t}\n\n\tprev_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), prev_rid);\n\tif (prev_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t\/* Finds out the DN of the new primary group\n\t * Notice: in order to parse the primary group ID correctly we create\n\t * a temporary message here. *\/\n\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tnew_rid = ldb_msg_find_attr_as_uint(msg, \"primaryGroupID\", (uint32_t) -1);\n\ttalloc_free(msg);\n\tif (new_rid == (uint32_t) -1) {\n\t\t\/* we aren't affected of any primary group change *\/\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif (prev_rid == new_rid) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif ((uac & UF_SERVER_TRUST_ACCOUNT) && new_rid != DOMAIN_RID_DCS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: UF_SERVER_TRUST_ACCOUNT requires \"\n\t\t\t\"primaryGroupID=%u!\",\n\t\t\tW_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),\n\t\t\tDOMAIN_RID_DCS);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tif ((uac & UF_PARTIAL_SECRETS_ACCOUNT) && new_rid != DOMAIN_RID_READONLY_DCS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: UF_PARTIAL_SECRETS_ACCOUNT requires \"\n\t\t\t\"primaryGroupID=%u!\",\n\t\t\tW_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),\n\t\t\tDOMAIN_RID_READONLY_DCS);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &group_res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, prev_sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (group_res->count != 1) {\n\t\treturn ldb_operr(ldb);\n\t}\n\tprev_prim_group_dn = group_res->msgs[0]->dn;\n\n\tnew_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), new_rid);\n\tif (new_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &group_res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, new_sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (group_res->count != 1) {\n\t\t\/* Here we know if the specified new primary group candidate is\n\t\t * valid or not. *\/\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tnew_prim_group_dn = group_res->msgs[0]->dn;\n\n\t\/* We need to be already a normal member of the new primary\n\t * group in order to be successful. *\/\n\tel = samdb_find_attribute(ldb, res->msgs[0], \"memberOf\",\n\t\t\t\t  ldb_dn_get_linearized(new_prim_group_dn));\n\tif (el == NULL) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t\/* Remove the \"member\" attribute on the new primary group *\/\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tmsg->dn = new_prim_group_dn;\n\n\tret = samdb_msg_add_delval(ldb, msg, msg, \"member\",\n\t\t\t\t   ldb_dn_get_linearized(ac->msg->dn));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\n\t\/* Add a \"member\" attribute for the previous primary group *\/\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tmsg->dn = prev_prim_group_dn;\n\n\tret = samdb_msg_add_addval(ldb, msg, msg, \"member\",\n\t\t\t\t   ldb_dn_get_linearized(ac->msg->dn));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\n\treturn LDB_SUCCESS;\n}\n","project":"samba","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"static size_t phar_dir_write(php_stream *stream, const char *buf, size_t count TSRMLS_DC) \/* {{{ *\/\n{\n\treturn 0;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_set_cmm_engine(fz_context *ctx, const fz_cmm_engine *engine)\n{\n\tfz_colorspace_context *cct;\n\n\tif (!ctx)\n\t\treturn;\n\tcct = ctx->colorspace;\n\tif (!cct)\n\t\treturn;\n\n#ifdef NO_ICC\n\tif (engine)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"ICC workflow not supported in NO_ICC build\");\n#else\n\tif (cct->cmm == engine)\n\t\treturn;\n\n\tfz_drop_cmm_context(ctx);\n\tfz_drop_colorspace(ctx, cct->gray);\n\tfz_drop_colorspace(ctx, cct->rgb);\n\tfz_drop_colorspace(ctx, cct->bgr);\n\tfz_drop_colorspace(ctx, cct->cmyk);\n\tfz_drop_colorspace(ctx, cct->lab);\n\tcct->gray = NULL;\n\tcct->rgb = NULL;\n\tcct->bgr = NULL;\n\tcct->cmyk = NULL;\n\tcct->lab = NULL;\n\tcct->cmm = engine;\n\tfz_new_cmm_context(ctx);\n\tif (engine)\n\t{\n\t\tcct->gray = fz_new_icc_colorspace(ctx, FZ_ICC_PROFILE_GRAY, 1, NULL);\n\t\tcct->rgb = fz_new_icc_colorspace(ctx, FZ_ICC_PROFILE_RGB, 3, NULL);\n\t\tcct->bgr = fz_new_icc_colorspace(ctx, FZ_ICC_PROFILE_BGR, 3, NULL);\n\t\tcct->cmyk = fz_new_icc_colorspace(ctx, FZ_ICC_PROFILE_CMYK, 4, NULL);\n\t\tcct->lab = fz_new_icc_colorspace(ctx, FZ_ICC_PROFILE_LAB, 3, NULL);\n\t}\n\telse\n\t\tset_no_icc(cct);\n#endif\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long SeekHead::Parse()\n{\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n \n    long long pos = m_start;\n    const long long stop = m_start + m_size;\n \n \n    int entry_count = 0;\n    int void_element_count = 0;\n \n    while (pos < stop)\n    {\n        long long id, size;\n \n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n \n        if (status < 0)  \/\/error\n            return status;\n \n        if (id == 0x0DBB)  \/\/SeekEntry ID\n            ++entry_count;\n        else if (id == 0x6C)  \/\/Void ID\n            ++void_element_count;\n \n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n \n    m_entries = new (std::nothrow) Entry[entry_count];\n \n    if (m_entries == NULL)\n        return -1;\n \n    m_void_elements = new (std::nothrow) VoidElement[void_element_count];\n \n    if (m_void_elements == NULL)\n        return -1;\n \n \n    Entry* pEntry = m_entries;\n    VoidElement* pVoidElement = m_void_elements;\n \n    pos = m_start;\n \n    while (pos < stop)\n    {\n        const long long idpos = pos;\n        long long id, size;\n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n        if (status < 0)  \/\/error\n            return status;\n        if (id == 0x0DBB)  \/\/SeekEntry ID\n        {\n            if (ParseEntry(pReader, pos, size, pEntry))\n            {\n                Entry& e = *pEntry++;\n                e.element_start = idpos;\n                e.element_size = (pos + size) - idpos;\n            }\n        }\n        else if (id == 0x6C)  \/\/Void ID\n        {\n            VoidElement& e = *pVoidElement++;\n            e.element_start = idpos;\n            e.element_size = (pos + size) - idpos;\n        }\n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);\n    assert(count_ >= 0);\n    assert(count_ <= entry_count);\n    m_entry_count = static_cast<int>(count_);\n    count_ = ptrdiff_t(pVoidElement - m_void_elements);\n    assert(count_ >= 0);\n    assert(count_ <= void_element_count);\n    m_void_element_count = static_cast<int>(count_);\n     return 0;\n }\n","project":"Android","target":1},{"commit_id":"9fe27a9b445f7e911286ed31c1087ceac567736b","func":"uint8_t rfc_parse_data(tRFC_MCB* p_mcb, MX_FRAME* p_frame, BT_HDR* p_buf) {\n uint8_t ead, eal, fcs;\n uint8_t* p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n uint8_t* p_start = p_data;\n uint16_t len;\n\n if (p_buf->len < RFCOMM_CTRL_FRAME_LEN) {\n    RFCOMM_TRACE_ERROR(\"Bad Length1: %d\", p_buf->len);\n return (RFC_EVENT_BAD_FRAME);\n }\n\n  RFCOMM_PARSE_CTRL_FIELD(ead, p_frame->cr, p_frame->dlci, p_data);\n if (!ead) {\n    RFCOMM_TRACE_ERROR(\"Bad Address(EA must be 1)\");\n\n     return (RFC_EVENT_BAD_FRAME);\n   }\n   RFCOMM_PARSE_TYPE_FIELD(p_frame->type, p_frame->pf, p_data);\n  RFCOMM_PARSE_LEN_FIELD(eal, len, p_data);\n \n   p_buf->len -= (3 + !ead + !eal + 1); \/* Additional 1 for FCS *\/\n   p_buf->offset += (3 + !ead + !eal);\n\n \/* handle credit if credit based flow control *\/\n if ((p_mcb->flow == PORT_FC_CREDIT) && (p_frame->type == RFCOMM_UIH) &&\n (p_frame->dlci != RFCOMM_MX_DLCI) && (p_frame->pf == 1)) {\n    p_frame->credit = *p_data++;\n    p_buf->len--;\n    p_buf->offset++;\n } else\n    p_frame->credit = 0;\n\n if (p_buf->len != len) {\n    RFCOMM_TRACE_ERROR(\"Bad Length2 %d %d\", p_buf->len, len);\n return (RFC_EVENT_BAD_FRAME);\n }\n\n  fcs = *(p_data + len);\n\n \/* All control frames that we are sending are sent with P=1, expect *\/\n \/* reply with F=1 *\/\n \/* According to TS 07.10 spec ivalid frames are discarded without *\/\n \/* notification to the sender *\/\n switch (p_frame->type) {\n case RFCOMM_SABME:\n if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) ||\n !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad SABME\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_SABME);\n\n case RFCOMM_UA:\n if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) ||\n !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad UA\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_UA);\n\n case RFCOMM_DM:\n if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) || len ||\n !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad DM\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_DM);\n\n case RFCOMM_DISC:\n if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) ||\n !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad DISC\");\n return (RFC_EVENT_BAD_FRAME);\n } else\n return (RFC_EVENT_DISC);\n\n case RFCOMM_UIH:\n if (!RFCOMM_VALID_DLCI(p_frame->dlci)) {\n        RFCOMM_TRACE_ERROR(\"Bad UIH - invalid DLCI\");\n return (RFC_EVENT_BAD_FRAME);\n } else if (!rfc_check_fcs(2, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad UIH - FCS\");\n return (RFC_EVENT_BAD_FRAME);\n } else if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr)) {\n \/* we assume that this is ok to allow bad implementations to work *\/\n        RFCOMM_TRACE_ERROR(\"Bad UIH - response\");\n return (RFC_EVENT_UIH);\n } else\n return (RFC_EVENT_UIH);\n }\n\n return (RFC_EVENT_BAD_FRAME);\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAACEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.aac\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAAC)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mBitRate = aacParams->nBitRate;\n            mNumChannels = aacParams->nChannels;\n            mSampleRate = aacParams->nSampleRate;\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"static void add_warning(Scanner *s, char *error)\n{\n\ts->errors->warning_count++;\n\ts->errors->warning_messages = realloc(s->errors->warning_messages, s->errors->warning_count * sizeof(timelib_error_message));\n\ts->errors->warning_messages[s->errors->warning_count - 1].position = s->tok ? s->tok - s->str : 0;\n\ts->errors->warning_messages[s->errors->warning_count - 1].character = s->tok ? *s->tok : 0;\n\ts->errors->warning_messages[s->errors->warning_count - 1].message = strdup(error);\n}\n","project":"php","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_EX(fz_context *ctx, pdf_processor *proc)\n{\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Chapters::Atom::GetStopTimecode() const\n{\n    return m_stop_timecode;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void CuePoint::TrackPosition::Parse(\n    IMkvReader* pReader,\n    long long start_,\n    long long size_)\n{\n    const long long stop = start_ + size_;\n    long long pos = start_;\n \n    m_track = -1;\n    m_pos = -1;\n    m_block = 1;  \/\/default\n \n    while (pos < stop)\n    {\n        long len;\n \n        const long long id = ReadUInt(pReader, pos, len);\n        assert(id >= 0);  \/\/TODO\n        assert((pos + len) <= stop);\n \n        pos += len;  \/\/consume ID\n \n        const long long size = ReadUInt(pReader, pos, len);\n        assert(size >= 0);\n        assert((pos + len) <= stop);\n \n        pos += len;  \/\/consume Size field\n        assert((pos + size) <= stop);\n \n        if (id == 0x77)  \/\/CueTrack ID\n            m_track = UnserializeUInt(pReader, pos, size);\n \n        else if (id == 0x71)  \/\/CueClusterPos ID\n            m_pos = UnserializeUInt(pReader, pos, size);\n \n        else if (id == 0x1378)  \/\/CueBlockNumber\n            m_block = UnserializeUInt(pReader, pos, size);\n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n    }\n    assert(m_pos >= 0);\n    assert(m_track > 0);\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"int php_openssl_get_x509_list_id(void) \/* {{{ *\/\n{\n\treturn le_x509;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"free_cal(fz_context *ctx, fz_colorspace *cs)\n{\n\tfz_cal_colorspace *cal_data = cs->data;\n\tif (cal_data->profile != NULL)\n\t{\n\t\tfz_drop_buffer(ctx, cal_data->profile->buffer);\n\t\tfz_cmm_fin_profile(ctx, cal_data->profile);\n\t\tfz_free(ctx, cal_data->profile);\n\t}\n\tfz_free(ctx, cal_data);\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"attrhash_cmp (const void *p1, const void *p2)\n{\n  const struct attr * attr1 = p1;\n  const struct attr * attr2 = p2;\n\n  if (attr1->flag == attr2->flag\n      && attr1->origin == attr2->origin\n      && attr1->nexthop.s_addr == attr2->nexthop.s_addr\n      && attr1->aspath == attr2->aspath\n      && attr1->community == attr2->community\n      && attr1->med == attr2->med\n      && attr1->local_pref == attr2->local_pref)\n    {\n      const struct attr_extra *ae1 = attr1->extra;\n      const struct attr_extra *ae2 = attr2->extra;\n      \n      if (ae1 && ae2\n          && ae1->aggregator_as == ae2->aggregator_as\n          && ae1->aggregator_addr.s_addr == ae2->aggregator_addr.s_addr\n          && ae1->weight == ae2->weight\n#ifdef HAVE_IPV6\n          && ae1->mp_nexthop_len == ae2->mp_nexthop_len\n          && IPV6_ADDR_SAME (&ae1->mp_nexthop_global, &ae2->mp_nexthop_global)\n          && IPV6_ADDR_SAME (&ae1->mp_nexthop_local, &ae2->mp_nexthop_local)\n#endif \/* HAVE_IPV6 *\/\n          && IPV4_ADDR_SAME (&ae1->mp_nexthop_global_in, &ae2->mp_nexthop_global_in)\n          && ae1->ecommunity == ae2->ecommunity\n          && ae1->cluster == ae2->cluster\n          && ae1->transit == ae2->transit)\n        return 1;\n      else if (ae1 || ae2)\n        return 0;\n      \/* neither attribute has extra attributes, so they're same *\/\n      return 1;\n    }\n  else\n    return 0;\n}\n","project":"savannah","target":0},{"commit_id":"3c4edac2a5b00dec6c8579a0ee658cfb3bb16d94","func":" void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_device_gray(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn fz_colorspace_is_device(ctx, cs) && fz_colorspace_is_gray(ctx, cs);\n}\n","project":"ghostscript","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_fill_object(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\n\t\/* Add information for the different account types *\/\n\tswitch(ac->type) {\n\tcase SAMLDB_TYPE_USER: {\n\t\tstruct ldb_control *rodc_control = ldb_request_get_control(ac->req,\n\t\t\t\t\t\t\t\t\t   LDB_CONTROL_RODC_DCPROMO_OID);\n\t\tif (rodc_control != NULL) {\n\t\t\t\/* see [MS-ADTS] 3.1.1.3.4.1.23 LDAP_SERVER_RODC_DCPROMO_OID *\/\n\t\t\trodc_control->critical = false;\n\t\t\tret = samldb_add_step(ac, samldb_rodc_add);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t}\n\n\t\t\/* check if we have a valid sAMAccountName *\/\n\t\tret = samldb_add_step(ac, samldb_check_sAMAccountName);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_GROUP: {\n\t\t\/* check if we have a valid sAMAccountName *\/\n\t\tret = samldb_add_step(ac, samldb_check_sAMAccountName);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_CLASS: {\n\t\tconst struct ldb_val *rdn_value, *def_obj_cat_val;\n\t\tunsigned int v = ldb_msg_find_attr_as_uint(ac->msg, \"objectClassCategory\", -2);\n\n\t\t\/* As discussed with Microsoft through dochelp in April 2012 this is the behavior of windows*\/\n\t\tif (!ldb_msg_find_element(ac->msg, \"subClassOf\")) {\n\t\t\tret = ldb_msg_add_string(ac->msg, \"subClassOf\", \"top\");\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t}\n\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"rdnAttId\", \"cn\");\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* do not allow to mark an attributeSchema as RODC filtered if it\n\t\t * is system-critical *\/\n\t\tif (check_rodc_critical_attribute(ac->msg)) {\n\t\t\tldb_asprintf_errstring(ldb, \"Refusing schema add of %s - cannot combine critical class with RODC filtering\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tif (!ldb_msg_find_element(ac->msg, \"lDAPDisplayName\")) {\n\t\t\t\/* the RDN has prefix \"CN\" *\/\n\t\t\tret = ldb_msg_add_string(ac->msg, \"lDAPDisplayName\",\n\t\t\t\tsamdb_cn_to_lDAPDisplayName(ac->msg,\n\t\t\t\t\t\t\t    (const char *) rdn_value->data));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (!ldb_msg_find_element(ac->msg, \"schemaIDGUID\")) {\n\t\t\tstruct GUID guid;\n\t\t\t\/* a new GUID *\/\n\t\t\tguid = GUID_random();\n\t\t\tret = dsdb_msg_add_guid(ac->msg, &guid, \"schemaIDGUID\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tdef_obj_cat_val = ldb_msg_find_ldb_val(ac->msg,\n\t\t\t\t\t\t       \"defaultObjectCategory\");\n\t\tif (def_obj_cat_val != NULL) {\n\t\t\t\/* \"defaultObjectCategory\" has been set by the caller.\n\t\t\t * Do some checks for consistency.\n\t\t\t * NOTE: The real constraint check (that\n\t\t\t * 'defaultObjectCategory' is the DN of the new\n\t\t\t * objectclass or any parent of it) is still incomplete.\n\t\t\t * For now we say that 'defaultObjectCategory' is valid\n\t\t\t * if it exists and it is of objectclass \"classSchema\".\n\t\t\t *\/\n\t\t\tac->dn = ldb_dn_from_ldb_val(ac, ldb, def_obj_cat_val);\n\t\t\tif (ac->dn == NULL) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\t  \"Invalid DN for 'defaultObjectCategory'!\");\n\t\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t\t}\n\t\t} else {\n\t\t\t\/* \"defaultObjectCategory\" has not been set by the\n\t\t\t * caller. Use the entry DN for it. *\/\n\t\t\tac->dn = ac->msg->dn;\n\n\t\t\tret = ldb_msg_add_string(ac->msg, \"defaultObjectCategory\",\n\t\t\t\t\t\t ldb_dn_alloc_linearized(ac->msg, ac->dn));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* Now perform the checks for the 'defaultObjectCategory'. The\n\t\t * lookup DN was already saved in \"ac->dn\" *\/\n\t\tret = samldb_add_step(ac, samldb_find_for_defaultObjectCategory);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* -2 is not a valid objectClassCategory so it means the attribute wasn't present *\/\n\t\tif (v == -2) {\n\t\t\t\/* Windows 2003 does this*\/\n\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"objectClassCategory\", 0);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_ATTRIBUTE: {\n\t\tconst struct ldb_val *rdn_value;\n\t\tstruct ldb_message_element *el;\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tif (!ldb_msg_find_element(ac->msg, \"lDAPDisplayName\")) {\n\t\t\t\/* the RDN has prefix \"CN\" *\/\n\t\t\tret = ldb_msg_add_string(ac->msg, \"lDAPDisplayName\",\n\t\t\t\tsamdb_cn_to_lDAPDisplayName(ac->msg,\n\t\t\t\t\t\t\t    (const char *) rdn_value->data));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t\/* do not allow to mark an attributeSchema as RODC filtered if it\n\t\t * is system-critical *\/\n\t\tif (check_rodc_critical_attribute(ac->msg)) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: refusing schema add of %s - cannot combine critical attribute with RODC filtering\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"isSingleValued\", \"FALSE\");\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tif (!ldb_msg_find_element(ac->msg, \"schemaIDGUID\")) {\n\t\t\tstruct GUID guid;\n\t\t\t\/* a new GUID *\/\n\t\t\tguid = GUID_random();\n\t\t\tret = dsdb_msg_add_guid(ac->msg, &guid, \"schemaIDGUID\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tel = ldb_msg_find_element(ac->msg, \"attributeSyntax\");\n\t\tif (el) {\n\t\t\t\/*\n\t\t\t * No need to scream if there isn't as we have code later on\n\t\t\t * that will take care of it.\n\t\t\t *\/\n\t\t\tconst struct dsdb_syntax *syntax = find_syntax_map_by_ad_oid((const char *)el->values[0].data);\n\t\t\tif (!syntax) {\n\t\t\t\tDEBUG(9, (\"Can't find dsdb_syntax object for attributeSyntax %s\\n\",\n\t\t\t\t\t\t(const char *)el->values[0].data));\n\t\t\t} else {\n\t\t\t\tunsigned int v = ldb_msg_find_attr_as_uint(ac->msg, \"oMSyntax\", 0);\n\t\t\t\tconst struct ldb_val *val = ldb_msg_find_ldb_val(ac->msg, \"oMObjectClass\");\n\n\t\t\t\tif (v == 0) {\n\t\t\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"oMSyntax\", syntax->oMSyntax);\n\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!val) {\n\t\t\t\t\tstruct ldb_val val2 = ldb_val_dup(ldb, &syntax->oMObjectClass);\n\t\t\t\t\tif (val2.length > 0) {\n\t\t\t\t\t\tret = ldb_msg_add_value(ac->msg, \"oMObjectClass\", &val2, NULL);\n\t\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\/* handle msDS-IntID attribute *\/\n\t\tret = samldb_add_handle_msDS_IntId(ac);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb, \"Invalid entry type!\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\tbreak;\n\t}\n\n\treturn samldb_first_step(ac);\n}\n","project":"samba","target":0},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"static char *timelib_string(Scanner *s)\n{\n\tchar *tmp = calloc(1, s->cur - s->tok + 1);\n\tmemcpy(tmp, s->tok, s->cur - s->tok);\n\n\treturn tmp;\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"icc_conv_color(fz_context *ctx, fz_color_converter *cc, float *dstv, const float *srcv)\n{\n\tconst fz_colorspace *dsts = cc->ds;\n\tint src_n = cc->n;\n\tint dst_n = dsts->n;\n\n\tfz_icclink *link = (fz_icclink *)cc->link;\n\tint i;\n\tunsigned short dstv_s[FZ_MAX_COLORS];\n\tunsigned short srcv_s[FZ_MAX_COLORS];\n\n\t\/* Special case.  Link is NULL if we are doing DeviceGray to CMYK *\/\n\tif (link == NULL)\n\t{\n\t\tdstv[0] = 0;\n\t\tdstv[1] = 0;\n\t\tdstv[2] = 0;\n\t\tdstv[3] = 1 - srcv[0];\n\t}\n\telse if (link->is_identity)\n\t{\n\t\tfor (i = 0; i < src_n; i++)\n\t\t\tdstv[i] = srcv[i];\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < src_n; i++)\n\t\t\tsrcv_s[i] = srcv[i] * 65535;\n\t\tfz_cmm_transform_color(ctx, link, dstv_s, srcv_s);\n\t\tfor (i = 0; i < dst_n; i++)\n\t\t\tdstv[i] = fz_clamp((float) dstv_s[i] \/ 65535.0f, 0, 1);\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Track::Info::Info():\n    uid(0),\n    defaultDuration(0),\n    codecDelay(0),\n    seekPreRoll(0),\n    nameAsUTF8(NULL),\n    language(NULL),\n    codecId(NULL),\n    codecNameAsUTF8(NULL),\n    codecPrivate(NULL),\n    codecPrivateSize(0),\n    lacing(false)\n{\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_FUNCTION(preg_quote)\n{\n\tint\t\t in_str_len;\n\tchar\t*in_str;\t\t\/* Input string argument *\/\n\tchar\t*in_str_end;    \/* End of the input string *\/\n\tint\t\t delim_len = 0;\n\tchar\t*delim = NULL;\t\/* Additional delimiter argument *\/\n\tchar\t*out_str,\t\t\/* Output string with quoted characters *\/\n\t\t \t*p,\t\t\t\t\/* Iterator for input string *\/\n\t\t\t*q,\t\t\t\t\/* Iterator for output string *\/\n\t\t\t delim_char=0,\t\/* Delimiter character to be quoted *\/\n\t\t\t c;\t\t\t\t\/* Current character *\/\n\tzend_bool quote_delim = 0; \/* Whether to quote additional delim char *\/\n\t\n\t\/* Get the arguments and check for errors *\/\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\", &in_str, &in_str_len,\n\t\t\t\t\t\t\t  &delim, &delim_len) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tin_str_end = in_str + in_str_len;\n\n\t\/* Nothing to do if we got an empty string *\/\n\tif (in_str == in_str_end) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\n\tif (delim && *delim) {\n\t\tdelim_char = delim[0];\n\t\tquote_delim = 1;\n\t}\n\t\n\t\/* Allocate enough memory so that even if each character\n\t   is quoted, we won't run out of room *\/\n\tout_str = safe_emalloc(4, in_str_len, 1);\n\t\n\t\/* Go through the string and quote necessary characters *\/\n\tfor(p = in_str, q = out_str; p != in_str_end; p++) {\n\t\tc = *p;\n\t\tswitch(c) {\n\t\t\tcase '.':\n\t\t\tcase '\\\\':\n\t\t\tcase '+':\n\t\t\tcase '*':\n\t\t\tcase '?':\n\t\t\tcase '[':\n\t\t\tcase '^':\n\t\t\tcase ']':\n\t\t\tcase '$':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '=':\n\t\t\tcase '!':\n\t\t\tcase '>':\n\t\t\tcase '<':\n\t\t\tcase '|':\n\t\t\tcase ':':\n\t\t\tcase '-':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = c;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\0':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '0';\n\t\t\t\t*q++ = '0';\n\t\t\t\t*q++ = '0';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (quote_delim && c == delim_char)\n\t\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\t\n\t\/* Reallocate string and return it *\/\n\tRETVAL_STRINGL(erealloc(out_str, q - out_str + 1), q - out_str, 0);\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"clamp_lab_icc(const fz_colorspace *cs, const float *src, float *dst)\n{\n\tdst[0] = (fz_clamp(src[0], 0, 100)) \/ 100.0f;\n\tdst[1] = (fz_clamp(src[1], -128, 127) + 128.0f) \/ 256;\n\tdst[2] = (fz_clamp(src[2], -128, 127) + 128.0f) \/ 256;\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static void add_assoc_name_entry(zval * val, char * key, X509_NAME * name, int shortname TSRMLS_DC) \/* {{{ *\/\n{\n\tzval *subitem, *subentries;\n\tint i, j = -1, last = -1, obj_cnt = 0;\n\tchar *sname;\n\tint nid;\n\tX509_NAME_ENTRY * ne;\n\tASN1_STRING * str = NULL;\n\tASN1_OBJECT * obj;\n\n\tif (key != NULL) {\n\t\tMAKE_STD_ZVAL(subitem);\n\t\tarray_init(subitem);\n\t} else {\n\t\tsubitem = val;\n\t}\n\t\n\tfor (i = 0; i < X509_NAME_entry_count(name); i++) {\n\t\tunsigned char *to_add;\n\t\tint to_add_len;\n\n\n\t\tne  = X509_NAME_get_entry(name, i);\n\t\tobj = X509_NAME_ENTRY_get_object(ne);\n\t\tnid = OBJ_obj2nid(obj);\n\t\tobj_cnt = 0;\n\n\t\tif (shortname) {\n\t\t\tsname = (char *) OBJ_nid2sn(nid);\n\t\t} else {\n\t\t\tsname = (char *) OBJ_nid2ln(nid);\n\t\t}\n\n\t\tMAKE_STD_ZVAL(subentries);\n\t\tarray_init(subentries);\n\n\t\tlast = -1;\n\t\tfor (;;) {\n\t\t\tj = X509_NAME_get_index_by_OBJ(name, obj, last);\n\t\t\tif (j < 0) {\n\t\t\t\tif (last != -1) break;\n\t\t\t} else {\n\t\t\t\tobj_cnt++;\n\t\t\t\tne  = X509_NAME_get_entry(name, j);\n\t\t\t\tstr = X509_NAME_ENTRY_get_data(ne);\n\t\t\t\tif (ASN1_STRING_type(str) != V_ASN1_UTF8STRING) {\n\t\t\t\t\tto_add_len = ASN1_STRING_to_UTF8(&to_add, str);\n\t\t\t\t\tif (to_add_len != -1) {\n\t\t\t\t\t\tadd_next_index_stringl(subentries, (char *)to_add, to_add_len, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tto_add = ASN1_STRING_data(str);\n\t\t\t\t\tto_add_len = ASN1_STRING_length(str);\n\t\t\t\t\tadd_next_index_stringl(subentries, (char *)to_add, to_add_len, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = j;\n\t\t}\n\t\ti = last;\n\t\t\n\t\tif (obj_cnt > 1) {\n\t\t\tadd_assoc_zval_ex(subitem, sname, strlen(sname) + 1, subentries);\n\t\t} else {\n\t\t\tzval_dtor(subentries);\n\t\t\tFREE_ZVAL(subentries);\n\t\t\tif (obj_cnt && str && to_add_len > -1) {\n\t\t\t\tadd_assoc_stringl(subitem, sname, (char *)to_add, to_add_len, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (key != NULL) {\n\t\tzend_hash_update(HASH_OF(val), key, strlen(key) + 1, (void *)&subitem, sizeof(subitem), NULL);\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"static void add_error(Scanner *s, char *error)\n{\n\ts->errors->error_count++;\n\ts->errors->error_messages = realloc(s->errors->error_messages, s->errors->error_count * sizeof(timelib_error_message));\n\ts->errors->error_messages[s->errors->error_count - 1].position = s->tok ? s->tok - s->str : 0;\n\ts->errors->error_messages[s->errors->error_count - 1].character = s->tok ? *s->tok : 0;\n\ts->errors->error_messages[s->errors->error_count - 1].message = strdup(error);\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::ParseSimpleBlock(\n    long long block_size,\n    long long& pos,\n    long& len)\n{\n    const long long block_start = pos;\n    const long long block_stop = pos + block_size;\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long total, avail;\n    long status = pReader->Length(&total, &avail);\n    if (status < 0)  \/\/error\n        return status;\n    assert((total < 0) || (avail <= total));\n    if ((pos + 1) > avail)\n    {\n        len = 1;\n        return E_BUFFER_NOT_FULL;\n     }\n \n     long long result = GetUIntLength(pReader, pos, len);\n \n    if (result < 0)  \/\/error\n        return static_cast<long>(result);\n \n    if (result > 0)  \/\/weird\n        return E_BUFFER_NOT_FULL;\n \n    if ((pos + len) > block_stop)\n        return E_FILE_FORMAT_INVALID;\n \n     if ((pos + len) > avail)\n         return E_BUFFER_NOT_FULL;\n \n    const long long track = ReadUInt(pReader, pos, len);\n \n    if (track < 0) \/\/error\n        return static_cast<long>(track);\n \n    if (track == 0)\n        return E_FILE_FORMAT_INVALID;\n \n #if 0\n\n const Tracks* const pTracks = m_pSegment->GetTracks();\n    assert(pTracks);\n\n const long tn = static_cast<long>(track);\n\n const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n\n if (pTrack == NULL)\n\n         return E_FILE_FORMAT_INVALID;\n #endif\n \n    pos += len;  \/\/consume track number\n \n    if ((pos + 2) > block_stop)\n        return E_FILE_FORMAT_INVALID;\n \n    if ((pos + 2) > avail)\n    {\n        len = 2;\n        return E_BUFFER_NOT_FULL;\n    }\n \n    pos += 2;  \/\/consume timecode\n \n    if ((pos + 1) > block_stop)\n        return E_FILE_FORMAT_INVALID;\n \n    if ((pos + 1) > avail)\n    {\n        len = 1;\n        return E_BUFFER_NOT_FULL;\n    }\n \n    unsigned char flags;\n \n    status = pReader->Read(pos, 1, &flags);\n \n    if (status < 0)  \/\/error or underflow\n    {\n        len = 1;\n        return status;\n    }\n \n    ++pos;  \/\/consume flags byte\n    assert(pos <= avail);\n \n    if (pos >= block_stop)\n        return E_FILE_FORMAT_INVALID;\n \n    const int lacing = int(flags & 0x06) >> 1;\n \n    if ((lacing != 0) && (block_stop > avail))\n    {\n        len = static_cast<long>(block_stop - pos);\n        return E_BUFFER_NOT_FULL;\n    }\n \n    status = CreateBlock(0x23,  \/\/simple block id\n                         block_start, block_size,\n                         0);  \/\/DiscardPadding\n \n    if (status != 0)\n        return status;\n \n    m_pos = block_stop;\n \n    return 0;  \/\/success\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)\n{\n    assert(pCluster);\n    assert(pCluster->m_index < 0);\n    assert(idx >= m_clusterCount);\n    const long count = m_clusterCount + m_clusterPreloadCount;\n    long& size = m_clusterSize;\n    assert(size >= count);\n    if (count >= size)\n    {\n        const long n = (size <= 0) ? 2048 : 2*size;\n        Cluster** const qq = new Cluster*[n];\n        Cluster** q = qq;\n        Cluster** p = m_clusters;\n        Cluster** const pp = p + count;\n        while (p != pp)\n            *q++ = *p++;\n        delete[] m_clusters;\n        m_clusters = qq;\n        size = n;\n    }\n     assert(m_clusters);\n \n    Cluster** const p = m_clusters + idx;\n \n    Cluster** q = m_clusters + count;\n    assert(q >= p);\n     assert(q < (m_clusters + size));\n \n    while (q > p)\n    {\n        Cluster** const qq = q - 1;\n        assert((*qq)->m_index < 0);\n \n        *q = *qq;\n        q = qq;\n     }\n \n    m_clusters[idx] = pCluster;\n    ++m_clusterPreloadCount;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_new_colorspace(fz_context *ctx,\n\t\tconst char *name,\n\t\tenum fz_colorspace_type type, int flags, int n,\n\t\tfz_colorspace_convert_fn *to_ccs,\n\t\tfz_colorspace_convert_fn *from_ccs,\n\t\tfz_colorspace_base_fn *base,\n\t\tfz_colorspace_clamp_fn *clamp,\n\t\tfz_colorspace_destruct_fn *destruct,\n\t\tvoid *data, size_t size)\n{\n\tfz_colorspace *cs = fz_malloc_struct(ctx, fz_colorspace);\n\tFZ_INIT_KEY_STORABLE(cs, 1, fz_drop_colorspace_imp);\n\tcs->size = sizeof(fz_colorspace) + size;\n\tfz_strlcpy(cs->name, name ? name : \"UNKNOWN\", sizeof cs->name);\n\tcs->type = type;\n\tcs->flags = flags;\n\tcs->n = n;\n\tcs->to_ccs = to_ccs;\n\tcs->from_ccs = from_ccs;\n\tcs->get_base = base;\n\n\tif (clamp != NULL)\n\t\tcs->clamp = clamp;\n\telse\n\t\tcs->clamp = clamp_default;\n\n\tcs->free_data = destruct;\n\tcs->data = data;\n\treturn cs;\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_decrypt)\n{\n\tzend_bool raw_input = 0;\n\tchar *data, *method, *password, *iv = \"\";\n\tint data_len, method_len, password_len, iv_len = 0;\n\tconst EVP_CIPHER *cipher_type;\n\tEVP_CIPHER_CTX cipher_ctx;\n\tint i, outlen, keylen;\n\tunsigned char *outbuf, *key;\n\tint base64_str_len;\n\tchar *base64_str = NULL;\n\tzend_bool free_iv;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sss|bs\", &data, &data_len, &method, &method_len, &password, &password_len, &raw_input, &iv, &iv_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!method_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcipher_type = EVP_get_cipherbyname(method);\n\tif (!cipher_type) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!raw_input) {\n\t\tbase64_str = (char*)php_base64_decode((unsigned char*)data, data_len, &base64_str_len);\n\t\tif (!base64_str) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to base64 decode the input\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tdata_len = base64_str_len;\n\t\tdata = base64_str;\n\t}\n\n\tkeylen = EVP_CIPHER_key_length(cipher_type);\n\tif (keylen > password_len) {\n\t\tkey = emalloc(keylen);\n\t\tmemset(key, 0, keylen);\n\t\tmemcpy(key, password, password_len);\n\t} else {\n\t\tkey = (unsigned char*)password;\n\t}\n\n\tfree_iv = php_openssl_validate_iv(&iv, &iv_len, EVP_CIPHER_iv_length(cipher_type) TSRMLS_CC);\n\n\toutlen = data_len + EVP_CIPHER_block_size(cipher_type);\n\toutbuf = emalloc(outlen + 1);\n\n\tEVP_DecryptInit(&cipher_ctx, cipher_type, NULL, NULL);\n\tif (password_len > keylen) {\n\t\tEVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len);\n\t}\n\tEVP_DecryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);\n\tEVP_DecryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);\n\toutlen = i;\n\tif (EVP_DecryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {\n\t\toutlen += i;\n\t\toutbuf[outlen] = '\\0';\n\t\tRETVAL_STRINGL((char *)outbuf, outlen, 0);\n\t} else {\n\t\tefree(outbuf);\n\t\tRETVAL_FALSE;\n\t}\n\tif (key != (unsigned char*)password) {\n\t\tefree(key);\n\t}\n\tif (free_iv) {\n\t\tefree(iv);\n\t}\n\tif (base64_str) {\n\t\tefree(base64_str);\n\t}\n \tEVP_CIPHER_CTX_cleanup(&cipher_ctx);\n}\n","project":"php","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_copy_on_write(phar_archive_data **pphar TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_archive_data **newpphar, *newphar = NULL;\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), (*pphar)->fname, (*pphar)->fname_len, (void *)&newphar, sizeof(phar_archive_data *), (void **)&newpphar)) {\n\t\treturn FAILURE;\n\t}\n\n\t*newpphar = *pphar;\n\tphar_copy_cached_phar(newpphar TSRMLS_CC);\n\t\/* invalidate phar cache *\/\n\tPHAR_G(last_phar) = NULL;\n\tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;\n\n\tif (newpphar[0]->alias_len && FAILURE == zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), newpphar[0]->alias, newpphar[0]->alias_len, (void*)newpphar, sizeof(phar_archive_data*), NULL)) {\n\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), (*pphar)->fname, (*pphar)->fname_len);\n\t\treturn FAILURE;\n\t}\n\n\t*pphar = *newpphar;\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void TearDown() {\n    vp9_worker_end(&worker_);\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Cluster::GetPosition() const\n{\n    const long long pos = m_element_start - m_pSegment->m_start;\n    assert(pos >= 0);\n \n    return pos;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void TearDown() {\n     vpx_free(src_);\n     delete[] ref_;\n    vpx_free(sec_);\n     libvpx_test::ClearSystemState();\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Block::Frame& Block::GetFrame(int idx) const\n{\n    assert(idx >= 0);\n    assert(idx < m_frame_count);\n    const Frame& f = m_frames[idx];\n    assert(f.pos > 0);\n    assert(f.len > 0);\n    return f;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Chapters::Edition::Clear()\n{\n    while (m_atoms_count > 0)\n    {\n        Atom& a = m_atoms[--m_atoms_count];\n        a.Clear();\n     }\n \n    delete[] m_atoms;\n    m_atoms = NULL;\n \n    m_atoms_size = 0;\n }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"PHP_PHAR_API int phar_resolve_alias(char *alias, int alias_len, char **filename, int *filename_len TSRMLS_DC) \/* {{{ *\/ {\n\tphar_archive_data **fd_ptr;\n\tif (PHAR_GLOBALS->phar_alias_map.arBuckets\n\t\t\t&& SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void**)&fd_ptr)) {\n\t\t*filename = (*fd_ptr)->fname;\n\t\t*filename_len = (*fd_ptr)->fname_len;\n\t\treturn SUCCESS;\n\t}\n\treturn FAILURE;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":" ContentEncoding::ContentCompression::ContentCompression()\n    : algo(0),\n      settings(NULL),\n      settings_len(0) {\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"double VideoTrack::GetFrameRate() const\n{\n    return m_rate;\n}\n","project":"Android","target":1},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_do_port (int csock, int *local_sock)\n{\n  if (!opt.server_response)\n    logputs (LOG_VERBOSE, \"==> PORT ... \");\n  return ftp_port (csock, local_sock);\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"int main(int argc, char *argv[]) {\n char *fin, *fout;\n FILE *fpin, *fpout;\n uint8_t *inbuf, *outbuf;\n uint8_t *inbuf_u, *outbuf_u;\n uint8_t *inbuf_v, *outbuf_v;\n\n   int f, frames;\n   int width, height, target_width, target_height;\n \n   if (argc < 5) {\n     printf(\"Incorrect parameters:\\n\");\n    usage(argv[0]);\n     return 1;\n   }\n \n  fin = argv[1];\n\n   fout = argv[4];\n   if (!parse_dim(argv[2], &width, &height)) {\n     printf(\"Incorrect parameters: %s\\n\", argv[2]);\n    usage(argv[0]);\n     return 1;\n   }\n   if (!parse_dim(argv[3], &target_width, &target_height)) {\n     printf(\"Incorrect parameters: %s\\n\", argv[3]);\n    usage(argv[0]);\n     return 1;\n   }\n \n   fpin = fopen(fin, \"rb\");\n   if (fpin == NULL) {\n     printf(\"Can't open file %s to read\\n\", fin);\n    usage(argv[0]);\n     return 1;\n   }\n   fpout = fopen(fout, \"wb\");\n   if (fpout == NULL) {\n     printf(\"Can't open file %s to write\\n\", fout);\n    usage(argv[0]);\n     return 1;\n   }\n   if (argc >= 6)\n    frames = atoi(argv[5]);\n else\n    frames = INT_MAX;\n\n  printf(\"Input size:  %dx%d\\n\",\n         width, height);\n  printf(\"Target size: %dx%d, Frames: \",\n         target_width, target_height);\n if (frames == INT_MAX)\n    printf(\"All\\n\");\n else\n    printf(\"%d\\n\", frames);\n\n  inbuf = (uint8_t*)malloc(width * height * 3 \/ 2);\n  outbuf = (uint8_t*)malloc(target_width * target_height * 3 \/ 2);\n  inbuf_u = inbuf + width * height;\n  inbuf_v = inbuf_u + width * height \/ 4;\n  outbuf_u = outbuf + target_width * target_height;\n  outbuf_v = outbuf_u + target_width * target_height \/ 4;\n  f = 0;\n while (f < frames) {\n if (fread(inbuf, width * height * 3 \/ 2, 1, fpin) != 1)\n break;\n    vp9_resize_frame420(inbuf, width, inbuf_u, inbuf_v, width \/ 2,\n                        height, width,\n                        outbuf, target_width, outbuf_u, outbuf_v,\n                        target_width \/ 2,\n                        target_height, target_width);\n    fwrite(outbuf, target_width * target_height * 3 \/ 2, 1, fpout);\n    f++;\n }\n  printf(\"%d frames processed\\n\", f);\n  fclose(fpin);\n  fclose(fpout);\n\n  free(inbuf);\n  free(outbuf);\n return 0;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long BlockGroup::Parse()\n{\n    const long status = m_block.Parse(m_pCluster);\n    if (status)\n        return status;\n    m_block.SetKey((m_prev > 0) && (m_next <= 0));\n    return 0;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Block::~Block()\n{\n    delete[] m_frames;\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_BDC(fz_context *ctx, pdf_processor *proc, const char *tag, pdf_obj *raw, pdf_obj *cooked)\n{\n}\n","project":"ghostscript","target":0},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"print_length (wgint size, wgint start, bool authoritative)\n{\n  logprintf (LOG_VERBOSE, _(\"Length: %s\"), number_to_static_string (size));\n  if (size >= 1024)\n    logprintf (LOG_VERBOSE, \" (%s)\", human_readable (size, 10, 1));\n  if (start > 0)\n    {\n      if (size - start >= 1024)\n        logprintf (LOG_VERBOSE, _(\", %s (%s) remaining\"),\n                   number_to_static_string (size - start),\n                   human_readable (size - start, 10, 1));\n      else\n        logprintf (LOG_VERBOSE, _(\", %s remaining\"),\n                   number_to_static_string (size - start));\n    }\n  logputs (LOG_VERBOSE, !authoritative ? _(\" (unauthoritative)\\n\") : \"\\n\");\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    int status;\n \n \n    len = 1;\n \n    unsigned char b;\n \n     status = pReader->Read(pos, 1, &b);\n \n    if (status < 0)  \/\/error or underflow\n        return status;\n    if (status > 0)  \/\/interpreted as \"underflow\"\n        return E_BUFFER_NOT_FULL;\n    if (b == 0)  \/\/we can't handle u-int values larger than 8 bytes\n        return E_FILE_FORMAT_INVALID;\n    unsigned char m = 0x80;\n    while (!(b & m))\n    {\n        m >>= 1;\n        ++len;\n     }\n \n \n    long long result = b & (~m);\n     ++pos;\n \n    for (int i = 1; i < len; ++i)\n    {\n        status = pReader->Read(pos, 1, &b);\n        if (status < 0)\n        {\n            len = 1;\n            return status;\n        }\n        if (status > 0)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result <<= 8;\n        result |= b;\n        ++pos;\n    }\n    return result;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_n(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs ? cs->n : 0;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_md5_icc(fz_context *ctx, fz_iccprofile *profile)\n{\n\tif (profile)\n\t\tfz_md5_buffer(ctx, profile->buffer, profile->md5);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_fin_cached_color_converter(fz_context *ctx, fz_color_converter *cc_)\n{\n\tfz_cached_color_converter *cc;\n\tif (cc_ == NULL)\n\t\treturn;\n\tcc = cc_->opaque;\n\tif (cc == NULL)\n\t\treturn;\n\tcc_->opaque = NULL;\n\tfz_drop_hash_table(ctx, cc->hash);\n\tfz_drop_color_converter(ctx, &cc->base);\n\tfz_free(ctx, cc);\n}\n","project":"ghostscript","target":0},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"OMXNodeInstance::OMXNodeInstance(\n        OMX *owner, const sp<IOMXObserver> &observer, const char *name)\n : mOwner(owner),\n      mNodeID(0),\n\n       mHandle(NULL),\n       mObserver(observer),\n       mDying(false),\n       mBufferIDCount(0)\n {\n     mName = ADebug::GetDebugName(name);\n    DEBUG = ADebug::GetDebugLevelFromProperty(name, \"debug.stagefright.omx-debug\");\n    ALOGV(\"debug level for %s is %d\", name, DEBUG);\n    DEBUG_BUMP = DEBUG;\n    mNumPortBuffers[0] = 0;\n    mNumPortBuffers[1] = 0;\n    mDebugLevelBumpPendingBuffers[0] = 0;\n    mDebugLevelBumpPendingBuffers[1] = 0;\n    mMetadataType[0] = kMetadataBufferTypeInvalid;\n    mMetadataType[1] = kMetadataBufferTypeInvalid;\n    mSecureBufferType[0] = kSecureBufferTypeUnknown;\n    mSecureBufferType[1] = kSecureBufferTypeUnknown;\n    mIsSecure = AString(name).endsWith(\".secure\");\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Chapters::Edition::Init()\n{\n    m_atoms = NULL;\n    m_atoms_size = 0;\n    m_atoms_count = 0;\n }\n","project":"Android","target":1},{"commit_id":"190cef6eed37d0e73a73c1e205eb31d45ab60a3c","func":"gnutls_session_set_data (gnutls_session_t session,\n                         const void *session_data, size_t session_data_size)\n{\n  int ret;\n  gnutls_datum_t psession;\n\n  psession.data = (opaque *) session_data;\n  psession.size = session_data_size;\n\n  if (session_data == NULL || session_data_size == 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INVALID_REQUEST;\n    }\n  ret = _gnutls_session_unpack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n\n  return 0;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_get_icc_link(fz_context *ctx, const fz_colorspace *dst, int dst_extras, const fz_colorspace *src, int src_extras, const fz_colorspace *prf, const fz_color_params *rend, int num_bytes, int copy_spots, int *src_n)\n{\n\tfz_icclink *link = NULL;\n\tfz_iccprofile *src_icc = NULL;\n\tfz_iccprofile *dst_icc = dst->data;\n\tfz_iccprofile *prf_icc = NULL;\n\tfz_link_key *key = NULL;\n\tfz_icclink *new_link;\n\n\tassert(!copy_spots || src_extras == dst_extras);\n\n\tif (prf != NULL)\n\t\tprf_icc = prf->data;\n\n\tif (fz_colorspace_is_icc(ctx, src))\n\t\tsrc_icc = src->data;\n\telse if (fz_colorspace_is_cal(ctx, src))\n\t{\n\t\tfz_cal_colorspace *cal;\n\n\t\tcal = src->data;\n\t\tsrc_icc = cal->profile;\n\t\t\/* Check if we have any work to do. *\/\n\t\tif (src_icc == NULL)\n\t\t\tsrc_icc = fz_icc_from_cal(ctx, src);\n\t\tif (src_icc->cmm_handle == NULL)\n\t\t{\n\t\t\tfz_cmm_init_profile(ctx, src_icc);\n\n\t\t\t\/* The CMM failed to make a profile. Use the default. *\/\n\t\t\tif (src_icc->cmm_handle == NULL)\n\t\t\t{\n\t\t\t\tswitch (src->n)\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tsrc_icc = fz_device_gray(ctx)->data;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsrc_icc = fz_device_rgb(ctx)->data;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tsrc_icc = fz_device_cmyk(ctx)->data;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Poorly formed Cal color space\");\n\t\t\t\t}\n\t\t\t\t\/* To avoid repeated failures building the pdf-cal color space,\n\t\t\t\t * assign the default profile. *\/\n\t\t\t\tfz_cmm_fin_profile(ctx, src_icc);\n\t\t\t\tcal->profile = src_icc;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tsrc_icc = get_base_icc_profile(ctx, src);\n\n\tif (src_icc == NULL)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Profile missing during link creation\");\n\n\t*src_n = src_icc->num_devcomp;\n\n\tfz_var(link);\n\tfz_var(key);\n\n\tif (rend == NULL)\n\t\trend = fz_default_color_params(ctx);\n\n\tfz_try(ctx)\n\t{\n\t\t\/* Check the storable to see if we have a copy. *\/\n\t\tkey = fz_malloc_struct(ctx, fz_link_key);\n\t\tkey->refs = 1;\n\t\tmemcpy(&key->dst_md5, dst_icc->md5, 16);\n\t\tmemcpy(&key->src_md5, src_icc->md5, 16);\n\t\tkey->rend.ri = rend->ri;\n\t\tkey->rend.bp = rend->bp;\n\t\tkey->src_extras = src_extras;\n\t\tkey->dst_extras = dst_extras;\n\t\tkey->depth = num_bytes;\n\t\tkey->proof = (prf_icc != NULL);\n\t\tkey->copy_spots = copy_spots;\n\t\tlink = fz_find_item(ctx, fz_drop_link_imp, key, &fz_link_store_type);\n\n\t\t\/* Not found.  Make new one add to store. *\/\n\t\tif (link == NULL)\n\t\t{\n\t\t\tlink = fz_new_icc_link(ctx, dst_icc, dst_extras, src_icc, src_extras, prf_icc, rend, num_bytes, copy_spots);\n\t\t\tnew_link = fz_store_item(ctx, key, link, sizeof(fz_icclink), &fz_link_store_type);\n\t\t\tif (new_link != NULL)\n\t\t\t{\n\t\t\t\t\/* Found one while adding! Perhaps from another thread? *\/\n\t\t\t\tfz_drop_icclink(ctx, link);\n\t\t\t\tlink = new_link;\n\t\t\t}\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_link_key(ctx, key);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\t\/* Ignore any error that came just from the enstoring. *\/\n\t\tif (link == NULL)\n\t\t\tfz_rethrow(ctx);\n\t}\n\treturn link;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long VideoTrack::GetWidth() const\n{\n    return m_width;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* Track::GetLanguage() const\n{\n    return m_info.language;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"g2rgb(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tdv[0] = sv[0];\n\tdv[1] = sv[0];\n\tdv[2] = sv[0];\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_digest)\n{\n\tzend_bool raw_output = 0;\n\tchar *data, *method;\n\tint data_len, method_len;\n\tconst EVP_MD *mdtype;\n\tEVP_MD_CTX md_ctx;\n\tint siglen;\n\tunsigned char *sigbuf;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\", &data, &data_len, &method, &method_len, &raw_output) == FAILURE) {\n\t\treturn;\n\t}\n\tmdtype = EVP_get_digestbyname(method);\n\tif (!mdtype) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tsiglen = EVP_MD_size(mdtype);\n\tsigbuf = emalloc(siglen + 1);\n\n\tEVP_DigestInit(&md_ctx, mdtype);\n\tEVP_DigestUpdate(&md_ctx, (unsigned char *)data, data_len);\n\tif (EVP_DigestFinal (&md_ctx, (unsigned char *)sigbuf, (unsigned int *)&siglen)) {\n\t\tif (raw_output) {\n\t\t\tsigbuf[siglen] = '\\0';\n\t\t\tRETVAL_STRINGL((char *)sigbuf, siglen, 0);\n\t\t} else {\n\t\t\tint digest_str_len = siglen * 2;\n\t\t\tchar *digest_str = emalloc(digest_str_len + 1);\n\n\t\t\tmake_digest_ex(digest_str, sigbuf, siglen);\n\t\t\tefree(sigbuf);\n\t\t\tRETVAL_STRINGL(digest_str, digest_str_len, 0);\n\t\t}\n\t} else {\n\t\tefree(sigbuf);\n\t\tRETVAL_FALSE;\n\t}\n}\n","project":"php","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"status_t BnOMX::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case LIVES_LOCALLY:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n            node_id node = (node_id)data.readInt32();\n pid_t pid = (pid_t)data.readInt32();\n            reply->writeInt32(livesLocally(node, pid));\n\n return OK;\n }\n\n case LIST_NODES:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n List<ComponentInfo> list;\n            listNodes(&list);\n\n            reply->writeInt32(list.size());\n for (List<ComponentInfo>::iterator it = list.begin();\n                 it != list.end(); ++it) {\n ComponentInfo &cur = *it;\n\n                reply->writeString8(cur.mName);\n                reply->writeInt32(cur.mRoles.size());\n for (List<String8>::iterator role_it = cur.mRoles.begin();\n                     role_it != cur.mRoles.end(); ++role_it) {\n                    reply->writeString8(*role_it);\n }\n }\n\n return NO_ERROR;\n }\n\n case ALLOCATE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n const char *name = data.readCString();\n\n            sp<IOMXObserver> observer =\n                interface_cast<IOMXObserver>(data.readStrongBinder());\n\n            node_id node;\n\n status_t err = allocateNode(name, observer, &node);\n            reply->writeInt32(err);\n if (err == OK) {\n                reply->writeInt32((int32_t)node);\n }\n\n return NO_ERROR;\n }\n\n case FREE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            reply->writeInt32(freeNode(node));\n\n return NO_ERROR;\n }\n\n case SEND_COMMAND:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            OMX_COMMANDTYPE cmd =\n static_cast<OMX_COMMANDTYPE>(data.readInt32());\n\n            OMX_S32 param = data.readInt32();\n            reply->writeInt32(sendCommand(node, cmd, param));\n\n return NO_ERROR;\n }\n\n case GET_PARAMETER:\n case SET_PARAMETER:\n case GET_CONFIG:\n case SET_CONFIG:\n case SET_INTERNAL_OPTION:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());\n\n \n             size_t size = data.readInt64();\n \n            status_t err = NO_MEMORY;\n            void *params = calloc(size, 1);\n            if (params) {\n                err = data.read(params, size);\n                if (err != OK) {\n                    android_errorWriteLog(0x534e4554, \"26914474\");\n                 } else {\n                    switch (code) {\n                        case GET_PARAMETER:\n                            err = getParameter(node, index, params, size);\n                            break;\n                        case SET_PARAMETER:\n                            err = setParameter(node, index, params, size);\n                            break;\n                        case GET_CONFIG:\n                            err = getConfig(node, index, params, size);\n                            break;\n                        case SET_CONFIG:\n                            err = setConfig(node, index, params, size);\n                            break;\n                        case SET_INTERNAL_OPTION:\n                        {\n                            InternalOptionType type =\n                                (InternalOptionType)data.readInt32();\n \n                            err = setInternalOption(node, index, type, params, size);\n                            break;\n                         }\n                        default:\n                            TRESPASS();\n                     }\n                 }\n             }\n \n            reply->writeInt32(err);\n\n if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {\n\n                 reply->write(params, size);\n             }\n \n            free(params);\n             params = NULL;\n \n             return NO_ERROR;\n }\n\n case GET_STATE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_STATETYPE state = OMX_StateInvalid;\n\n status_t err = getState(node, &state);\n            reply->writeInt32(state);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case ENABLE_GRAPHIC_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n status_t err = enableGraphicBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case GET_GRAPHIC_BUFFER_USAGE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            OMX_U32 usage = 0;\n status_t err = getGraphicBufferUsage(node, port_index, &usage);\n            reply->writeInt32(err);\n            reply->writeInt32(usage);\n\n return NO_ERROR;\n }\n\n case USE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = useBuffer(node, port_index, params, &buffer, allottedSize);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case USE_GRAPHIC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n\n            buffer_id buffer;\n status_t err = useGraphicBuffer(\n                    node, port_index, graphicBuffer, &buffer);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case UPDATE_GRAPHIC_BUFFER_IN_META:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            buffer_id buffer = (buffer_id)data.readInt32();\n\n status_t err = updateGraphicBufferInMeta(\n                    node, port_index, graphicBuffer, buffer);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CREATE_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferProducer> bufferProducer;\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = createInputSurface(node, port_index, &bufferProducer, &type);\n\n if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {\n                android_errorWriteLog(0x534e4554, \"26324358\");\n }\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n }\n\n return NO_ERROR;\n }\n\n case CREATE_PERSISTENT_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            sp<IGraphicBufferProducer> bufferProducer;\n            sp<IGraphicBufferConsumer> bufferConsumer;\n status_t err = createPersistentInputSurface(\n &bufferProducer, &bufferConsumer);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n                reply->writeStrongBinder(IInterface::asBinder(bufferConsumer));\n }\n\n return NO_ERROR;\n }\n\n case SET_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferConsumer> bufferConsumer =\n                    interface_cast<IGraphicBufferConsumer>(data.readStrongBinder());\n\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = setInputSurface(node, port_index, bufferConsumer, &type);\n\n if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {\n                android_errorWriteLog(0x534e4554, \"26324358\");\n }\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n return NO_ERROR;\n }\n\n case SIGNAL_END_OF_INPUT_STREAM:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n status_t err = signalEndOfInputStream(node);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case STORE_META_DATA_IN_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = storeMetaDataInBuffers(node, port_index, enable, &type);\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case PREPARE_FOR_ADAPTIVE_PLAYBACK:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n            OMX_U32 max_width = data.readInt32();\n            OMX_U32 max_height = data.readInt32();\n\n status_t err = prepareForAdaptivePlayback(\n                    node, port_index, enable, max_width, max_height);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CONFIGURE_VIDEO_TUNNEL_MODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();\n            OMX_U32 audio_hw_sync = data.readInt32();\n\n native_handle_t *sideband_handle = NULL;\n status_t err = configureVideoTunnelMode(\n                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);\n            reply->writeInt32(err);\n if(err == OK){\n                reply->writeNativeHandle(sideband_handle);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n if (!isSecure(node) || port_index != 0 \/* kPortIndexInput *\/) {\n                ALOGE(\"b\/24310423\");\n                reply->writeInt32(INVALID_OPERATION);\n return NO_ERROR;\n }\n\n size_t size = data.readInt64();\n\n            buffer_id buffer;\n void *buffer_data;\n status_t err = allocateBuffer(\n                    node, port_index, size, &buffer, &buffer_data);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n                reply->writeInt64((uintptr_t)buffer_data);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER_WITH_BACKUP:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = allocateBufferWithBackup(\n                    node, port_index, params, &buffer, allottedSize);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case FREE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(freeBuffer(node, port_index, buffer));\n\n return NO_ERROR;\n }\n\n case FILL_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(fillBuffer(node, buffer, fenceFd));\n\n return NO_ERROR;\n }\n\n case EMPTY_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            OMX_U32 range_offset = data.readInt32();\n            OMX_U32 range_length = data.readInt32();\n            OMX_U32 flags = data.readInt32();\n            OMX_TICKS timestamp = data.readInt64();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(emptyBuffer(\n                    node, buffer, range_offset, range_length, flags, timestamp, fenceFd));\n\n return NO_ERROR;\n }\n\n case GET_EXTENSION_INDEX:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n const char *parameter_name = data.readCString();\n\n            OMX_INDEXTYPE index;\n status_t err = getExtensionIndex(node, parameter_name, &index);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32(index);\n }\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_lab_icc(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn fz_colorspace_is_lab(ctx, cs) && fz_colorspace_is_icc(ctx, cs);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"static void get_frame_stats(vpx_codec_ctx_t *ctx,\n                            const vpx_image_t *img,\n                            vpx_codec_pts_t pts,\n                            unsigned int duration,\n                            vpx_enc_frame_flags_t flags,\n                            unsigned int deadline,\n                            vpx_fixed_buf_t *stats) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,\n                                               deadline);\n if (res != VPX_CODEC_OK)\n\n     die_codec(ctx, \"Failed to get frame stats.\");\n \n   while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_STATS_PKT) {\n       const uint8_t *const pkt_buf = pkt->data.twopass_stats.buf;\n       const size_t pkt_size = pkt->data.twopass_stats.sz;\n      stats->buf = realloc(stats->buf, stats->sz + pkt_size);\n      memcpy((uint8_t *)stats->buf + stats->sz, pkt_buf, pkt_size);\n\n       stats->sz += pkt_size;\n     }\n   }\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Chapters::Display::Parse(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    const long long stop = pos + size;\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  \/\/ error\n            return status;\n        if (size == 0)  \/\/ weird\n            continue;\n        if (id == 0x05)  \/\/ ChapterString ID\n        {\n            status = UnserializeString(pReader, pos, size, m_string);\n            if (status)\n              return status;\n        }\n        else if (id == 0x037C)  \/\/ ChapterLanguage ID\n        {\n            status = UnserializeString(pReader, pos, size, m_language);\n            if (status)\n              return status;\n        }\n        else if (id == 0x037E)  \/\/ ChapterCountry ID\n        {\n            status = UnserializeString(pReader, pos, size, m_country);\n            if (status)\n              return status;\n        }\n        pos += size;\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    return 0;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":" ContentEncoding::ContentEncryption::~ContentEncryption() {\n  delete [] key_id;\n  delete [] signature;\n  delete [] sig_key_id;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Chapters::Atom::GetStartTime(const Chapters* pChapters) const\n{\n    return GetTime(pChapters, m_start_timecode);\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long BlockGroup::GetNextTimeCode() const\n{\n    return m_next;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_cipher_iv_length)\n{\n\tchar *method;\n\tint method_len;\n\tconst EVP_CIPHER *cipher_type;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &method, &method_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!method_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcipher_type = EVP_get_cipherbyname(method);\n\tif (!cipher_type) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(EVP_CIPHER_iv_length(cipher_type));\n}\n","project":"php","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_cmap_wmode(fz_context *ctx, pdf_cmap *cmap)\n{\n\treturn cmap->wmode;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_cmm_avoid_white_fix_flag(fz_context *ctx)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\treturn ctx->colorspace->cmm->avoid_white_fix_flag;\n\treturn 0;\n}\n","project":"ghostscript","target":0},{"commit_id":"58a6822d7140137ce957c6d2fc20bae1374186c1","func":"IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice(dec_state_t *ps_dec)\n{\n    WORD16 *pi2_vld_out;\n    UWORD32 i;\n yuv_buf_t *ps_cur_frm_buf      = &ps_dec->s_cur_frm_buf;\n\n    UWORD32 u4_frm_offset          = 0;\n const dec_mb_params_t *ps_dec_mb_params;\n    IMPEG2D_ERROR_CODES_T e_error   = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n\n    pi2_vld_out = ps_dec->ai2_vld_buf;\n    memset(ps_dec->ai2_pred_mv,0,sizeof(ps_dec->ai2_pred_mv));\n\n    ps_dec->u2_prev_intra_mb    = 0;\n    ps_dec->u2_first_mb       = 1;\n\n    ps_dec->u2_picture_width = ps_dec->u2_frame_width;\n\n if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n {\n        ps_dec->u2_picture_width <<= 1;\n if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n {\n            u4_frm_offset = ps_dec->u2_frame_width;\n }\n }\n\n\n     do\n     {\n         UWORD32 u4_x_offset, u4_y_offset;\n \n \n         UWORD32 u4_x_dst_offset = 0;\n        UWORD32 u4_y_dst_offset = 0;\n        UWORD8  *pu1_out_p;\n        UWORD8  *pu1_pred;\n        WORD32 u4_pred_strd;\n\n        IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);\n\n \n \n         if(ps_dec->e_pic_type == B_PIC)\n            impeg2d_dec_pnb_mb_params(ps_dec);\n         else\n            impeg2d_dec_p_mb_params(ps_dec);\n \n         IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);\n \n         u4_x_dst_offset = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        u4_y_dst_offset = (ps_dec->u2_mb_y << 4) * ps_dec->u2_picture_width;\n        pu1_out_p = ps_cur_frm_buf->pu1_y + u4_x_dst_offset + u4_y_dst_offset;\n if(ps_dec->u2_prev_intra_mb == 0)\n {\n            UWORD32 offset_x, offset_y, stride;\n            UWORD16 index = (ps_dec->u2_motion_type);\n \/*only for non intra mb's*\/\n if(ps_dec->e_mb_pred == BIDIRECT)\n {\n                ps_dec_mb_params = &ps_dec->ps_func_bi_direct[index];\n }\n else\n {\n                ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];\n }\n\n            stride = ps_dec->u2_picture_width;\n\n            offset_x = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n\n            offset_y = (ps_dec->u2_mb_y << 4);\n\n            ps_dec->s_dest_buf.pu1_y = ps_cur_frm_buf->pu1_y + offset_y * stride + offset_x;\n\n            stride = stride >> 1;\n\n            ps_dec->s_dest_buf.pu1_u = ps_cur_frm_buf->pu1_u + (offset_y >> 1) * stride\n + (offset_x >> 1);\n\n            ps_dec->s_dest_buf.pu1_v = ps_cur_frm_buf->pu1_v + (offset_y >> 1) * stride\n + (offset_x >> 1);\n\n            PROFILE_DISABLE_MC_IF0\n            ps_dec_mb_params->pf_mc(ps_dec);\n\n }\n for(i = 0; i < NUM_LUMA_BLKS; ++i)\n {\n if((ps_dec->u2_cbp & (1 << (BLOCKS_IN_MB - 1 - i))) != 0)\n {\n                e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                              ps_dec->u2_prev_intra_mb, Y_LUMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n                u4_x_offset = gai2_impeg2_blk_x_off[i];\n\n if(ps_dec->u2_field_dct == 0)\n                    u4_y_offset = gai2_impeg2_blk_y_off_frm[i] ;\n else\n                    u4_y_offset = gai2_impeg2_blk_y_off_fld[i] ;\n\n\n\n\n\n                IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n                PROFILE_DISABLE_IDCT_IF0\n {\n                    WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                        idx = 0;\n else\n                        idx = 1;\n\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                        pu1_pred = pu1_out_p + u4_y_offset * ps_dec->u2_picture_width + u4_x_offset;\n                        u4_pred_strd = ps_dec->u2_picture_width << ps_dec->u2_field_dct;\n }\n else\n {\n                        pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                        u4_pred_strd = 8;\n }\n\n                    ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                            ps_dec->ai2_idct_stg1,\n                                                            pu1_pred,\n                                                            pu1_out_p + u4_y_offset * ps_dec->u2_picture_width + u4_x_offset,\n 8,\n                                                            u4_pred_strd,\n                                                            ps_dec->u2_picture_width << ps_dec->u2_field_dct,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n }\n }\n\n }\n\n \/* For U and V blocks, divide the x and y offsets by 2. *\/\n        u4_x_dst_offset >>= 1;\n        u4_y_dst_offset >>= 2;\n\n\n \/* In case of chrominance blocks the DCT will be frame DCT *\/\n \/* i = 0, U component and i = 1 is V componet *\/\n if((ps_dec->u2_cbp & 0x02) != 0)\n {\n            pu1_out_p = ps_cur_frm_buf->pu1_u + u4_x_dst_offset + u4_y_dst_offset;\n            e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                          ps_dec->u2_prev_intra_mb, U_CHROMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n\n            IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n            PROFILE_DISABLE_IDCT_IF0\n {\n                WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                    idx = 0;\n else\n                    idx = 1;\n\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                    pu1_pred = pu1_out_p;\n                    u4_pred_strd = ps_dec->u2_picture_width >> 1;\n }\n else\n {\n                    pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                    u4_pred_strd = 8;\n }\n\n                ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                        ps_dec->ai2_idct_stg1,\n                                                        pu1_pred,\n                                                        pu1_out_p,\n 8,\n                                                        u4_pred_strd,\n                                                        ps_dec->u2_picture_width >> 1,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n\n }\n\n }\n\n\n if((ps_dec->u2_cbp & 0x01) != 0)\n {\n            pu1_out_p = ps_cur_frm_buf->pu1_v + u4_x_dst_offset + u4_y_dst_offset;\n            e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                          ps_dec->u2_prev_intra_mb, V_CHROMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n\n            IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n            PROFILE_DISABLE_IDCT_IF0\n {\n                WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                    idx = 0;\n else\n                    idx = 1;\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                    pu1_pred = pu1_out_p;\n                    u4_pred_strd = ps_dec->u2_picture_width >> 1;\n }\n else\n {\n                    pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                    u4_pred_strd = 8;\n }\n\n                ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                        ps_dec->ai2_idct_stg1,\n                                                        pu1_pred,\n                                                        pu1_out_p,\n 8,\n                                                        u4_pred_strd,\n                                                        ps_dec->u2_picture_width >> 1,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n\n }\n }\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_first_mb = 0;\n        ps_dec->u2_mb_x++;\n\n if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n {\n return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n }\n else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n }\n }\n while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n return e_error;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::GetLast(const BlockEntry*& pLast) const\n{\n    for (;;)\n    {\n        long long pos;\n        long len;\n        const long status = Parse(pos, len);\n        if (status < 0)  \/\/error\n        {\n            pLast = NULL;\n            return status;\n        }\n        if (status > 0)  \/\/no new block\n            break;\n    }\n    if (m_entries_count <= 0)\n    {\n        pLast = NULL;\n        return 0;\n    }\n    assert(m_entries);\n    const long idx = m_entries_count - 1;\n    pLast = m_entries[idx];\n    assert(pLast);\n     return 0;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void update_rate_histogram(struct rate_hist *hist,\n const vpx_codec_enc_cfg_t *cfg,\n const vpx_codec_cx_pkt_t *pkt) {\n int i;\n int64_t then = 0;\n int64_t avg_bitrate = 0;\n int64_t sum_sz = 0;\n const int64_t now = pkt->data.frame.pts * 1000 *\n (uint64_t)cfg->g_timebase.num \/\n (uint64_t)cfg->g_timebase.den;\n\n int idx = hist->frames++ % hist->samples;\n  hist->pts[idx] = now;\n  hist->sz[idx] = (int)pkt->data.frame.sz;\n\n\n   if (now < cfg->rc_buf_initial_sz)\n     return;\n \n   then = now;\n \n   \/* Sum the size over the past rc_buf_sz ms *\/\n for (i = hist->frames; i > 0 && hist->frames - i < hist->samples; i--) {\n const int i_idx = (i - 1) % hist->samples;\n\n    then = hist->pts[i_idx];\n if (now - then > cfg->rc_buf_sz)\n break;\n    sum_sz += hist->sz[i_idx];\n }\n\n if (now == then)\n return;\n\n  avg_bitrate = sum_sz * 8 * 1000 \/ (now - then);\n  idx = (int)(avg_bitrate * (RATE_BINS \/ 2) \/ (cfg->rc_target_bitrate * 1000));\n if (idx < 0)\n    idx = 0;\n if (idx > RATE_BINS - 1)\n    idx = RATE_BINS - 1;\n if (hist->bucket[idx].low > avg_bitrate)\n    hist->bucket[idx].low = (int)avg_bitrate;\n if (hist->bucket[idx].high < avg_bitrate)\n    hist->bucket[idx].high = (int)avg_bitrate;\n  hist->bucket[idx].count++;\n  hist->total++;\n}\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n\n         OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, kPortIndexInput);\n     if (header == NULL) {\n         ALOGE(\"b\/25884056\");\n return BAD_VALUE;\n }\n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    sp<ABuffer> backup = buffer_meta->getBuffer(header, true \/* backup *\/, false \/* limit *\/);\n    sp<ABuffer> codec = buffer_meta->getBuffer(header, false \/* backup *\/, false \/* limit *\/);\n\n if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource\n && backup->capacity() >= sizeof(VideoNativeMetadata)\n && codec->capacity() >= sizeof(VideoGrallocMetadata)\n && ((VideoNativeMetadata *)backup->base())->eType\n == kMetadataBufferTypeANWBuffer) {\n VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();\n VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();\n        CLOG_BUFFER(emptyBuffer, \"converting ANWB %p to handle %p\",\n                backupMeta.pBuffer, backupMeta.pBuffer->handle);\n        codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;\n        codecMeta.eType = kMetadataBufferTypeGrallocSource;\n        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;\n        header->nOffset = 0;\n } else {\n if (rangeOffset > header->nAllocLen\n || rangeLength > header->nAllocLen - rangeOffset) {\n            CLOG_ERROR(emptyBuffer, OMX_ErrorBadParameter, FULL_BUFFER(NULL, header, fenceFd));\n if (fenceFd >= 0) {\n ::close(fenceFd);\n }\n return BAD_VALUE;\n }\n        header->nFilledLen = rangeLength;\n        header->nOffset = rangeOffset;\n\n        buffer_meta->CopyToOMX(header);\n }\n\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer, fenceFd);\n}\n","project":"Android","target":1},{"commit_id":"e629194c62a9a129ce378e08cb1059a8a53f1795","func":"WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(prev_slice_err == 1)\n {\n \/* first slice - missing\/header corruption *\/\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n\n                    if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                        j = i;\n             {\n                 ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                         ps_dec->ps_cur_slice->u2_frame_num,\n                         &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n \/* If error code is non-zero then there is no buffer available for display,\n                 hence avoid format conversion *\/\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n \/******************************************************\/\n \/* Initializations to new slice                       *\/\n \/******************************************************\/\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MAX_FRAMES;\n if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n (0 == ps_dec->i4_display_delay))\n {\n            num_entries = 1;\n }\n        num_entries = ((2 * num_entries) + 1);\n if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)\n {\n            num_entries *= 2;\n }\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n\n     }\n \n     ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n     if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n         ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n \n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n \/******************************************************\/\n \/* Initializations specific to P slice                *\/\n \/******************************************************\/\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n \/******************************************************\/\n \/* Parsing \/ decoding the slice                       *\/\n \/******************************************************\/\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n \/* Storing Default partition info *\/\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n \/**************************************************************\/\n \/* Get the required information for decoding of MB            *\/\n \/**************************************************************\/\n \/* mb_x, mb_y, neighbor availablity, *\/\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n \/* Set the deblocking parameters for this MB *\/\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n \/* Set appropriate flags in ps_cur_mb_info and ps_dec *\/\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n \/* Storing Skip partition info *\/\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n \/* Update Nnzs *\/\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n \/**************************************************************\/\n \/* Get next Macroblock address                                *\/\n \/**************************************************************\/\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n \/****************************************************************\/\n \/* Check for End Of Row and other flags that determine when to  *\/\n \/* do DMA setup for N\/2-Mb, Decode for N-Mb, and Transfer for   *\/\n \/* N-Mb                                                         *\/\n \/****************************************************************\/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n \/* incremented here only if first slice is inserted *\/\n if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAVC::internalGetParameter(OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamVideoBitrate:\n {\n\n             OMX_VIDEO_PARAM_BITRATETYPE *bitRate =\n                 (OMX_VIDEO_PARAM_BITRATETYPE *)params;\n \n             if (bitRate->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            bitRate->eControlRate = OMX_Video_ControlRateVariable;\n            bitRate->nTargetBitrate = mBitrate;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoAvc:\n\n         {\n             OMX_VIDEO_PARAM_AVCTYPE *avcParams = (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n             if (avcParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            OMX_VIDEO_AVCLEVELTYPE omxLevel = OMX_VIDEO_AVCLevel41;\n if (OMX_ErrorNone\n != ConvertAvcSpecLevelToOmxAvcLevel(mAVCEncLevel, &omxLevel)) {\n return OMX_ErrorUndefined;\n }\n\n            avcParams->eProfile = OMX_VIDEO_AVCProfileBaseline;\n            avcParams->eLevel = omxLevel;\n            avcParams->nRefFrames = 1;\n            avcParams->bUseHadamard = OMX_TRUE;\n            avcParams->nAllowedPictureTypes = (OMX_VIDEO_PictureTypeI\n | OMX_VIDEO_PictureTypeP | OMX_VIDEO_PictureTypeB);\n            avcParams->nRefIdx10ActiveMinus1 = 0;\n            avcParams->nRefIdx11ActiveMinus1 = 0;\n            avcParams->bWeightedPPrediction = OMX_FALSE;\n            avcParams->bconstIpred = OMX_FALSE;\n            avcParams->bDirect8x8Inference = OMX_FALSE;\n            avcParams->bDirectSpatialTemporal = OMX_FALSE;\n            avcParams->nCabacInitIdc = 0;\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_make_hash_link_key(fz_context *ctx, fz_store_hash *hash, void *key_)\n{\n\tfz_link_key *key = (fz_link_key *)key_;\n\tmemcpy(hash->u.link.dst_md5, key->dst_md5, 16);\n\tmemcpy(hash->u.link.src_md5, key->src_md5, 16);\n\thash->u.link.ri = key->rend.ri;\n\thash->u.link.bp = key->rend.bp;\n\thash->u.link.src_extras = key->src_extras;\n\thash->u.link.dst_extras = key->dst_extras;\n\thash->u.link.bpp16 = key->depth == 2;\n\thash->u.link.proof = key->proof;\n\thash->u.link.copy_spots = key->copy_spots;\n\treturn 1;\n}\n","project":"ghostscript","target":0},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"has_insecure_name_p (const char *s)\n{\n  if (*s == '\/')\n    return true;\n\n  if (strstr (s, \"..\/\") != 0)\n    return true;\n\n  return false;\n}\n","project":"savannah","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static void php_x509_free(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tX509 *x509 = (X509 *)rsrc->ptr;\n\tX509_free(x509);\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long AudioTrack::GetChannels() const\n{\n    return m_channels;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_rendering_intent_name(int ri)\n{\n\tif (ri >= 0 && ri < nelem(fz_intent_names))\n\t\treturn (char*)fz_intent_names[ri];\n\treturn \"RelativeColorimetric\";\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long VideoTrack::Seek(\n    long long time_ns,\n    const BlockEntry*& pResult) const\n{\n    const long status = GetFirst(pResult);\n    if (status < 0)  \/\/buffer underflow, etc\n         return status;\n \n    assert(pResult);\n \n    if (pResult->EOS())\n        return 0;\n \n    const Cluster* pCluster = pResult->GetCluster();\n     assert(pCluster);\n     assert(pCluster->GetIndex() >= 0);\n \n    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n        return 0;\n \n    Cluster** const clusters = m_pSegment->m_clusters;\n    assert(clusters);\n \n    const long count = m_pSegment->GetCount();  \/\/loaded only, not pre-loaded\n    assert(count > 0);\n \n    Cluster** const i = clusters + pCluster->GetIndex();\n    assert(i);\n    assert(*i == pCluster);\n    assert(pCluster->GetTime() <= time_ns);\n \n    Cluster** const j = clusters + count;\n \n    Cluster** lo = i;\n    Cluster** hi = j;\n \n    while (lo < hi)\n    {\n \n        Cluster** const mid = lo + (hi - lo) \/ 2;\n        assert(mid < hi);\n        pCluster = *mid;\n        assert(pCluster);\n        assert(pCluster->GetIndex() >= 0);\n        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n        const long long t = pCluster->GetTime();\n        if (t <= time_ns)\n            lo = mid + 1;\n        else\n            hi = mid;\n        assert(lo <= hi);\n    }\n    assert(lo == hi);\n    assert(lo > i);\n    assert(lo <= j);\n     pCluster = *--lo;\n     assert(pCluster);\n     assert(pCluster->GetTime() <= time_ns);\n \n    pResult = pCluster->GetEntry(this, time_ns);\n    if ((pResult != 0) && !pResult->EOS())  \/\/found a keyframe\n        return 0;\n    while (lo != i)\n    {\n        pCluster = *--lo;\n        assert(pCluster);\n        assert(pCluster->GetTime() <= time_ns);\n #if 0\n\n         pResult = pCluster->GetMaxKey(this);\n #else\n        pResult = pCluster->GetEntry(this, time_ns);\n #endif\n \n        if ((pResult != 0) && !pResult->EOS())\n            return 0;\n     }\n \n \n    pResult = GetEOS();\n    return 0;\n }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_CS(fz_context *ctx, pdf_processor *proc, const char *name, fz_colorspace *colorspace)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpr->dev->flags &= ~FZ_DEVFLAG_STROKECOLOR_UNDEFINED;\n\tif (!strcmp(name, \"Pattern\"))\n\t\tpdf_set_pattern(ctx, pr, PDF_STROKE, NULL, NULL);\n\telse\n\t\tpdf_set_colorspace(ctx, pr, PDF_STROKE, colorspace);\n}\n","project":"ghostscript","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"SSL_CIPHER *ssl3_choose_cipher(SSL *s, STACK_OF(SSL_CIPHER) *clnt,\n\t     STACK_OF(SSL_CIPHER) *srvr)\n\t{\n\tSSL_CIPHER *c,*ret=NULL;\n\tSTACK_OF(SSL_CIPHER) *prio, *allow;\n\tint i,ii,ok;\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_EC)\n\tunsigned int j;\n\tint ec_ok, ec_nid;\n\tunsigned char ec_search1 = 0, ec_search2 = 0;\n#endif\n\tCERT *cert;\n\tunsigned long alg_k,alg_a,mask_k,mask_a,emask_k,emask_a;\n\n\t\/* Let's see which ciphers we can support *\/\n\tcert=s->cert;\n\n#if 0\n\t\/* Do not set the compare functions, because this may lead to a\n\t * reordering by \"id\". We want to keep the original ordering.\n\t * We may pay a price in performance during sk_SSL_CIPHER_find(),\n\t * but would have to pay with the price of sk_SSL_CIPHER_dup().\n\t *\/\n\tsk_SSL_CIPHER_set_cmp_func(srvr, ssl_cipher_ptr_id_cmp);\n\tsk_SSL_CIPHER_set_cmp_func(clnt, ssl_cipher_ptr_id_cmp);\n#endif\n\n#ifdef CIPHER_DEBUG\n\tprintf(\"Server has %d from %p:\\n\", sk_SSL_CIPHER_num(srvr), (void *)srvr);\n\tfor(i=0 ; i < sk_SSL_CIPHER_num(srvr) ; ++i)\n\t\t{\n\t\tc=sk_SSL_CIPHER_value(srvr,i);\n\t\tprintf(\"%p:%s\\n\",(void *)c,c->name);\n\t\t}\n\tprintf(\"Client sent %d from %p:\\n\", sk_SSL_CIPHER_num(clnt), (void *)clnt);\n\tfor(i=0 ; i < sk_SSL_CIPHER_num(clnt) ; ++i)\n\t    {\n\t    c=sk_SSL_CIPHER_value(clnt,i);\n\t    printf(\"%p:%s\\n\",(void *)c,c->name);\n\t    }\n#endif\n\n\tif (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE)\n\t\t{\n\t\tprio = srvr;\n\t\tallow = clnt;\n\t\t}\n\telse\n\t\t{\n\t\tprio = clnt;\n\t\tallow = srvr;\n\t\t}\n\n\tfor (i=0; i<sk_SSL_CIPHER_num(prio); i++)\n\t\t{\n\t\tc=sk_SSL_CIPHER_value(prio,i);\n\n\t\t\/* Skip TLS v1.2 only ciphersuites if lower than v1.2 *\/\n\t\tif ((c->algorithm_ssl & SSL_TLSV1_2) && \n\t\t\t(TLS1_get_version(s) < TLS1_2_VERSION))\n\t\t\tcontinue;\n\n\t\tssl_set_cert_masks(cert,c);\n\t\tmask_k = cert->mask_k;\n\t\tmask_a = cert->mask_a;\n\t\temask_k = cert->export_mask_k;\n\t\temask_a = cert->export_mask_a;\n#ifndef OPENSSL_NO_SRP\n\t\tmask_k=cert->mask_k | s->srp_ctx.srp_Mask;\n\t\temask_k=cert->export_mask_k | s->srp_ctx.srp_Mask;\n#endif\n\t\t\t\n#ifdef KSSL_DEBUG\n\/*\t\tprintf(\"ssl3_choose_cipher %d alg= %lx\\n\", i,c->algorithms);*\/\n#endif    \/* KSSL_DEBUG *\/\n\n\t\talg_k=c->algorithm_mkey;\n\t\talg_a=c->algorithm_auth;\n\n#ifndef OPENSSL_NO_KRB5\n\t\tif (alg_k & SSL_kKRB5)\n\t\t\t{\n\t\t\tif ( !kssl_keytab_is_available(s->kssl_ctx) )\n\t\t\t    continue;\n\t\t\t}\n#endif \/* OPENSSL_NO_KRB5 *\/\n#ifndef OPENSSL_NO_PSK\n\t\t\/* with PSK there must be server callback set *\/\n\t\tif ((alg_k & SSL_kPSK) && s->psk_server_callback == NULL)\n\t\t\tcontinue;\n#endif \/* OPENSSL_NO_PSK *\/\n\n\t\tif (SSL_C_IS_EXPORT(c))\n\t\t\t{\n\t\t\tok = (alg_k & emask_k) && (alg_a & emask_a);\n#ifdef CIPHER_DEBUG\n\t\t\tprintf(\"%d:[%08lX:%08lX:%08lX:%08lX]%p:%s (export)\\n\",ok,alg_k,alg_a,emask_k,emask_a,\n\t\t\t       (void *)c,c->name);\n#endif\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tok = (alg_k & mask_k) && (alg_a & mask_a);\n#ifdef CIPHER_DEBUG\n\t\t\tprintf(\"%d:[%08lX:%08lX:%08lX:%08lX]%p:%s\\n\",ok,alg_k,alg_a,mask_k,mask_a,(void *)c,\n\t\t\t       c->name);\n#endif\n\t\t\t}\n\n#ifndef OPENSSL_NO_TLSEXT\n#ifndef OPENSSL_NO_EC\n\t\tif (\n\t\t\t\/* if we are considering an ECC cipher suite that uses our certificate *\/\n\t\t\t(alg_a & SSL_aECDSA || alg_a & SSL_aECDH)\n\t\t\t\/* and we have an ECC certificate *\/\n\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509 != NULL)\n\t\t\t\/* and the client specified a Supported Point Formats extension *\/\n\t\t\t&& ((s->session->tlsext_ecpointformatlist_length > 0) && (s->session->tlsext_ecpointformatlist != NULL))\n\t\t\t\/* and our certificate's point is compressed *\/\n\t\t\t&& (\n\t\t\t\t(s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key->public_key != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key->public_key->data != NULL)\n\t\t\t\t&& (\n\t\t\t\t\t(*(s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key->public_key->data) == POINT_CONVERSION_COMPRESSED)\n\t\t\t\t\t|| (*(s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key->public_key->data) == POINT_CONVERSION_COMPRESSED + 1)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t)\n\t\t\t{\n\t\t\tec_ok = 0;\n\t\t\t\/* if our certificate's curve is over a field type that the client does not support\n\t\t\t * then do not allow this cipher suite to be negotiated *\/\n\t\t\tif (\n\t\t\t\t(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth != NULL)\n\t\t\t\t&& (EC_METHOD_get_field_type(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth) == NID_X9_62_prime_field)\n\t\t\t)\n\t\t\t\t{\n\t\t\t\tfor (j = 0; j < s->session->tlsext_ecpointformatlist_length; j++)\n\t\t\t\t\t{\n\t\t\t\t\tif (s->session->tlsext_ecpointformatlist[j] == TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_ok = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if (EC_METHOD_get_field_type(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth) == NID_X9_62_characteristic_two_field)\n\t\t\t\t{\n\t\t\t\tfor (j = 0; j < s->session->tlsext_ecpointformatlist_length; j++)\n\t\t\t\t\t{\n\t\t\t\t\tif (s->session->tlsext_ecpointformatlist[j] == TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_ok = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tok = ok && ec_ok;\n\t\t\t}\n\t\tif (\n\t\t\t\/* if we are considering an ECC cipher suite that uses our certificate *\/\n\t\t\t(alg_a & SSL_aECDSA || alg_a & SSL_aECDH)\n\t\t\t\/* and we have an ECC certificate *\/\n\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509 != NULL)\n\t\t\t\/* and the client specified an EllipticCurves extension *\/\n\t\t\t&& ((s->session->tlsext_ellipticcurvelist_length > 0) && (s->session->tlsext_ellipticcurvelist != NULL))\n\t\t)\n\t\t\t{\n\t\t\tec_ok = 0;\n\t\t\tif (\n\t\t\t\t(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group != NULL)\n\t\t\t)\n\t\t\t\t{\n\t\t\t\tec_nid = EC_GROUP_get_curve_name(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group);\n\t\t\t\tif ((ec_nid == 0)\n\t\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth != NULL)\n\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\tif (EC_METHOD_get_field_type(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth) == NID_X9_62_prime_field)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_search1 = 0xFF;\n\t\t\t\t\t\tec_search2 = 0x01;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (EC_METHOD_get_field_type(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth) == NID_X9_62_characteristic_two_field)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_search1 = 0xFF;\n\t\t\t\t\t\tec_search2 = 0x02;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tec_search1 = 0x00;\n\t\t\t\t\tec_search2 = tls1_ec_nid2curve_id(ec_nid);\n\t\t\t\t\t}\n\t\t\t\tif ((ec_search1 != 0) || (ec_search2 != 0))\n\t\t\t\t\t{\n\t\t\t\t\tfor (j = 0; j < s->session->tlsext_ellipticcurvelist_length \/ 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif ((s->session->tlsext_ellipticcurvelist[2*j] == ec_search1) && (s->session->tlsext_ellipticcurvelist[2*j+1] == ec_search2))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tec_ok = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tok = ok && ec_ok;\n\t\t\t}\n\t\tif (\n\t\t\t\/* if we are considering an ECC cipher suite that uses an ephemeral EC key *\/\n\t\t\t(alg_k & SSL_kEECDH)\n\t\t\t\/* and we have an ephemeral EC key *\/\n\t\t\t&& (s->cert->ecdh_tmp != NULL)\n\t\t\t\/* and the client specified an EllipticCurves extension *\/\n\t\t\t&& ((s->session->tlsext_ellipticcurvelist_length > 0) && (s->session->tlsext_ellipticcurvelist != NULL))\n\t\t)\n\t\t\t{\n\t\t\tec_ok = 0;\n\t\t\tif (s->cert->ecdh_tmp->group != NULL)\n\t\t\t\t{\n\t\t\t\tec_nid = EC_GROUP_get_curve_name(s->cert->ecdh_tmp->group);\n\t\t\t\tif ((ec_nid == 0)\n\t\t\t\t\t&& (s->cert->ecdh_tmp->group->meth != NULL)\n\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\tif (EC_METHOD_get_field_type(s->cert->ecdh_tmp->group->meth) == NID_X9_62_prime_field)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_search1 = 0xFF;\n\t\t\t\t\t\tec_search2 = 0x01;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (EC_METHOD_get_field_type(s->cert->ecdh_tmp->group->meth) == NID_X9_62_characteristic_two_field)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_search1 = 0xFF;\n\t\t\t\t\t\tec_search2 = 0x02;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tec_search1 = 0x00;\n\t\t\t\t\tec_search2 = tls1_ec_nid2curve_id(ec_nid);\n\t\t\t\t\t}\n\t\t\t\tif ((ec_search1 != 0) || (ec_search2 != 0))\n\t\t\t\t\t{\n\t\t\t\t\tfor (j = 0; j < s->session->tlsext_ellipticcurvelist_length \/ 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif ((s->session->tlsext_ellipticcurvelist[2*j] == ec_search1) && (s->session->tlsext_ellipticcurvelist[2*j+1] == ec_search2))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tec_ok = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tok = ok && ec_ok;\n\t\t\t}\n#endif \/* OPENSSL_NO_EC *\/\n#endif \/* OPENSSL_NO_TLSEXT *\/\n\n\t\tif (!ok) continue;\n\t\tii=sk_SSL_CIPHER_find(allow,c);\n\t\tif (ii >= 0)\n\t\t\t{\n#if !defined(OPENSSL_NO_EC) && !defined(OPENSSL_NO_TLSEXT)\n\t\t\tif ((alg_k & SSL_kEECDH) && (alg_a & SSL_aECDSA) && s->s3->is_probably_safari)\n\t\t\t\t{\n\t\t\t\tif (!ret) ret=sk_SSL_CIPHER_value(allow,ii);\n\t\t\t\tcontinue;\n\t\t\t\t}\n#endif\n\t\t\tret=sk_SSL_CIPHER_value(allow,ii);\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn(ret);\n\t}\n","project":"openssl","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 8;\n     fwd_txfm_ref = fht8x8_ref;\n   }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride);\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Segment::Load()\n{\n    assert(m_clusters == NULL);\n    assert(m_clusterSize == 0);\n    assert(m_clusterCount == 0);\n \n \n    const long long header_status = ParseHeaders();\n \n    if (header_status < 0)  \/\/error\n        return static_cast<long>(header_status);\n \n    if (header_status > 0)  \/\/underflow\n        return E_BUFFER_NOT_FULL;\n \n    assert(m_pInfo);\n    assert(m_pTracks);\n \n    for (;;)\n    {\n        const int status = LoadCluster();\n \n        if (status < 0)  \/\/error\n            return status;\n \n        if (status >= 1)  \/\/no more clusters\n            return 0;\n    }\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void usage_exit() {\n   fprintf(stderr, \"Usage: %s <codec> <width> <height> <infile> <outfile>\\n\",\n           exec_name);\n   exit(EXIT_FAILURE);\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Track::GetNumber() const\n{\n    return m_info.number;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Block::GetTime(const Cluster* pCluster) const\n{\n    assert(pCluster);\n \n    const long long tc = GetTimeCode(pCluster);\n \n    const Segment* const pSegment = pCluster->m_pSegment;\n    const SegmentInfo* const pInfo = pSegment->GetInfo();\n    assert(pInfo);\n \n    const long long scale = pInfo->GetTimeCodeScale();\n    assert(scale >= 1);\n \n    const long long ns = tc * scale;\n    return ns;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void SetConstantInput(int value) {\n     memset(input_, value, kInputBufferSize);\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long VideoTrack::GetHeight() const\n{\n    return m_height;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" void SubpelVarianceTest<SubpelVarianceFunctionType>::RefTest() {\n  for (int x = 0; x < 16; ++x) {\n    for (int y = 0; y < 16; ++y) {\n      for (int j = 0; j < block_size_; j++) {\n        src_[j] = rnd.Rand8();\n      }\n      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n        ref_[j] = rnd.Rand8();\n       }\n       unsigned int sse1, sse2;\n       unsigned int var1;\n      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,\n                                                   src_, width_, &sse1));\n      const unsigned int var2 = subpel_variance_ref(ref_, src_, log2width_,\n                                                    log2height_, x, y, &sse2);\n       EXPECT_EQ(sse1, sse2) << \"at position \" << x << \", \" << y;\n       EXPECT_EQ(var1, var2) << \"at position \" << x << \", \" << y;\n     }\n   }\n }\n","project":"Android","target":1},{"commit_id":"122feb9a0b04290f55183ff2f0384c6c53756bd8","func":"static jboolean enableNative(JNIEnv* env, jobject obj) {\n     ALOGV(\"%s:\",__FUNCTION__);\n \n     jboolean result = JNI_FALSE;\n     if (!sBluetoothInterface) return result;\n    int ret = sBluetoothInterface->enable();\n     result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;\n     return result;\n }\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"     BufferMeta(size_t size, OMX_U32 portIndex)\n         : mSize(size),\n          mIsBackup(false),\n          mPortIndex(portIndex) {\n     }\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftVPXEncoder::internalSetParameter(OMX_INDEXTYPE index,\n const OMX_PTR param) {\n\n     const int32_t indexFull = index;\n \n     switch (indexFull) {\n        case OMX_IndexParamVideoBitrate:\n            return internalSetBitrateParams(\n                (const OMX_VIDEO_PARAM_BITRATETYPE *)param);\n \n        case OMX_IndexParamVideoVp8:\n            return internalSetVp8Params(\n                (const OMX_VIDEO_PARAM_VP8TYPE *)param);\n \n        case OMX_IndexParamVideoAndroidVp8Encoder:\n            return internalSetAndroidVp8Params(\n                (const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *)param);\n \n         default:\n             return SoftVideoEncoderOMXComponent::internalSetParameter(index, param);\n }\n}\n","project":"Android","target":1},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_retrieve_list (struct url *u, struct fileinfo *f, ccon *con)\n{\n  static int depth = 0;\n  uerr_t err;\n  struct fileinfo *orig;\n  wgint local_size;\n  time_t tml;\n  bool dlthis; \/* Download this (file). *\/\n  const char *actual_target = NULL;\n  bool force_full_retrieve = false;\n\n  \/* Increase the depth.  *\/\n  ++depth;\n  if (opt.reclevel != INFINITE_RECURSION && depth > opt.reclevel)\n    {\n      DEBUGP ((_(\"Recursion depth %d exceeded max. depth %d.\\n\"),\n               depth, opt.reclevel));\n      --depth;\n      return RECLEVELEXC;\n    }\n\n  assert (f != NULL);\n  orig = f;\n\n  con->st &= ~ON_YOUR_OWN;\n  if (!(con->st & DONE_CWD))\n    con->cmd |= DO_CWD;\n  else\n    con->cmd &= ~DO_CWD;\n  con->cmd |= (DO_RETR | LEAVE_PENDING);\n\n  if (con->csock < 0)\n    con->cmd |= DO_LOGIN;\n  else\n    con->cmd &= ~DO_LOGIN;\n\n  err = RETROK;                 \/* in case it's not used *\/\n\n  while (f)\n    {\n      char *old_target, *ofile;\n\n      if (opt.quota && total_downloaded_bytes > opt.quota)\n        {\n          --depth;\n          return QUOTEXC;\n        }\n      old_target = con->target;\n\n      ofile = xstrdup (u->file);\n      url_set_file (u, f->name);\n\n      con->target = url_file_name (u, NULL);\n      err = RETROK;\n\n      dlthis = true;\n      if (opt.timestamping && f->type == FT_PLAINFILE)\n        {\n          struct_stat st;\n          \/* If conversion of HTML files retrieved via FTP is ever implemented,\n             we'll need to stat() <file>.orig here when -K has been specified.\n             I'm not implementing it now since files on an FTP server are much\n             more likely than files on an HTTP server to legitimately have a\n             .orig suffix. *\/\n          if (!stat (con->target, &st))\n            {\n              bool eq_size;\n              bool cor_val;\n              \/* Else, get it from the file.  *\/\n              local_size = st.st_size;\n              tml = st.st_mtime;\n#ifdef WINDOWS\n              \/* Modification time granularity is 2 seconds for Windows, so\n                 increase local time by 1 second for later comparison. *\/\n              tml++;\n#endif\n              \/* Compare file sizes only for servers that tell us correct\n                 values. Assume sizes being equal for servers that lie\n                 about file size.  *\/\n              cor_val = (con->rs == ST_UNIX || con->rs == ST_WINNT);\n              eq_size = cor_val ? (local_size == f->size) : true;\n              if (f->tstamp <= tml && eq_size)\n                {\n                  \/* Remote file is older, file sizes can be compared and\n                     are both equal. *\/\n                  logprintf (LOG_VERBOSE, _(\"\\\nRemote file no newer than local file %s -- not retrieving.\\n\"), quote (con->target));\n                  dlthis = false;\n                }\n              else if (f->tstamp > tml)\n                {\n                  \/* Remote file is newer *\/\n                  force_full_retrieve = true;\n                  logprintf (LOG_VERBOSE, _(\"\\\nRemote file is newer than local file %s -- retrieving.\\n\\n\"),\n                             quote (con->target));\n                }\n              else\n                {\n                  \/* Sizes do not match *\/\n                  logprintf (LOG_VERBOSE, _(\"\\\nThe sizes do not match (local %s) -- retrieving.\\n\\n\"),\n                             number_to_static_string (local_size));\n                }\n            }\n        }       \/* opt.timestamping && f->type == FT_PLAINFILE *\/\n      switch (f->type)\n        {\n        case FT_SYMLINK:\n          \/* If opt.retr_symlinks is defined, we treat symlinks as\n             if they were normal files.  There is currently no way\n             to distinguish whether they might be directories, and\n             follow them.  *\/\n          if (!opt.retr_symlinks)\n            {\n#ifdef HAVE_SYMLINK\n              if (!f->linkto)\n                logputs (LOG_NOTQUIET,\n                         _(\"Invalid name of the symlink, skipping.\\n\"));\n              else\n                {\n                  struct_stat st;\n                  \/* Check whether we already have the correct\n                     symbolic link.  *\/\n                  int rc = lstat (con->target, &st);\n                  if (rc == 0)\n                    {\n                      size_t len = strlen (f->linkto) + 1;\n                      if (S_ISLNK (st.st_mode))\n                        {\n                          char *link_target = (char *)alloca (len);\n                          size_t n = readlink (con->target, link_target, len);\n                          if ((n == len - 1)\n                              && (memcmp (link_target, f->linkto, n) == 0))\n                            {\n                              logprintf (LOG_VERBOSE, _(\"\\\nAlready have correct symlink %s -> %s\\n\\n\"),\n                                         quote (con->target),\n                                         quote (f->linkto));\n                              dlthis = false;\n                              break;\n                            }\n                        }\n                    }\n                  logprintf (LOG_VERBOSE, _(\"Creating symlink %s -> %s\\n\"),\n                             quote (con->target), quote (f->linkto));\n                  \/* Unlink before creating symlink!  *\/\n                  unlink (con->target);\n                  if (symlink (f->linkto, con->target) == -1)\n                    logprintf (LOG_NOTQUIET, \"symlink: %s\\n\", strerror (errno));\n                  logputs (LOG_VERBOSE, \"\\n\");\n                } \/* have f->linkto *\/\n#else  \/* not HAVE_SYMLINK *\/\n              logprintf (LOG_NOTQUIET,\n                         _(\"Symlinks not supported, skipping symlink %s.\\n\"),\n                         quote (con->target));\n#endif \/* not HAVE_SYMLINK *\/\n            }\n          else                \/* opt.retr_symlinks *\/\n            {\n              if (dlthis)\n                err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);\n            } \/* opt.retr_symlinks *\/\n          break;\n        case FT_DIRECTORY:\n          if (!opt.recursive)\n            logprintf (LOG_NOTQUIET, _(\"Skipping directory %s.\\n\"),\n                       quote (f->name));\n          break;\n        case FT_PLAINFILE:\n          \/* Call the retrieve loop.  *\/\n          if (dlthis)\n            err = ftp_loop_internal (u, f, con, NULL, force_full_retrieve);\n          break;\n        case FT_UNKNOWN:\n          logprintf (LOG_NOTQUIET, _(\"%s: unknown\/unsupported file type.\\n\"),\n                     quote (f->name));\n          break;\n        }       \/* switch *\/\n\n\n      \/* 2004-12-15 SMS.\n       * Set permissions _before_ setting the times, as setting the\n       * permissions changes the modified-time, at least on VMS.\n       * Also, use the opt.output_document name here, too, as\n       * appropriate.  (Do the test once, and save the result.)\n       *\/\n\n      set_local_file (&actual_target, con->target);\n\n      \/* If downloading a plain file, and the user requested it, then\n         set valid (non-zero) permissions. *\/\n      if (dlthis && (actual_target != NULL) &&\n       (f->type == FT_PLAINFILE) && opt.preserve_perm)\n        {\n          if (f->perms)\n            chmod (actual_target, f->perms);\n          else\n            DEBUGP ((\"Unrecognized permissions for %s.\\n\", actual_target));\n        }\n\n      \/* Set the time-stamp information to the local file.  Symlinks\n         are not to be stamped because it sets the stamp on the\n         original.  :( *\/\n      if (actual_target != NULL)\n        {\n          if (opt.useservertimestamps\n              && !(f->type == FT_SYMLINK && !opt.retr_symlinks)\n              && f->tstamp != -1\n              && dlthis\n              && file_exists_p (con->target))\n            {\n              touch (actual_target, f->tstamp);\n            }\n          else if (f->tstamp == -1)\n            logprintf (LOG_NOTQUIET, _(\"%s: corrupt time-stamp.\\n\"),\n                       actual_target);\n        }\n\n      xfree (con->target);\n      con->target = old_target;\n\n      url_set_file (u, ofile);\n      xfree (ofile);\n\n      \/* Break on fatals.  *\/\n      if (err == QUOTEXC || err == HOSTERR || err == FWRITEERR\n          || err == WARC_ERR || err == WARC_TMP_FOPENERR\n          || err == WARC_TMP_FWRITEERR)\n        break;\n      con->cmd &= ~ (DO_CWD | DO_LOGIN);\n      f = f->next;\n    }\n\n  \/* We do not want to call ftp_retrieve_dirs here *\/\n  if (opt.recursive &&\n      !(opt.reclevel != INFINITE_RECURSION && depth >= opt.reclevel))\n    err = ftp_retrieve_dirs (u, orig, con);\n  else if (opt.recursive)\n    DEBUGP ((_(\"Will not retrieve dirs since depth is %d (max %d).\\n\"),\n             depth, opt.reclevel));\n  --depth;\n  return err;\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void EncoderTest::MismatchHook(const vpx_image_t *img1,\n                               const vpx_image_t *img2) {\n   ASSERT_TRUE(0) << \"Encode\/Decode mismatch found\";\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long mkvparser::UnserializeUInt(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    if ((size <= 0) || (size > 8))\n        return E_FILE_FORMAT_INVALID;\n \n    long long result = 0;\n \n    for (long long i = 0; i < size; ++i)\n    {\n        unsigned char b;\n \n        const long status = pReader->Read(pos, 1, &b);\n \n        if (status < 0)\n            return status;\n \n        result <<= 8;\n        result |= b;\n \n        ++pos;\n     }\n \n    return result;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long BlockGroup::GetPrevTimeCode() const\n{\n    return m_prev;\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_dup (struct attr *new, struct attr *orig)\n{\n  *new = *orig;\n  if (orig->extra)\n    {\n      new->extra = bgp_attr_extra_new();\n      *new->extra = *orig->extra;\n    }\n}\n","project":"savannah","target":0},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"struct name_list *get_list(const struct stat *st, acl_t acl)\n{\n\tstruct name_list *first = NULL, *last = NULL;\n\tacl_entry_t ent;\n\tint ret = 0;\n\n\tif (acl != NULL)\n\t\tret = acl_get_entry(acl, ACL_FIRST_ENTRY, &ent);\n\tif (ret != 1)\n\t\treturn NULL;\n\twhile (ret > 0) {\n\t\tacl_tag_t e_type;\n\t\tconst id_t *id_p;\n\t\tconst char *name = \"\";\n\t\tint len;\n\n\t\tacl_get_tag_type(ent, &e_type);\n\t\tswitch(e_type) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tname = user_name(st->st_uid, opt_numeric);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tid_p = acl_get_qualifier(ent);\n\t\t\t\tif (id_p != NULL)\n\t\t\t\t\tname = user_name(*id_p, opt_numeric);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tname = group_name(st->st_gid, opt_numeric);\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tid_p = acl_get_qualifier(ent);\n\t\t\t\tif (id_p != NULL)\n\t\t\t\t\tname = group_name(*id_p, opt_numeric);\n\t\t\t\tbreak;\n\t\t}\n\t\tname = xquote(name, \"\\t\\n\\r\");\n\t\tlen = strlen(name);\n\t\tif (last == NULL) {\n\t\t\tfirst = last = (struct name_list *)\n\t\t\t\tmalloc(sizeof(struct name_list) + len + 1);\n\t\t} else {\n\t\t\tlast->next = (struct name_list *)\n\t\t\t\tmalloc(sizeof(struct name_list) + len + 1);\n\t\t\tlast = last->next;\n\t\t}\n\t\tif (last == NULL) {\n\t\t\tfree_list(first);\n\t\t\treturn NULL;\n\t\t}\n\t\tlast->next = NULL;\n\t\tstrcpy(last->name, name);\n\n\t\tret = acl_get_entry(acl, ACL_NEXT_ENTRY, &ent);\n\t}\n\treturn first;\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  uint8_t* input() const {\n     return input_ + BorderTop() * kOuterBlockSize + BorderLeft();\n   }\n","project":"Android","target":1},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"int do_print(const char *path_p, const struct stat *st, int walk_flags, void *unused)\n{\n\tconst char *default_prefix = NULL;\n\tacl_t acl = NULL, default_acl = NULL;\n\tint error = 0;\n\n\tif (walk_flags & WALK_TREE_FAILED) {\n\t\tfprintf(stderr, \"%s: %s: %s\\n\", progname, xquote(path_p, \"\\n\\r\"),\n\t\t\tstrerror(errno));\n\t\treturn 1;\n\t}\n\n\t\/*\n\t * Symlinks can never have ACLs, so when doing a physical walk, we\n\t * skip symlinks altogether, and when doing a half-logical walk, we\n\t * skip all non-toplevel symlinks. \n\t *\/\n\tif ((walk_flags & WALK_TREE_SYMLINK) &&\n\t    ((walk_flags & WALK_TREE_PHYSICAL) ||\n\t     !(walk_flags & (WALK_TREE_TOPLEVEL | WALK_TREE_LOGICAL))))\n\t\treturn 0;\n\n\tif (opt_print_acl) {\n\t\tacl = acl_get_file(path_p, ACL_TYPE_ACCESS);\n\t\tif (acl == NULL && (errno == ENOSYS || errno == ENOTSUP))\n\t\t\tacl = acl_get_file_mode(path_p);\n\t\tif (acl == NULL)\n\t\t\tgoto fail;\n\t}\n\n\tif (opt_print_default_acl && S_ISDIR(st->st_mode)) {\n\t\tdefault_acl = acl_get_file(path_p, ACL_TYPE_DEFAULT);\n\t\tif (default_acl == NULL) {\n\t\t\tif (errno != ENOSYS && errno != ENOTSUP)\n\t\t\t\tgoto fail;\n\t\t} else if (acl_entries(default_acl) == 0) {\n\t\t\tacl_free(default_acl);\n\t\t\tdefault_acl = NULL;\n\t\t}\n\t}\n\n\tif (opt_skip_base &&\n\t    (!acl || acl_equiv_mode(acl, NULL) == 0) && !default_acl)\n\t\treturn 0;\n\n\tif (opt_print_acl && opt_print_default_acl)\n\t\tdefault_prefix = \"default:\";\n\n\tif (opt_strip_leading_slash) {\n\t\tif (*path_p == '\/') {\n\t\t\tif (!absolute_warning) {\n\t\t\t\tfprintf(stderr, _(\"%s: Removing leading \"\n\t\t\t\t\t\"'\/' from absolute path names\\n\"),\n\t\t\t\t        progname);\n\t\t\t\tabsolute_warning = 1;\n\t\t\t}\n\t\t\twhile (*path_p == '\/')\n\t\t\t\tpath_p++;\n\t\t} else if (*path_p == '.' && *(path_p+1) == '\/')\n\t\t\twhile (*++path_p == '\/')\n\t\t\t\t\/* nothing *\/ ;\n\t\tif (*path_p == '\\0')\n\t\t\tpath_p = \".\";\n\t}\n\n\tif (opt_tabular)  {\n\t\tif (do_show(stdout, path_p, st, acl, default_acl) != 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tif (opt_comments) {\n\t\t\tprintf(\"# file: %s\\n\", xquote(path_p, \"\\n\\r\"));\n\t\t\tprintf(\"# owner: %s\\n\",\n\t\t\t       xquote(user_name(st->st_uid, opt_numeric), \" \\t\\n\\r\"));\n\t\t\tprintf(\"# group: %s\\n\",\n\t\t\t       xquote(group_name(st->st_gid, opt_numeric), \" \\t\\n\\r\"));\n\t\t}\n\t\tif (acl != NULL) {\n\t\t\tchar *acl_text = acl_to_any_text(acl, NULL, '\\n',\n\t\t\t\t\t\t\t print_options);\n\t\t\tif (!acl_text)\n\t\t\t\tgoto fail;\n\t\t\tif (puts(acl_text) < 0) {\n\t\t\t\tacl_free(acl_text);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tacl_free(acl_text);\n\t\t}\n\t\tif (default_acl != NULL) {\n\t\t\tchar *acl_text = acl_to_any_text(default_acl, \n\t\t\t\t\t\t\t default_prefix, '\\n',\n\t\t\t\t\t\t\t print_options);\n\t\t\tif (!acl_text)\n\t\t\t\tgoto fail;\n\t\t\tif (puts(acl_text) < 0) {\n\t\t\t\tacl_free(acl_text);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tacl_free(acl_text);\n\t\t}\n\t}\n\tif (acl || default_acl || opt_comments)\n\t\tprintf(\"\\n\");\n\ncleanup:\n\tif (acl)\n\t\tacl_free(acl);\n\tif (default_acl)\n\t\tacl_free(default_acl);\n\treturn error;\n\nfail:\n\tfprintf(stderr, \"%s: %s: %s\\n\", progname, xquote(path_p, \"\\n\\r\"),\n\t\tstrerror(errno));\n\terror = -1;\n\tgoto cleanup;\n}\n","project":"savannah","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftG711::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (pcmParams->nChannels < 1 || pcmParams->nChannels > 2) {\n return OMX_ErrorUndefined;\n }\n\n if(pcmParams->nPortIndex == 0) {\n                mNumChannels = pcmParams->nChannels;\n }\n\n            mSamplingRate = pcmParams->nSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (mIsMLaw) {\n                 if (strncmp((const char *)roleParams->cRole,\n                             \"audio_decoder.g711mlaw\",\n                            OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n } else {\n if (strncmp((const char *)roleParams->cRole,\n \"audio_decoder.g711alaw\",\n                            OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static void add_assoc_asn1_string(zval * val, char * key, ASN1_STRING * str) \/* {{{ *\/\n{\n\tadd_assoc_stringl(val, key, (char *)str->data, str->length, 1);\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_device_cmyk(fz_context *ctx)\n{\n\treturn ctx->colorspace->cmyk;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n const VpxInterface *decoder = NULL;\n VpxVideoReader *reader = NULL;\n const VpxVideoInfo *info = NULL;\n int n = 0;\n int m = 0;\n int is_range = 0;\n char *nptr = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 4)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing.\", argv[2]);\n\n  n = strtol(argv[3], &nptr, 0);\n  m = strtol(nptr + 1, NULL, 0);\n  is_range = (*nptr == '-');\n if (!n || !m || (*nptr != '-' && *nptr != '\/'))\n    die(\"Couldn't parse pattern %s.\\n\", argv[3]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n     die_codec(&codec, \"Failed to initialize decoder.\");\n \n   while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n int skip;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))\n      die_codec(&codec, \"Failed to decode frame.\");\n\n ++frame_cnt;\n\n    skip = (is_range && frame_cnt >= n && frame_cnt <= m) ||\n (!is_range && m - (frame_cnt - 1) % m <= n);\n\n if (!skip) {\n      putc('.', stdout);\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL)\n        vpx_img_write(img, outfile);\n } else {\n      putc('X', stdout);\n }\n\n    fflush(stdout);\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\",\n         info->frame_width, info->frame_height, argv[2]);\n\n  vpx_video_reader_close(reader);\n  fclose(outfile);\n\n return EXIT_SUCCESS;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void rgb_to_rgb(fz_context *ctx, const fz_colorspace *cs, const float *rgb, float *xyz)\n{\n\txyz[0] = rgb[0];\n\txyz[1] = rgb[1];\n\txyz[2] = rgb[2];\n}\n","project":"ghostscript","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static struct samldb_ctx *samldb_ctx_init(struct ldb_module *module,\n\t\t\t\t\t  struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\n\tldb = ldb_module_get_ctx(module);\n\n\tac = talloc_zero(req, struct samldb_ctx);\n\tif (ac == NULL) {\n\t\tldb_oom(ldb);\n\t\treturn NULL;\n\t}\n\n\tac->module = module;\n\tac->req = req;\n\n\treturn ac;\n}\n","project":"samba","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftVideoDecoderOMXComponent::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n const int32_t indexFull = index;\n\n switch (indexFull) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         mComponentRole,\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoPortFormat:\n {\n\n             OMX_VIDEO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_VIDEO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > kMaxPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n if (formatParams->nIndex != 0) {\n return OMX_ErrorNoMore;\n }\n\n if (formatParams->nPortIndex == kInputPortIndex) {\n if (formatParams->eCompressionFormat != mCodingType\n || formatParams->eColorFormat != OMX_COLOR_FormatUnused) {\n return OMX_ErrorUnsupportedSetting;\n }\n } else {\n if (formatParams->eCompressionFormat != OMX_VIDEO_CodingUnused\n || formatParams->eColorFormat != OMX_COLOR_FormatYUV420Planar) {\n return OMX_ErrorUnsupportedSetting;\n }\n }\n\n return OMX_ErrorNone;\n }\n\n case kPrepareForAdaptivePlaybackIndex:\n\n         {\n             const PrepareForAdaptivePlaybackParams* adaptivePlaybackParams =\n                     (const PrepareForAdaptivePlaybackParams *)params;\n             mIsAdaptive = adaptivePlaybackParams->bEnable;\n             if (mIsAdaptive) {\n                 mAdaptiveMaxWidth = adaptivePlaybackParams->nMaxFrameWidth;\n                mAdaptiveMaxHeight = adaptivePlaybackParams->nMaxFrameHeight;\n                mWidth = mAdaptiveMaxWidth;\n                mHeight = mAdaptiveMaxHeight;\n } else {\n                mAdaptiveMaxWidth = 0;\n                mAdaptiveMaxHeight = 0;\n }\n            updatePortDefinitions(true \/* updateCrop *\/, true \/* updateInputSize *\/);\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamPortDefinition:\n\n         {\n             OMX_PARAM_PORTDEFINITIONTYPE *newParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n             OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &newParams->format.video;\n             OMX_PARAM_PORTDEFINITIONTYPE *def = &editPortInfo(newParams->nPortIndex)->mDef;\n \n uint32_t oldWidth = def->format.video.nFrameWidth;\n uint32_t oldHeight = def->format.video.nFrameHeight;\n uint32_t newWidth = video_def->nFrameWidth;\n uint32_t newHeight = video_def->nFrameHeight;\n if (newWidth != oldWidth || newHeight != oldHeight) {\n bool outputPort = (newParams->nPortIndex == kOutputPortIndex);\n if (outputPort) {\n                    mWidth = newWidth;\n                    mHeight = newHeight;\n\n                    updatePortDefinitions(true \/* updateCrop *\/, true \/* updateInputSize *\/);\n                    newParams->nBufferSize = def->nBufferSize;\n } else {\n                    def->format.video.nFrameWidth = newWidth;\n                    def->format.video.nFrameHeight = newHeight;\n }\n }\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Segment::DoLoadCluster(\n    long long& pos,\n    long& len)\n{\n    if (m_pos < 0)\n        return DoLoadClusterUnknownSize(pos, len);\n \n    long long total, avail;\n \n    long status = m_pReader->Length(&total, &avail);\n \n    if (status < 0)  \/\/error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n \n    long long cluster_off = -1;   \/\/offset relative to start of segment\n    long long cluster_size = -1;  \/\/size of cluster payload\n \n    for (;;)\n    {\n        if ((total >= 0) && (m_pos >= total))\n            return 1;  \/\/no more clusters\n \n        if ((segment_stop >= 0) && (m_pos >= segment_stop))\n            return 1;  \/\/no more clusters\n \n        pos = m_pos;\n \n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(m_pReader, pos, len);\n \n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n \n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n \n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long idpos = pos;\n        const long long id = ReadUInt(m_pReader, idpos, len);\n \n        if (id < 0)  \/\/error (or underflow)\n            return static_cast<long>(id);\n \n        pos += len;  \/\/consume ID\n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(m_pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(m_pReader, pos, len);\n        if (size < 0)  \/\/error\n            return static_cast<long>(size);\n        pos += len;  \/\/consume length of size of element\n        if (size == 0)  \/\/weird\n        {\n            m_pos = pos;\n            continue;\n        }\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n#if 0  \/\/we must handle this to support live webm\n         if (size == unknown_size)\n             return E_FILE_FORMAT_INVALID;  \/\/TODO: allow this\n #endif\n \n        if ((segment_stop >= 0) &&\n            (size != unknown_size) &&\n            ((pos + size) > segment_stop))\n        {\n            return E_FILE_FORMAT_INVALID;\n        }\n \n#if 0  \/\/commented-out, to support incremental cluster parsing\n         len = static_cast<long>(size);\n \n         if ((pos + size) > avail)\n             return E_BUFFER_NOT_FULL;\n #endif\n \n        if (id == 0x0C53BB6B)  \/\/Cues ID\n        {\n            if (size == unknown_size)\n                return E_FILE_FORMAT_INVALID;  \/\/TODO: liberalize\n \n            if (m_pCues == NULL)\n            {\n                const long long element_size = (pos - idpos) + size;\n \n                m_pCues = new Cues(this,\n                                   pos,\n                                   size,\n                                   idpos,\n                                   element_size);\n                assert(m_pCues);  \/\/TODO\n            }\n \n            m_pos = pos + size;  \/\/consume payload\n            continue;\n        }\n        if (id != 0x0F43B675)  \/\/Cluster ID\n        {\n            if (size == unknown_size)\n                return E_FILE_FORMAT_INVALID;  \/\/TODO: liberalize\n            m_pos = pos + size;  \/\/consume payload\n            continue;\n        }\n        cluster_off = idpos - m_start;  \/\/relative pos\n        if (size != unknown_size)\n            cluster_size = size;\n        break;\n     }\n \n    assert(cluster_off >= 0);  \/\/have cluster\n \n    long long pos_;\n    long len_;\n    status = Cluster::HasBlockEntries(this, cluster_off, pos_, len_);\n    if (status < 0) \/\/error, or underflow\n    {\n        pos = pos_;\n        len = len_;\n        return status;\n     }\n \n \n \n    const long idx = m_clusterCount;\n \n    if (m_clusterPreloadCount > 0)\n    {\n        assert(idx < m_clusterSize);\n \n        Cluster* const pCluster = m_clusters[idx];\n        assert(pCluster);\n        assert(pCluster->m_index < 0);\n \n        const long long off = pCluster->GetPosition();\n        assert(off >= 0);\n \n        if (off == cluster_off)  \/\/preloaded already\n        {\n            if (status == 0)  \/\/no entries found\n                return E_FILE_FORMAT_INVALID;\n \n            if (cluster_size >= 0)\n                pos += cluster_size;\n            else\n            {\n                const long long element_size = pCluster->GetElementSize();\n \n                if (element_size <= 0)\n                    return E_FILE_FORMAT_INVALID;  \/\/TODO: handle this case\n \n                pos = pCluster->m_element_start + element_size;\n            }\n \n            pCluster->m_index = idx;  \/\/move from preloaded to loaded\n            ++m_clusterCount;\n            --m_clusterPreloadCount;\n \n            m_pos = pos;  \/\/consume payload\n            assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n            return 0;  \/\/success\n        }\n    }\n    if (status == 0)  \/\/no entries found\n    {\n        if (cluster_size < 0)\n            return E_FILE_FORMAT_INVALID;  \/\/TODO: handle this\n        pos += cluster_size;\n        if ((total >= 0) && (pos >= total))\n        {\n            m_pos = total;\n            return 1;  \/\/no more clusters\n        }\n        if ((segment_stop >= 0) && (pos >= segment_stop))\n        {\n            m_pos = segment_stop;\n            return 1;  \/\/no more clusters\n        }\n        m_pos = pos;\n        return 2;  \/\/try again\n    }\n    Cluster* const pCluster = Cluster::Create(this,\n                                              idx,\n                                              cluster_off);\n    assert(pCluster);\n    AppendCluster(pCluster);\n    assert(m_clusters);\n     assert(idx < m_clusterSize);\n    assert(m_clusters[idx] == pCluster);\n \n    if (cluster_size >= 0)\n    {\n         pos += cluster_size;\n \n        m_pos = pos;\n        assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n        return 0;\n     }\n \n    m_pUnknownSize = pCluster;\n    m_pos = -pos;\n \n    return 0;  \/\/partial success, since we have a new cluster\n \n \n\/\/\/\/ status == 0 means \"no block entries found\"\n\/\/\/\/ pos designates start of payload\n\/\/\/\/ m_pos has NOT been adjusted yet (in case we need to come back here)\n \n #if 0\n \n    if (cluster_size < 0)  \/\/unknown size\n    {\n         const long long payload_pos = pos;  \/\/absolute pos of cluster payload\n \n        for (;;)  \/\/determine cluster size\n        {\n             if ((total >= 0) && (pos >= total))\n                 break;\n \n if ((segment_stop >= 0) && (pos >= segment_stop))\n break; \/\/no more clusters\n\n\n if ((pos + 1) > avail)\n {\n                len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \/\/error\n return static_cast<long>(result);\n\n if (result > 0) \/\/weird\n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long idpos = pos;\n const long long id = ReadUInt(m_pReader, idpos, len);\n\n if (id < 0) \/\/error (or underflow)\n return static_cast<long>(id);\n\n\n if (id == 0x0F43B675) \/\/Cluster ID\n break;\n\n if (id == 0x0C53BB6B) \/\/Cues ID\n break;\n\n switch (id)\n {\n case 0x20: \/\/BlockGroup\n case 0x23: \/\/Simple Block\n case 0x67: \/\/TimeCode\n case 0x2B: \/\/PrevSize\n break;\n\n default:\n                    assert(false);\n break;\n }\n\n            pos += len; \/\/consume ID (of sub-element)\n\n\n if ((pos + 1) > avail)\n {\n                len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n            result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \/\/error\n return static_cast<long>(result);\n\n if (result > 0) \/\/weird\n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) \/\/error\n return static_cast<long>(size);\n\n            pos += len; \/\/consume size field of element\n\n\n if (size == 0) \/\/weird\n continue;\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID; \/\/not allowed for sub-elements\n\n if ((segment_stop >= 0) && ((pos + size) > segment_stop)) \/\/weird\n return E_FILE_FORMAT_INVALID;\n\n            pos += size; \/\/consume payload of sub-element\n            assert((segment_stop < 0) || (pos <= segment_stop));\n } \/\/determine cluster size\n\n        cluster_size = pos - payload_pos;\n        assert(cluster_size >= 0);\n\n        pos = payload_pos; \/\/reset and re-parse original cluster\n }\n\n if (m_clusterPreloadCount > 0)\n {\n        assert(idx < m_clusterSize);\n\n Cluster* const pCluster = m_clusters[idx];\n        assert(pCluster);\n        assert(pCluster->m_index < 0);\n\n const long long off = pCluster->GetPosition();\n        assert(off >= 0);\n\n if (off == cluster_off) \/\/preloaded already\n return E_FILE_FORMAT_INVALID; \/\/subtle\n }\n\n    m_pos = pos + cluster_size; \/\/consume payload\n    assert((segment_stop < 0) || (m_pos <= segment_stop));\n\n\n     return 2;     \/\/try to find another cluster\n \n #endif\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"BlockEntry::Kind BlockGroup::GetKind() const\n{\n    return kBlockGroup;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_new_icc_link(fz_context *ctx, fz_iccprofile *dst, int dst_extras, fz_iccprofile *src, int src_extras, fz_iccprofile *prf, const fz_color_params *rend, int num_bytes, int copy_extras)\n{\n\tfz_icclink *link = fz_malloc_struct(ctx, fz_icclink);\n\tFZ_INIT_STORABLE(link, 1, fz_drop_link_imp);\n\n\tif (memcmp(src->md5, dst->md5, 16) == 0 && prf == NULL)\n\t{\n\t\tlink->is_identity = 1;\n\t\treturn link;\n\t}\n\n\tfz_try(ctx)\n\t\tfz_cmm_init_link(ctx, link, dst, dst_extras, src, src_extras, prf, rend, 0, num_bytes, copy_extras);\n\tfz_catch(ctx)\n\t{\n\t\tfz_free(ctx, link);\n\t\tfz_rethrow(ctx);\n\t}\n\n\treturn link;\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static void php_csr_free(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tX509_REQ * csr = (X509_REQ*)rsrc->ptr;\n\tX509_REQ_free(csr);\n}\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_extra_free (struct attr *attr)\n{\n  if (attr->extra)\n    {\n      XFREE (MTYPE_ATTR_EXTRA, attr->extra);\n      attr->extra = NULL;\n    }\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" int main(int argc, char **argv)\n {\n    FILE                *infile, *outfile[NUM_ENCODERS];\n     vpx_codec_ctx_t      codec[NUM_ENCODERS];\n     vpx_codec_enc_cfg_t  cfg[NUM_ENCODERS];\n    vpx_codec_pts_t      frame_cnt = 0;\n     vpx_image_t          raw[NUM_ENCODERS];\n     vpx_codec_err_t      res[NUM_ENCODERS];\n \n     int                  i;\n     long                 width;\n     long                 height;\n     int                  frame_avail;\n     int                  got_data;\n     int                  flags = 0;\n \n     \/*Currently, only realtime mode is supported in multi-resolution encoding.*\/\n     int                  arg_deadline = VPX_DL_REALTIME;\n\n \/* Set show_psnr to 1\/0 to show\/not show PSNR. Choose show_psnr=0 if you\n\n        don't need to know PSNR, which will skip PSNR calculation and save\n        encoding time. *\/\n     int                  show_psnr = 0;\n     uint64_t             psnr_sse_total[NUM_ENCODERS] = {0};\n     uint64_t             psnr_samples_total[NUM_ENCODERS] = {0};\n     double               psnr_totals[NUM_ENCODERS][4] = {{0,0}};\n     int                  psnr_count[NUM_ENCODERS] = {0};\n \n     \/* Set the required target bitrates for each resolution level.\n      * If target bitrate for highest-resolution level is set to 0,\n      * (i.e. target_bitrate[0]=0), we skip encoding at that level.\n      *\/\n     unsigned int         target_bitrate[NUM_ENCODERS]={1000, 500, 100};\n     \/* Enter the frame rate of the input video *\/\n     int                  framerate = 30;\n     \/* Set down-sampling factor for each resolution level.\n        dsf[0] controls down sampling from level 0 to level 1;\n        dsf[1] controls down sampling from level 1 to level 2;\n        dsf[2] is not used. *\/\n     vpx_rational_t dsf[NUM_ENCODERS] = {{2, 1}, {2, 1}, {1, 1}};\n \n    if(argc!= (5+NUM_ENCODERS))\n        die(\"Usage: %s <width> <height> <infile> <outfile(s)> <output psnr?>\\n\",\n             argv[0]);\n \n     printf(\"Using %s\\n\",vpx_codec_iface_name(interface));\n \n     width = strtol(argv[1], NULL, 0);\n     height = strtol(argv[2], NULL, 0);\n \n     if(width < 16 || width%2 || height <16 || height%2)\n         die(\"Invalid resolution: %ldx%ld\", width, height);\n \n     \/* Open input video file for encoding *\/\n    if(!(infile = fopen(argv[3], \"rb\")))\n        die(\"Failed to open %s for reading\", argv[3]);\n \n     \/* Open output file for each encoder to output bitstreams *\/\n     for (i=0; i< NUM_ENCODERS; i++)\n {\n if(!target_bitrate[i])\n {\n            outfile[i] = NULL;\n\n             continue;\n         }\n \n        if(!(outfile[i] = fopen(argv[i+4], \"wb\")))\n             die(\"Failed to open %s for writing\", argv[i+4]);\n     }\n \n    show_psnr = strtol(argv[NUM_ENCODERS + 4], NULL, 0);\n \n     \/* Populate default encoder configuration *\/\n     for (i=0; i< NUM_ENCODERS; i++)\n {\n        res[i] = vpx_codec_enc_config_default(interface, &cfg[i], 0);\n if(res[i]) {\n            printf(\"Failed to get config: %s\\n\", vpx_codec_err_to_string(res[i]));\n return EXIT_FAILURE;\n }\n }\n\n \/*\n     * Update the default configuration according to needs of the application.\n     *\/\n\n     \/* Highest-resolution encoder settings *\/\n     cfg[0].g_w = width;\n     cfg[0].g_h = height;\n    cfg[0].g_threads = 1;                           \/* number of threads used *\/\n    cfg[0].rc_dropframe_thresh = 30;\n     cfg[0].rc_end_usage = VPX_CBR;\n     cfg[0].rc_resize_allowed = 0;\n    cfg[0].rc_min_quantizer = 4;\n     cfg[0].rc_max_quantizer = 56;\n    cfg[0].rc_undershoot_pct = 98;\n    cfg[0].rc_overshoot_pct = 100;\n     cfg[0].rc_buf_initial_sz = 500;\n     cfg[0].rc_buf_optimal_sz = 600;\n     cfg[0].rc_buf_sz = 1000;\n    cfg[0].g_error_resilient = 1; \/* Enable error resilient mode *\/\n    cfg[0].g_lag_in_frames   = 0;\n\n \/* Disable automatic keyframe placement *\/\n\n     \/* Note: These 3 settings are copied to all levels. But, except the lowest\n      * resolution level, all other levels are set to VPX_KF_DISABLED internally.\n      *\/\n     cfg[0].kf_min_dist = 3000;\n     cfg[0].kf_max_dist = 3000;\n\n    cfg[0].rc_target_bitrate = target_bitrate[0]; \/* Set target bitrate *\/\n    cfg[0].g_timebase.num = 1; \/* Set fps *\/\n    cfg[0].g_timebase.den = framerate;\n\n \/* Other-resolution encoder settings *\/\n for (i=1; i< NUM_ENCODERS; i++)\n\n     {\n         memcpy(&cfg[i], &cfg[0], sizeof(vpx_codec_enc_cfg_t));\n \n        cfg[i].g_threads = 1;                       \/* number of threads used *\/\n         cfg[i].rc_target_bitrate = target_bitrate[i];\n \n         \/* Note: Width & height of other-resolution encoders are calculated\n         * from the highest-resolution encoder's size and the corresponding\n         * down_sampling_factor.\n         *\/\n {\n unsigned int iw = cfg[i-1].g_w*dsf[i-1].den + dsf[i-1].num - 1;\n unsigned int ih = cfg[i-1].g_h*dsf[i-1].den + dsf[i-1].num - 1;\n            cfg[i].g_w = iw\/dsf[i-1].num;\n            cfg[i].g_h = ih\/dsf[i-1].num;\n }\n\n \/* Make width & height to be multiplier of 2. *\/\n if((cfg[i].g_w)%2)cfg[i].g_w++;\n\n         if((cfg[i].g_h)%2)cfg[i].g_h++;\n     }\n \n     \/* Allocate image for each encoder *\/\n     for (i=0; i< NUM_ENCODERS; i++)\n         if(!vpx_img_alloc(&raw[i], VPX_IMG_FMT_I420, cfg[i].g_w, cfg[i].g_h, 32))\n            die(\"Failed to allocate image\", cfg[i].g_w, cfg[i].g_h);\n\n if (raw[0].stride[VPX_PLANE_Y] == raw[0].d_w)\n        read_frame_p = read_frame;\n else\n        read_frame_p = read_frame_by_row;\n\n for (i=0; i< NUM_ENCODERS; i++)\n\n         if(outfile[i])\n             write_ivf_file_header(outfile[i], &cfg[i], 0);\n \n     \/* Initialize multi-encoder *\/\n     if(vpx_codec_enc_init_multi(&codec[0], interface, &cfg[0], NUM_ENCODERS,\n                                 (show_psnr ? VPX_CODEC_USE_PSNR : 0), &dsf[0]))\n        die_codec(&codec[0], \"Failed to initialize encoder\");\n\n \/* The extra encoding configuration parameters can be set as follows. *\/\n \/* Set encoding speed *\/\n\n     for ( i=0; i<NUM_ENCODERS; i++)\n     {\n         int speed = -6;\n         if(vpx_codec_control(&codec[i], VP8E_SET_CPUUSED, speed))\n             die_codec(&codec[i], \"Failed to set cpu_used\");\n     }\n \n    \/* Set static threshold. *\/\n     for ( i=0; i<NUM_ENCODERS; i++)\n     {\n        unsigned int static_thresh = 1;\n        if(vpx_codec_control(&codec[i], VP8E_SET_STATIC_THRESHOLD, static_thresh))\n             die_codec(&codec[i], \"Failed to set static threshold\");\n     }\n \n \/* Set NOISE_SENSITIVITY to do TEMPORAL_DENOISING *\/\n \/* Enable denoising for the highest-resolution encoder. *\/\n if(vpx_codec_control(&codec[0], VP8E_SET_NOISE_SENSITIVITY, 1))\n        die_codec(&codec[0], \"Failed to set noise_sensitivity\");\n for ( i=1; i< NUM_ENCODERS; i++)\n {\n if(vpx_codec_control(&codec[i], VP8E_SET_NOISE_SENSITIVITY, 0))\n\n             die_codec(&codec[i], \"Failed to set noise_sensitivity\");\n     }\n \n \n     frame_avail = 1;\n     got_data = 0;\n\n while(frame_avail || got_data)\n {\n vpx_codec_iter_t iter[NUM_ENCODERS]={NULL};\n const vpx_codec_cx_pkt_t *pkt[NUM_ENCODERS];\n\n        flags = 0;\n        frame_avail = read_frame_p(infile, &raw[0]);\n\n if(frame_avail)\n {\n for ( i=1; i<NUM_ENCODERS; i++)\n {\n \/*Scale the image down a number of times by downsampling factor*\/\n \/* FilterMode 1 or 2 give better psnr than FilterMode 0. *\/\n                I420Scale(raw[i-1].planes[VPX_PLANE_Y], raw[i-1].stride[VPX_PLANE_Y],\n                          raw[i-1].planes[VPX_PLANE_U], raw[i-1].stride[VPX_PLANE_U],\n                          raw[i-1].planes[VPX_PLANE_V], raw[i-1].stride[VPX_PLANE_V],\n                          raw[i-1].d_w, raw[i-1].d_h,\n                          raw[i].planes[VPX_PLANE_Y], raw[i].stride[VPX_PLANE_Y],\n\n                           raw[i].planes[VPX_PLANE_U], raw[i].stride[VPX_PLANE_U],\n                           raw[i].planes[VPX_PLANE_V], raw[i].stride[VPX_PLANE_V],\n                           raw[i].d_w, raw[i].d_h, 1);\n             }\n         }\n \n        \/* Encode each frame at multi-levels *\/\n        if(vpx_codec_encode(&codec[0], frame_avail? &raw[0] : NULL,\n            frame_cnt, 1, flags, arg_deadline))\n            die_codec(&codec[0], \"Failed to encode frame\");\n \n         for (i=NUM_ENCODERS-1; i>=0 ; i--)\n         {\n             got_data = 0;\n             while( (pkt[i] = vpx_codec_get_cx_data(&codec[i], &iter[i])) )\n             {\n                 got_data = 1;\n switch(pkt[i]->kind) {\n case VPX_CODEC_CX_FRAME_PKT:\n                        write_ivf_frame_header(outfile[i], pkt[i]);\n (void) fwrite(pkt[i]->data.frame.buf, 1,\n                                      pkt[i]->data.frame.sz, outfile[i]);\n break;\n case VPX_CODEC_PSNR_PKT:\n if (show_psnr)\n {\n int j;\n\n                            psnr_sse_total[i] += pkt[i]->data.psnr.sse[0];\n\n                             psnr_samples_total[i] += pkt[i]->data.psnr.samples[0];\n                             for (j = 0; j < 4; j++)\n                             {\n                             }\n                             psnr_count[i]++;\n }\n\n break;\n default:\n\n                         break;\n                 }\n                 printf(pkt[i]->kind == VPX_CODEC_CX_FRAME_PKT\n                       && (pkt[i]->data.frame.flags & VPX_FRAME_IS_KEY)? \"K\":\".\");\n                 fflush(stdout);\n             }\n         }\n         frame_cnt++;\n     }\n     printf(\"\\n\");\n \n     fclose(infile);\n \n    printf(\"Processed %ld frames.\\n\",(long int)frame_cnt-1);\n for (i=0; i< NUM_ENCODERS; i++)\n {\n \/* Calculate PSNR and print it out *\/\n if ( (show_psnr) && (psnr_count[i]>0) )\n {\n int j;\n double ovpsnr = sse_to_psnr(psnr_samples_total[i], 255.0,\n                                        psnr_sse_total[i]);\n\n            fprintf(stderr, \"\\n ENC%d PSNR (Overall\/Avg\/Y\/U\/V)\", i);\n\n            fprintf(stderr, \" %.3lf\", ovpsnr);\n for (j = 0; j < 4; j++)\n {\n                fprintf(stderr, \" %.3lf\", psnr_totals[i][j]\/psnr_count[i]);\n }\n }\n\n if(vpx_codec_destroy(&codec[i]))\n            die_codec(&codec[i], \"Failed to destroy codec\");\n\n        vpx_img_free(&raw[i]);\n\n if(!outfile[i])\n continue;\n\n \/* Try to rewrite the file header with the actual frame count *\/\n if(!fseek(outfile[i], 0, SEEK_SET))\n            write_ivf_file_header(outfile[i], &cfg[i], frame_cnt-1);\n        fclose(outfile[i]);\n }\n    printf(\"\\n\");\n\n return EXIT_SUCCESS;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* Chapters::Atom::GetStringUID() const\n{\n    return m_string_uid;\n}\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_objectclass_trigger(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tvoid *skip_allocate_sids = ldb_get_opaque(ldb,\n\t\t\t\t\t\t  \"skip_allocate_sids\");\n\tstruct ldb_message_element *el, *el2;\n\tstruct dom_sid *sid;\n\tint ret;\n\n\t\/* make sure that \"sAMAccountType\" is not specified *\/\n\tel = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\tif (el != NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: sAMAccountType must not be specified!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t\/* Step 1: objectSid assignment *\/\n\n\t\/* Don't allow the objectSid to be changed. But beside the RELAX\n\t * control we have also to guarantee that it can always be set with\n\t * SYSTEM permissions. This is needed for the \"samba3sam\" backend. *\/\n\tsid = samdb_result_dom_sid(ac, ac->msg, \"objectSid\");\n\tif ((sid != NULL) && (!dsdb_module_am_system(ac->module)) &&\n\t    (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: objectSid must not be specified!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t\/* but generate a new SID when we do have an add operations *\/\n\tif ((sid == NULL) && (ac->req->operation == LDB_ADD) && !skip_allocate_sids) {\n\t\tret = samldb_add_step(ac, samldb_allocate_sid);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t}\n\n\tswitch(ac->type) {\n\tcase SAMLDB_TYPE_USER: {\n\t\tbool uac_generated = false, uac_add_flags = false;\n\n\t\t\/* Step 1.2: Default values *\/\n\t\tret = dsdb_user_obj_set_defaults(ldb, ac->msg);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* On add operations we might need to generate a\n\t\t * \"userAccountControl\" (if it isn't specified). *\/\n\t\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\t\tif ((el == NULL) && (ac->req->operation == LDB_ADD)) {\n\t\t\tret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t UF_NORMAL_ACCOUNT);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tuac_generated = true;\n\t\t\tuac_add_flags = true;\n\t\t}\n\n\t\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\t\tif (el != NULL) {\n\t\t\tuint32_t user_account_control;\n\t\t\t\/* Step 1.3: \"userAccountControl\" -> \"sAMAccountType\" mapping *\/\n\t\t\tuser_account_control = ldb_msg_find_attr_as_uint(ac->msg,\n\t\t\t\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t\t\t\t 0);\n\t\t\t\/*\n\t\t\t * \"userAccountControl\" = 0 or missing one of\n\t\t\t * the types means \"UF_NORMAL_ACCOUNT\".  See\n\t\t\t * MS-SAMR 3.1.1.8.10 point 8\n\t\t\t *\/\n\t\t\tif ((user_account_control & UF_ACCOUNT_TYPE_MASK) == 0) {\n\t\t\t\tuser_account_control = UF_NORMAL_ACCOUNT | user_account_control;\n\t\t\t\tuac_generated = true;\n\t\t\t}\n\n\t\t\t\/*\n\t\t\t * As per MS-SAMR 3.1.1.8.10 these flags have not to be set\n\t\t\t *\/\n\t\t\tif ((user_account_control & UF_LOCKOUT) != 0) {\n\t\t\t\tuser_account_control &= ~UF_LOCKOUT;\n\t\t\t\tuac_generated = true;\n\t\t\t}\n\t\t\tif ((user_account_control & UF_PASSWORD_EXPIRED) != 0) {\n\t\t\t\tuser_account_control &= ~UF_PASSWORD_EXPIRED;\n\t\t\t\tuac_generated = true;\n\t\t\t}\n\n\t\t\tret = samldb_check_user_account_control_rules(ac, NULL,\n\t\t\t\t\t\t\t\t      user_account_control, 0);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t\/* Workstation and (read-only) DC objects do need objectclass \"computer\" *\/\n\t\t\tif ((samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"objectclass\", \"computer\") == NULL) &&\n\t\t\t    (user_account_control &\n\t\t\t     (UF_SERVER_TRUST_ACCOUNT | UF_WORKSTATION_TRUST_ACCOUNT))) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\t  \"samldb: Requested account type does need objectclass 'computer'!\");\n\t\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t\t}\n\n\t\t\t\/* add \"sAMAccountType\" attribute *\/\n\t\t\tret = dsdb_user_obj_set_account_type(ldb, ac->msg, user_account_control, NULL);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t\/* \"isCriticalSystemObject\" might be set *\/\n\t\t\tif (user_account_control &\n\t\t\t    (UF_SERVER_TRUST_ACCOUNT | UF_PARTIAL_SECRETS_ACCOUNT)) {\n\t\t\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t\t\t \"TRUE\");\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tel2 = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t\t} else if (user_account_control & UF_WORKSTATION_TRUST_ACCOUNT) {\n\t\t\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t\t\t \"FALSE\");\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tel2 = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t\t}\n\n\t\t\t\/* Step 1.4: \"userAccountControl\" -> \"primaryGroupID\" mapping *\/\n\t\t\tif (!ldb_msg_find_element(ac->msg, \"primaryGroupID\")) {\n\t\t\t\tuint32_t rid;\n\n\t\t\t\tret = dsdb_user_obj_set_primary_group_id(ldb, ac->msg, user_account_control, &rid);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\t\/*\n\t\t\t\t * Older AD deployments don't know about the\n\t\t\t\t * RODC group\n\t\t\t\t *\/\n\t\t\t\tif (rid == DOMAIN_RID_READONLY_DCS) {\n\t\t\t\t\tret = samldb_prim_group_tester(ac, rid);\n\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/* Step 1.5: Add additional flags when needed *\/\n\t\t\t\/* Obviously this is done when the \"userAccountControl\"\n\t\t\t * has been generated here (tested against Windows\n\t\t\t * Server) *\/\n\t\t\tif (uac_generated) {\n\t\t\t\tif (uac_add_flags) {\n\t\t\t\t\tuser_account_control |= UF_ACCOUNTDISABLE;\n\t\t\t\t\tuser_account_control |= UF_PASSWD_NOTREQD;\n\t\t\t\t}\n\n\t\t\t\tret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t\t user_account_control);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_GROUP: {\n\t\tconst char *tempstr;\n\n\t\t\/* Step 2.2: Default values *\/\n\t\ttempstr = talloc_asprintf(ac->msg, \"%d\",\n\t\t\t\t\t  GTYPE_SECURITY_GLOBAL_GROUP);\n\t\tif (tempstr == NULL) return ldb_operr(ldb);\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\"groupType\", tempstr);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t\/* Step 2.3: \"groupType\" -> \"sAMAccountType\" *\/\n\t\tel = ldb_msg_find_element(ac->msg, \"groupType\");\n\t\tif (el != NULL) {\n\t\t\tuint32_t group_type, account_type;\n\n\t\t\tgroup_type = ldb_msg_find_attr_as_uint(ac->msg,\n\t\t\t\t\t\t\t       \"groupType\", 0);\n\n\t\t\t\/* The creation of builtin groups requires the\n\t\t\t * RELAX control *\/\n\t\t\tif (group_type == GTYPE_SECURITY_BUILTIN_LOCAL_GROUP) {\n\t\t\t\tif (ldb_request_get_control(ac->req,\n\t\t\t\t\t\t\t    LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taccount_type = ds_gtype2atype(group_type);\n\t\t\tif (account_type == 0) {\n\t\t\t\tldb_set_errstring(ldb, \"samldb: Unrecognized account type!\");\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"sAMAccountType\",\n\t\t\t\t\t\t account_type);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tel2 = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"Invalid entry type!\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\tbreak;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n","project":"samba","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void SubpelVarianceTest<vp9_subp_avg_variance_fn_t>::RefTest() {\n  for (int x = 0; x < 16; ++x) {\n    for (int y = 0; y < 16; ++y) {\n      for (int j = 0; j < block_size_; j++) {\n        src_[j] = rnd.Rand8();\n        sec_[j] = rnd.Rand8();\n      }\n      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {\n        ref_[j] = rnd.Rand8();\n       }\n       unsigned int sse1, sse2;\n       unsigned int var1;\n      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,\n                                                   src_, width_, &sse1, sec_));\n       const unsigned int var2 = subpel_avg_variance_ref(ref_, src_, sec_,\n                                                         log2width_, log2height_,\n                                                        x, y, &sse2);\n       EXPECT_EQ(sse1, sse2) << \"at position \" << x << \", \" << y;\n       EXPECT_EQ(var1, var2) << \"at position \" << x << \", \" << y;\n     }\n   }\n }\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_allocate_sid(struct samldb_ctx *ac)\n{\n\tuint32_t rid;\n\tstruct dom_sid *sid;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\n\tret = ridalloc_allocate_rid(ac->module, &rid, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tif ( ! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n","project":"samba","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_as4_aggregator (struct bgp_attr_parser_args *args,\n\t\t         as_t *as4_aggregator_as,\n\t\t         struct in_addr *as4_aggregator_addr)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n      \n  if (length != 8)\n    {\n      zlog (peer->log, LOG_ERR, \"New Aggregator length is not 8 [%d]\",\n            length);\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 0);\n    }\n  \n  *as4_aggregator_as = stream_getl (peer->ibuf);\n  as4_aggregator_addr->s_addr = stream_get_ipv4 (peer->ibuf);\n\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS4_AGGREGATOR);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n VpxVideoReader *reader = NULL;\n const VpxVideoInfo *info = NULL;\n const VpxInterface *decoder = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 3)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing.\", argv[2]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n     die_codec(&codec, \"Failed to initialize decoder\");\n \n   while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))\n      die_codec(&codec, \"Failed to decode frame\");\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {\n unsigned char digest[16];\n\n      get_image_md5(img, digest);\n      print_md5(outfile, digest);\n      fprintf(outfile, \"  img-%dx%d-%04d.i420\\n\",\n              img->d_w, img->d_h, ++frame_cnt);\n }\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_reader_close(reader);\n\n  fclose(outfile);\n return EXIT_SUCCESS;\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_K(fz_context *ctx, pdf_processor *proc, float c, float m, float y, float k)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tfloat color[4] = {c, m, y, k};\n\tpr->dev->flags &= ~FZ_DEVFLAG_STROKECOLOR_UNDEFINED;\n\tpdf_set_colorspace(ctx, pr, PDF_STROKE, fz_device_cmyk(ctx));\n\tpdf_set_color(ctx, pr, PDF_STROKE, color);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Cues::Init() const\n{\n    if (m_cue_points)\n        return;\n \n    assert(m_count == 0);\n    assert(m_preload_count == 0);\n \n    IMkvReader* const pReader = m_pSegment->m_pReader;\n \n    const long long stop = m_start + m_size;\n    long long pos = m_start;\n \n    long cue_points_size = 0;\n \n    while (pos < stop)\n    {\n        const long long idpos = pos;\n \n        long len;\n        const long long id = ReadUInt(pReader, pos, len);\n        assert(id >= 0);  \/\/TODO\n        assert((pos + len) <= stop);\n        pos += len;  \/\/consume ID\n        const long long size = ReadUInt(pReader, pos, len);\n        assert(size >= 0);\n        assert((pos + len) <= stop);\n        pos += len;  \/\/consume Size field\n        assert((pos + size) <= stop);\n        if (id == 0x3B)  \/\/CuePoint ID\n            PreloadCuePoint(cue_points_size, idpos);\n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n    }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"const fz_cmm_engine *fz_get_cmm_engine(fz_context *ctx)\n{\n\treturn ctx->colorspace ? ctx->colorspace->cmm : NULL;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"g2cmyk(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tdv[0] = 0;\n\tdv[1] = 0;\n\tdv[2] = 0;\n\tdv[3] = 1 - sv[0];\n}\n","project":"ghostscript","target":0},{"commit_id":"d3c6ce463ac91ecbeb2128beb475d31d3ca6ef42","func":" static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n {\n     const char *perm = \"add\";\n     return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"SimpleBlock::SimpleBlock(\n    Cluster* pCluster,\n    long idx,\n    long long start,\n    long long size) :\n    BlockEntry(pCluster, idx),\n    m_block(start, size, 0)\n{\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void DecoderTest::RunLoop(CompressedVideoSource *video) {\n  vpx_codec_dec_cfg_t dec_cfg = {0};\n  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);\n   ASSERT_TRUE(decoder != NULL);\n \n  for (video->Begin(); video->cxdata(); video->Next()) {\n     PreDecodeFrameHook(*video, decoder);\n    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),\n                                                   video->frame_size());\n    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n \n     DxDataIterator dec_iter = decoder->GetDxData();\n     const vpx_image_t *img = NULL;\n\n\n     while ((img = dec_iter.Next()))\n       DecompressedFrameHook(*img, video->frame_number());\n   }\n   delete decoder;\n }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_TL(fz_context *ctx, pdf_processor *proc, float leading)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tgstate->text.leading = leading;\n}\n","project":"ghostscript","target":0},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"static void timelib_eat_until_separator(char **ptr)\n{\n\twhile (strchr(\" \\t.,:;\/-0123456789\", **ptr) == NULL) {\n\t\t++*ptr;\n\t}\n}\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_private_decrypt)\n{\n\tzval **key, *crypted;\n\tEVP_PKEY *pkey;\n\tint cryptedlen;\n\tunsigned char *cryptedbuf = NULL;\n\tunsigned char *crypttemp;\n\tint successful = 0;\n\tlong padding = RSA_PKCS1_PADDING;\n\tlong keyresource = -1;\n\tchar * data;\n\tint data_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"szZ|l\", &data, &data_len, &crypted, &key, &padding) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tpkey = php_openssl_evp_from_zval(key, 0, \"\", 0, &keyresource TSRMLS_CC);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key parameter is not a valid private key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcryptedlen = EVP_PKEY_size(pkey);\n\tcrypttemp = emalloc(cryptedlen + 1);\n\n\tswitch (pkey->type) {\n\t\tcase EVP_PKEY_RSA:\n\t\tcase EVP_PKEY_RSA2:\n\t\t\tcryptedlen = RSA_private_decrypt(data_len, \n\t\t\t\t\t(unsigned char *)data, \n\t\t\t\t\tcrypttemp, \n\t\t\t\t\tpkey->pkey.rsa, \n\t\t\t\t\tpadding);\n\t\t\tif (cryptedlen != -1) {\n\t\t\t\tcryptedbuf = emalloc(cryptedlen + 1);\n\t\t\t\tmemcpy(cryptedbuf, crypttemp, cryptedlen);\n\t\t\t\tsuccessful = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key type not supported in this PHP build!\");\n\t}\n\n\tefree(crypttemp);\n\n\tif (successful) {\n\t\tzval_dtor(crypted);\n\t\tcryptedbuf[cryptedlen] = '\\0';\n\t\tZVAL_STRINGL(crypted, (char *)cryptedbuf, cryptedlen, 0);\n\t\tcryptedbuf = NULL;\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (keyresource == -1) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tif (cryptedbuf) { \n\t\tefree(cryptedbuf);\n\t}\n}\n","project":"php","target":0},{"commit_id":"190cef6eed37d0e73a73c1e205eb31d45ab60a3c","func":"gnutls_session_get_id (gnutls_session_t session,\n                       void *session_id, size_t * session_id_size)\n{\n  size_t given_session_id_size = *session_id_size;\n\n  *session_id_size = session->security_parameters.session_id_size;\n\n  \/* just return the session size *\/\n  if (session_id == NULL)\n    {\n      return 0;\n    }\n\n  if (given_session_id_size < session->security_parameters.session_id_size)\n    {\n      return GNUTLS_E_SHORT_MEMORY_BUFFER;\n    }\n\n  memcpy (session_id, &session->security_parameters.session_id,\n          *session_id_size);\n\n  return 0;\n}\n","project":"savannah","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"long ssl3_default_timeout(void)\n\t{\n\t\/* 2 hours, the 24 hours mentioned in the SSLv3 spec\n\t * is way too long for http, the cache would over fill *\/\n\treturn(60*60*2);\n\t}\n","project":"openssl","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"const SSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p)\n\t{\n\tSSL_CIPHER c;\n\tconst SSL_CIPHER *cp;\n\tunsigned long id;\n\n\tid=0x03000000L|((unsigned long)p[0]<<8L)|(unsigned long)p[1];\n\tc.id=id;\n\tcp = OBJ_bsearch_ssl_cipher_id(&c, ssl3_ciphers, SSL3_NUM_CIPHERS);\n#ifdef DEBUG_PRINT_UNKNOWN_CIPHERSUITES\nif (cp == NULL) fprintf(stderr, \"Unknown cipher ID %x\\n\", (p[0] << 8) | p[1]);\n#endif\n\tif (cp == NULL || cp->valid == 0)\n\t\treturn NULL;\n\telse\n\t\treturn cp;\n\t}\n","project":"openssl","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"static unsigned int variance_ref(const uint8_t *ref, const uint8_t *src,\n                                 int l2w, int l2h, unsigned int *sse_ptr) {\n  int se = 0;\n  unsigned int sse = 0;\n  const int w = 1 << l2w, h = 1 << l2h;\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) {\n      int diff = ref[w * y + x] - src[w * y + x];\n      se += diff;\n      sse += diff * diff;\n    }\n\/\/\/\/ Truncate high bit depth results by downshifting (with rounding) by:\n\/\/\/\/ 2 * (bit_depth - 8) for sse\n\/\/\/\/ (bit_depth - 8) for se\n   }\n  *sse_ptr = sse;\n  return sse - (((int64_t) se * se) >> (l2w + l2h));\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void fdct8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n  vp9_fdct8x8_c(in, out, stride);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"int Chapters::Edition::GetAtomCount() const\n{\n    return m_atoms_count;\n }\n","project":"Android","target":1},{"commit_id":"308396a55280f69ad4112d4f9892f4cbeff042aa","func":"xmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n if (RAW != '%')\n return;\n    NEXT;\n    name = xmlParseName(ctxt);\n if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n \"xmlParsePEReference: no name\\n\");\n return;\n }\n if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n return;\n }\n\n    NEXT;\n\n \/*\n     * Increate the number of entity references parsed\n     *\/\n    ctxt->nbentities++;\n\n \/*\n     * Request the entity from SAX\n     *\/\n if ((ctxt->sax != NULL) &&\n (ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n if (ctxt->instate == XML_PARSER_EOF)\n return;\n if (entity == NULL) {\n \/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t *\/\n if ((ctxt->standalone == 1) ||\n ((ctxt->hasExternalSubset == 0) &&\n (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n } else {\n \/*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     *\/\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t  name, NULL);\n\t    ctxt->valid = 0;\n }\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n } else {\n \/*\n\t * Internal checking in case the entity quest barfed\n\t *\/\n if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n } else if (ctxt->input->free != deallocblankswrapper) {\n\t    input = xmlNewBlanksWrapperInputStream(ctxt, entity);\n\n \t    if (xmlPushInput(ctxt, input) < 0)\n \t\treturn;\n \t} else {\n \t    \/*\n \t     * TODO !!!\n \t     * handle the extra spaces added before and after\n\t     * c.f. http:\/\/www.w3.org\/TR\/REC-xml#as-PE\n\t     *\/\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n if (xmlPushInput(ctxt, input) < 0)\n return;\n if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n (IS_BLANK_CH(NXT(5)))) {\n\t\txmlParseTextDecl(ctxt);\n if (ctxt->errNo ==\n\t\t    XML_ERR_UNSUPPORTED_ENCODING) {\n \/*\n\t\t     * The XML REC instructs us to stop parsing\n\t\t     * right here\n\t\t     *\/\n\t\t    xmlHaltParser(ctxt);\n return;\n }\n }\n }\n }\n    ctxt->hasPErefs = 1;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static X509 * php_openssl_x509_from_zval(zval ** val, int makeresource, long * resourceval TSRMLS_DC)\n{\n\tX509 *cert = NULL;\n\n\tif (resourceval) {\n\t\t*resourceval = -1;\n\t}\n\tif (Z_TYPE_PP(val) == IS_RESOURCE) {\n\t\t\/* is it an x509 resource ? *\/\n\t\tvoid * what;\n\t\tint type;\n\n\t\twhat = zend_fetch_resource(val TSRMLS_CC, -1, \"OpenSSL X.509\", &type, 1, le_x509);\n\t\tif (!what) {\n\t\t\treturn NULL;\n\t\t}\n\t\t\/* this is so callers can decide if they should free the X509 *\/\n\t\tif (resourceval) {\n\t\t\t*resourceval = Z_LVAL_PP(val);\n\t\t}\n\t\tif (type == le_x509) {\n\t\t\treturn (X509*)what;\n\t\t}\n\t\t\/* other types could be used here - eg: file pointers and read in the data from them *\/\n\n\t\treturn NULL;\n\t}\n\n\tif (!(Z_TYPE_PP(val) == IS_STRING || Z_TYPE_PP(val) == IS_OBJECT)) {\n\t\treturn NULL;\n\t}\n\n\t\/* force it to be a string and check if it refers to a file *\/\n\tconvert_to_string_ex(val);\n\n\tif (Z_STRLEN_PP(val) > 7 && memcmp(Z_STRVAL_PP(val), \"file:\/\/\", sizeof(\"file:\/\/\") - 1) == 0) {\n\t\t\/* read cert from the named file *\/\n\t\tBIO *in;\n\n\t\tif (php_openssl_safe_mode_chk(Z_STRVAL_PP(val) + (sizeof(\"file:\/\/\") - 1) TSRMLS_CC)) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tin = BIO_new_file(Z_STRVAL_PP(val) + (sizeof(\"file:\/\/\") - 1), \"r\");\n\t\tif (in == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcert = PEM_read_bio_X509(in, NULL, NULL, NULL);\n\t\tBIO_free(in);\n\t} else {\n\t\tBIO *in;\n\n\t\tin = BIO_new_mem_buf(Z_STRVAL_PP(val), Z_STRLEN_PP(val));\n\t\tif (in == NULL) {\n\t\t\treturn NULL;\n\t\t}\n#ifdef TYPEDEF_D2I_OF\n\t\tcert = (X509 *) PEM_ASN1_read_bio((d2i_of_void *)d2i_X509, PEM_STRING_X509, in, NULL, NULL, NULL);\n#else\n\t\tcert = (X509 *) PEM_ASN1_read_bio((char *(*)())d2i_X509, PEM_STRING_X509, in, NULL, NULL, NULL);\n#endif\n\t\tBIO_free(in);\n\t}\n\n\tif (cert && makeresource && resourceval) {\n\t\t*resourceval = zend_list_insert(cert, le_x509);\n\t}\n\treturn cert;\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const SegmentInfo* Segment::GetInfo() const\n{\n    return m_pInfo;\n }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_SC_shade(fz_context *ctx, pdf_processor *proc, const char *name, fz_shade *shade)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpr->dev->flags &= ~FZ_DEVFLAG_STROKECOLOR_UNDEFINED;\n\tpdf_set_shade(ctx, pr, PDF_STROKE, shade);\n}\n","project":"ghostscript","target":0},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"void acl_mask_perm_str(acl_t acl, char *str)\n{\n\tacl_entry_t entry;\n\n\tstr[0] = '\\0';\n\tif (acl_get_entry(acl, ACL_FIRST_ENTRY, &entry) != 1)\n\t\treturn;\n\tfor(;;) {\n\t\tacl_tag_t tag;\n\n\t\tacl_get_tag_type(entry, &tag);\n\t\tif (tag == ACL_MASK) {\n\t\t\tacl_perm_str(entry, str);\n\t\t\treturn;\n\t\t}\n\t\tif (acl_get_entry(acl, ACL_NEXT_ENTRY, &entry) != 1)\n\t\t\treturn;\n\t}\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_device_cmyk(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn fz_colorspace_is_device(ctx, cs) && fz_colorspace_is_cmyk(ctx, cs);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_colorspace *fz_colorspace_base(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && cs->get_base ? cs->get_base(cs) : NULL;\n}\n","project":"ghostscript","target":0},{"commit_id":"24d7c408c52143bce7b49de82f3913fd8d1219cf","func":"void WT_VoiceFilter (S_FILTER_CONTROL *pFilter, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pAudioBuffer;\n    EAS_I32 k;\n    EAS_I32 b1;\n    EAS_I32 b2;\n    EAS_I32 z1;\n    EAS_I32 z2;\n    EAS_I32 acc0;\n    EAS_I32 acc1;\n    EAS_I32 numSamples;\n\n \/* initialize some local variables *\/\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b\/26366256\");\n         return;\n     }\n     pAudioBuffer = pWTIntFrame->pAudioBuffer;\n\n    z1 = pFilter->z1;\n    z2 = pFilter->z2;\n    b1 = -pWTIntFrame->frame.b1;\n\n \/*lint -e{702} <avoid divide> *\/\n    b2 = -pWTIntFrame->frame.b2 >> 1;\n\n \/*lint -e{702} <avoid divide> *\/\n    k = pWTIntFrame->frame.k >> 1;\n\n while (numSamples--)\n {\n\n \/* do filter calculations *\/\n        acc0 = *pAudioBuffer;\n        acc1 = z1 * b1;\n        acc1 += z2 * b2;\n        acc0 = acc1 + k * acc0;\n        z2 = z1;\n\n \/*lint -e{702} <avoid divide> *\/\n        z1 = acc0 >> 14;\n *pAudioBuffer++ = (EAS_I16) z1;\n }\n\n \/* save delay values     *\/\n    pFilter->z1 = (EAS_I16) z1;\n    pFilter->z2 = (EAS_I16) z2;\n}\n","project":"Android","target":1},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"static void timelib_eat_spaces(char **ptr)\n{\n\twhile (**ptr == ' ' || **ptr == '\\t') {\n\t\t++*ptr;\n\t}\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_keep_colorspace_store_key(fz_context *ctx, fz_colorspace *cs)\n{\n\treturn fz_keep_key_storable_key(ctx, &cs->key_storable);\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_keep_gstate(fz_context *ctx, pdf_gstate *gs)\n{\n\tpdf_keep_material(ctx, &gs->stroke);\n\tpdf_keep_material(ctx, &gs->fill);\n\tif (gs->text.font)\n\t\tpdf_keep_font(ctx, gs->text.font);\n\tif (gs->softmask)\n\t\tpdf_keep_xobject(ctx, gs->softmask);\n\tif (gs->softmask_resources)\n\t\tpdf_keep_obj(ctx, gs->softmask_resources);\n\tfz_keep_stroke_state(ctx, gs->stroke_state);\n}\n","project":"ghostscript","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_open_archive_fp(phar_archive_data *phar TSRMLS_DC) \/* {{{ *\/\n{\n\tif (phar_get_pharfp(phar TSRMLS_CC)) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (php_check_open_basedir(phar->fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tphar_set_pharfp(phar, php_stream_open_wrapper(phar->fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|0, NULL) TSRMLS_CC);\n\n\tif (!phar_get_pharfp(phar TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"     void CopyToOMX(const OMX_BUFFERHEADERTYPE *header) {\n        if (!mIsBackup) {\n             return;\n         }\n \n        memcpy(header->pBuffer + header->nOffset,\n (const OMX_U8 *)mMem->pointer() + header->nOffset,\n                header->nFilledLen);\n }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"static int phar_dir_close(php_stream *stream, int close_handle TSRMLS_DC)  \/* {{{ *\/\n{\n\tHashTable *data = (HashTable *)stream->abstract;\n\n\tif (data && data->arBuckets) {\n\t\tzend_hash_destroy(data);\n\t\tdata->arBuckets = 0;\n\t\tFREE_HASHTABLE(data);\n\t\tstream->abstract = NULL;\n\t}\n\n\treturn 0;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static EVP_PKEY * php_openssl_evp_from_zval(zval ** val, int public_key, char * passphrase, int makeresource, long * resourceval TSRMLS_DC)\n{\n\tEVP_PKEY * key = NULL;\n\tX509 * cert = NULL;\n\tint free_cert = 0;\n\tlong cert_res = -1;\n\tchar * filename = NULL;\n\tzval tmp;\n\n\tZ_TYPE(tmp) = IS_NULL;\n\n#define TMP_CLEAN \\\n\tif (Z_TYPE(tmp) == IS_STRING) {\\\n\t\tzval_dtor(&tmp); \\\n\t} \\\n\treturn NULL;\n\n\tif (resourceval) {\n\t\t*resourceval = -1;\n\t}\n\tif (Z_TYPE_PP(val) == IS_ARRAY) {\n\t\tzval ** zphrase;\n\t\t\n\t\t\/* get passphrase *\/\n\n\t\tif (zend_hash_index_find(HASH_OF(*val), 1, (void **)&zphrase) == FAILURE) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key array must be of the form array(0 => key, 1 => phrase)\");\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tif (Z_TYPE_PP(zphrase) == IS_STRING) {\n\t\t\tpassphrase = Z_STRVAL_PP(zphrase);\n\t\t} else {\n\t\t\ttmp = **zphrase;\n\t\t\tzval_copy_ctor(&tmp);\n\t\t\tconvert_to_string(&tmp);\n\t\t\tpassphrase = Z_STRVAL(tmp);\n\t\t}\n\n\t\t\/* now set val to be the key param and continue *\/\n\t\tif (zend_hash_index_find(HASH_OF(*val), 0, (void **)&val) == FAILURE) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key array must be of the form array(0 => key, 1 => phrase)\");\n\t\t\tTMP_CLEAN;\n\t\t}\n\t}\n\n\tif (Z_TYPE_PP(val) == IS_RESOURCE) {\n\t\tvoid * what;\n\t\tint type;\n\n\t\twhat = zend_fetch_resource(val TSRMLS_CC, -1, \"OpenSSL X.509\/key\", &type, 2, le_x509, le_key);\n\t\tif (!what) {\n\t\t\tTMP_CLEAN;\n\t\t}\n\t\tif (resourceval) { \n\t\t\t*resourceval = Z_LVAL_PP(val);\n\t\t}\n\t\tif (type == le_x509) {\n\t\t\t\/* extract key from cert, depending on public_key param *\/\n\t\t\tcert = (X509*)what;\n\t\t\tfree_cert = 0;\n\t\t} else if (type == le_key) {\n\t\t\tint is_priv;\n\n\t\t\tis_priv = php_openssl_is_private_key((EVP_PKEY*)what TSRMLS_CC);\n\n\t\t\t\/* check whether it is actually a private key if requested *\/\n\t\t\tif (!public_key && !is_priv) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"supplied key param is a public key\");\n\t\t\t\tTMP_CLEAN;\n\t\t\t}\n\n\t\t\tif (public_key && is_priv) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Don't know how to get public key from this private key\");\n\t\t\t\tTMP_CLEAN;\n\t\t\t} else {\n\t\t\t\tif (Z_TYPE(tmp) == IS_STRING) {\n\t\t\t\t\tzval_dtor(&tmp);\n\t\t\t\t}\n\t\t\t\t\/* got the key - return it *\/\n\t\t\t\treturn (EVP_PKEY*)what;\n\t\t\t}\n\t\t} else {\n\t\t\t\/* other types could be used here - eg: file pointers and read in the data from them *\/\n\t\t\tTMP_CLEAN;\n\t\t}\n\t} else {\n\t\t\/* force it to be a string and check if it refers to a file *\/\n\t\t\/* passing non string values leaks, object uses toString, it returns NULL \n\t\t * See bug38255.phpt \n\t\t *\/\n\t\tif (!(Z_TYPE_PP(val) == IS_STRING || Z_TYPE_PP(val) == IS_OBJECT)) {\n\t\t\tTMP_CLEAN;\n\t\t}\n\t\tconvert_to_string_ex(val);\n\n\t\tif (Z_STRLEN_PP(val) > 7 && memcmp(Z_STRVAL_PP(val), \"file:\/\/\", sizeof(\"file:\/\/\") - 1) == 0) {\n\t\t\tfilename = Z_STRVAL_PP(val) + (sizeof(\"file:\/\/\") - 1);\n\t\t}\n\t\t\/* it's an X509 file\/cert of some kind, and we need to extract the data from that *\/\n\t\tif (public_key) {\n\t\t\tcert = php_openssl_x509_from_zval(val, 0, &cert_res TSRMLS_CC);\n\t\t\tfree_cert = (cert_res == -1);\n\t\t\t\/* actual extraction done later *\/\n\t\t\tif (!cert) {\n\t\t\t\t\/* not a X509 certificate, try to retrieve public key *\/\n\t\t\t\tBIO* in;\n\t\t\t\tif (filename) {\n\t\t\t\t\tin = BIO_new_file(filename, \"r\");\n\t\t\t\t} else {\n\t\t\t\t\tin = BIO_new_mem_buf(Z_STRVAL_PP(val), Z_STRLEN_PP(val));\n\t\t\t\t}\n\t\t\t\tif (in == NULL) {\n\t\t\t\t\tTMP_CLEAN;\n\t\t\t\t}\n\t\t\t\tkey = PEM_read_bio_PUBKEY(in, NULL,NULL, NULL);\n\t\t\t\tBIO_free(in);\n\t\t\t}\n\t\t} else {\n\t\t\t\/* we want the private key *\/\n\t\t\tBIO *in;\n\n\t\t\tif (filename) {\n\t\t\t\tif (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {\n\t\t\t\t\tTMP_CLEAN;\n\t\t\t\t}\n\t\t\t\tin = BIO_new_file(filename, \"r\");\n\t\t\t} else {\n\t\t\t\tin = BIO_new_mem_buf(Z_STRVAL_PP(val), Z_STRLEN_PP(val));\n\t\t\t}\n\n\t\t\tif (in == NULL) {\n\t\t\t\tTMP_CLEAN;\n\t\t\t}\n\t\t\tkey = PEM_read_bio_PrivateKey(in, NULL,NULL, passphrase);\n\t\t\tBIO_free(in);\n\t\t}\n\t}\n\n\tif (public_key && cert && key == NULL) {\n\t\t\/* extract public key from X509 cert *\/\n\t\tkey = (EVP_PKEY *) X509_get_pubkey(cert);\n\t}\n\n\tif (free_cert && cert) {\n\t\tX509_free(cert);\n\t}\n\tif (key && makeresource && resourceval) {\n\t\t*resourceval = ZEND_REGISTER_RESOURCE(NULL, key, le_key);\n\t}\n\tif (Z_TYPE(tmp) == IS_STRING) {\n\t\tzval_dtor(&tmp);\n\t}\n\treturn key;\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::GetEntryCount() const\n{\n    return m_entries_count;\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static int pcre_clean_cache(void *data, void *arg TSRMLS_DC)\n{\n\tint *num_clean = (int *)arg;\n\n\tif (*num_clean > 0) {\n\t\t(*num_clean)--;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_community (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;  \n  const bgp_size_t length = args->length;\n  \n  if (length == 0)\n    {\n      attr->community = NULL;\n      return BGP_ATTR_PARSE_PROCEED;\n    }\n  \n  attr->community =\n    community_parse ((u_int32_t *)stream_pnt (peer->ibuf), length);\n  \n  \/* XXX: fix community_parse to use stream API and remove this *\/\n  stream_forward_getp (peer->ibuf, length);\n\n  if (!attr->community)\n    return bgp_attr_malformed (args,\n                               BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n                               args->total);\n  \n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"inline static int php_openssl_safe_mode_chk(char *filename TSRMLS_DC)\n{\n\tif (PG(safe_mode) && (!php_checkuid(filename, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\treturn -1;\n\t}\n\tif (php_check_open_basedir(filename TSRMLS_CC)) {\n\t\treturn -1;\n\t}\n\t\n\treturn 0;\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n ::libvpx_test::Encoder *encoder) {\n\n     if (video->frame() == 1) {\n       encoder->Control(VP8E_SET_CPUUSED, cpu_used_);\n     } else if (video->frame() == 3) {\n      vpx_active_map_t map = {0};\n       uint8_t active_map[9 * 13] = {\n         1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n         1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0,\n 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1,\n 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1,\n 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1,\n 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1,\n 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0,\n };\n map.cols = (kWidth + 15) \/ 16;\n map.rows = (kHeight + 15) \/ 16;\n      ASSERT_EQ(map.cols, 13u);\n      ASSERT_EQ(map.rows, 9u);\n\n       map.active_map = active_map;\n       encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n     } else if (video->frame() == 15) {\n      vpx_active_map_t map = {0};\n       map.cols = (kWidth + 15) \/ 16;\n       map.rows = (kHeight + 15) \/ 16;\n       map.active_map = NULL;\n      encoder->Control(VP8E_SET_ACTIVEMAP, &map);\n }\n }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_Bstar(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_path(ctx, pr, 0, 1, 1, 1);\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_Td(fz_context *ctx, pdf_processor *proc, float tx, float ty)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_tos_translate(&pr->tos, tx, ty);\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int passwd_callback(char *buf, int num, int verify, void *data) \/* {{{ *\/\n{\n    php_stream *stream = (php_stream *)data;\n    zval **val = NULL;\n    char *passphrase = NULL;\n    \/* TODO: could expand this to make a callback into PHP user-space *\/\n\n    GET_VER_OPT_STRING(\"passphrase\", passphrase);\n\n    if (passphrase) {\n        if (Z_STRLEN_PP(val) < num - 1) {\n            memcpy(buf, Z_STRVAL_PP(val), Z_STRLEN_PP(val)+1);\n            return Z_STRLEN_PP(val);\n        }\n    }\n    return 0;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftMPEG4Encoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n int32_t indexFull = index;\n\n switch (indexFull) {\n case OMX_IndexParamVideoBitrate:\n {\n\n             OMX_VIDEO_PARAM_BITRATETYPE *bitRate =\n                 (OMX_VIDEO_PARAM_BITRATETYPE *) params;\n \n             if (bitRate->nPortIndex != 1 ||\n                 bitRate->eControlRate != OMX_Video_ControlRateVariable) {\n                 return OMX_ErrorUndefined;\n }\n\n            mBitrate = bitRate->nTargetBitrate;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoH263:\n {\n\n             OMX_VIDEO_PARAM_H263TYPE *h263type =\n                 (OMX_VIDEO_PARAM_H263TYPE *)params;\n \n             if (h263type->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (h263type->eProfile != OMX_VIDEO_H263ProfileBaseline ||\n                h263type->eLevel != OMX_VIDEO_H263Level45 ||\n (h263type->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) ||\n                h263type->bPLUSPTYPEAllowed != OMX_FALSE ||\n                h263type->bForceRoundingTypeToZero != OMX_FALSE ||\n                h263type->nPictureHeaderRepetition != 0 ||\n                h263type->nGOBHeaderInterval != 0) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoMpeg4:\n {\n\n             OMX_VIDEO_PARAM_MPEG4TYPE *mpeg4type =\n                 (OMX_VIDEO_PARAM_MPEG4TYPE *)params;\n \n             if (mpeg4type->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (mpeg4type->eProfile != OMX_VIDEO_MPEG4ProfileCore ||\n                mpeg4type->eLevel != OMX_VIDEO_MPEG4Level2 ||\n (mpeg4type->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) ||\n                mpeg4type->nBFrames != 0 ||\n                mpeg4type->nIDCVLCThreshold != 0 ||\n                mpeg4type->bACPred != OMX_TRUE ||\n                mpeg4type->nMaxPacketSize != 256 ||\n                mpeg4type->nTimeIncRes != 1000 ||\n                mpeg4type->nHeaderExtension != 0 ||\n                mpeg4type->bReversibleVLC != OMX_FALSE) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_default_set (struct attr *attr, u_char origin)\n{\n  memset (attr, 0, sizeof (struct attr));\n  bgp_attr_extra_get (attr);\n  \n  attr->origin = origin;\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);\n  attr->aspath = aspath_empty ();\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);\n  attr->extra->weight = BGP_ATTR_DEFAULT_WEIGHT;\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);\n#ifdef HAVE_IPV6\n  attr->extra->mp_nexthop_len = IPV6_MAX_BYTELEN;\n#endif\n\n  return attr;\n}\n","project":"savannah","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_get_cipher_methods)\n{\n\tzend_bool aliases = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &aliases) == FAILURE) {\n\t\treturn;\n\t}\n\tarray_init(return_value);\n\tOBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_CIPHER_METH,\n\t\taliases ? openssl_add_method_or_alias: openssl_add_method, \n\t\treturn_value);\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void TearDown() {\n    delete[] src_;\n    delete[] ref_;\n     libvpx_test::ClearSystemState();\n   }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkey_get_private)\n{\n\tzval **cert;\n\tEVP_PKEY *pkey;\n\tchar * passphrase = \"\";\n\tint passphrase_len = sizeof(\"\")-1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z|s\", &cert, &passphrase, &passphrase_len) == FAILURE) {\n\t\treturn;\n\t}\n\tZ_TYPE_P(return_value) = IS_RESOURCE;\n\tpkey = php_openssl_evp_from_zval(cert, 0, passphrase, 1, &Z_LVAL_P(return_value) TSRMLS_CC);\n\n\tif (pkey == NULL) {\n\t\tRETURN_FALSE;\n\t}\n}\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_nexthop (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  in_addr_t nexthop_h, nexthop_n;\n\n  \/* Check nexthop attribute length. *\/\n  if (length != 4)\n    {\n      zlog (peer->log, LOG_ERR, \"Nexthop attribute length isn't four [%d]\",\n\t      length);\n\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n\n  \/* According to section 6.3 of RFC4271, syntactically incorrect NEXT_HOP\n     attribute must result in a NOTIFICATION message (this is implemented below).\n     At the same time, semantically incorrect NEXT_HOP is more likely to be just\n     logged locally (this is implemented somewhere else). The UPDATE message\n     gets ignored in any of these cases. *\/\n  nexthop_n = stream_get_ipv4 (peer->ibuf);\n  nexthop_h = ntohl (nexthop_n);\n  if (IPV4_NET0 (nexthop_h) || IPV4_NET127 (nexthop_h) || IPV4_CLASS_DE (nexthop_h))\n    {\n      char buf[INET_ADDRSTRLEN];\n      inet_ntop (AF_INET, &nexthop_h, buf, INET_ADDRSTRLEN);\n      zlog (peer->log, LOG_ERR, \"Martian nexthop %s\", buf);\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP,\n                                 args->total);\n    }\n\n  attr->nexthop.s_addr = nexthop_n;\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_add_entry_callback(struct ldb_request *req,\n\t\t\t\t\tstruct ldb_reply *ares)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\tif (ares->type == LDB_REPLY_REFERRAL) {\n\t\treturn ldb_module_send_referral(ac->req, ares->referral);\n\t}\n\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\tif (ares->type != LDB_REPLY_DONE) {\n\t\tldb_asprintf_errstring(ldb, \"Invalid LDB reply type %d\", ares->type);\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\t\/* The caller may wish to get controls back from the add *\/\n\tac->ares = talloc_steal(ac, ares);\n\n\tret = samldb_next_step(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, ret);\n\t}\n\treturn ret;\n}\n","project":"samba","target":0},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"int do_show(FILE *stream, const char *path_p, const struct stat *st,\n            acl_t acl, acl_t dacl)\n{\n\tstruct name_list *acl_names = get_list(st, acl),\n\t                 *first_acl_name = acl_names;\n\tstruct name_list *dacl_names = get_list(st, dacl),\n\t                 *first_dacl_name = dacl_names;\n\t\n\tint acl_names_width = max_name_length(acl_names);\n\tint dacl_names_width = max_name_length(dacl_names);\n\tacl_entry_t acl_ent;\n\tacl_entry_t dacl_ent;\n\tchar acl_mask[ACL_PERMS+1], dacl_mask[ACL_PERMS+1];\n\tint ret;\n\n\tnames_width = 8;\n\tif (acl_names_width > names_width)\n\t\tnames_width = acl_names_width;\n\tif (dacl_names_width > names_width)\n\t\tnames_width = dacl_names_width;\n\n\tacl_mask[0] = '\\0';\n\tif (acl) {\n\t\tacl_mask_perm_str(acl, acl_mask);\n\t\tret = acl_get_entry(acl, ACL_FIRST_ENTRY, &acl_ent);\n\t\tif (ret == 0)\n\t\t\tacl = NULL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tdacl_mask[0] = '\\0';\n\tif (dacl) {\n\t\tacl_mask_perm_str(dacl, dacl_mask);\n\t\tret = acl_get_entry(dacl, ACL_FIRST_ENTRY, &dacl_ent);\n\t\tif (ret == 0)\n\t\t\tdacl = NULL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tfprintf(stream, \"# file: %s\\n\", xquote(path_p, \"\\n\\r\"));\n\twhile (acl_names != NULL || dacl_names != NULL) {\n\t\tacl_tag_t acl_tag, dacl_tag;\n\n\t\tif (acl)\n\t\t\tacl_get_tag_type(acl_ent, &acl_tag);\n\t\tif (dacl)\n\t\t\tacl_get_tag_type(dacl_ent, &dacl_tag);\n\n\t\tif (acl && (!dacl || acl_tag < dacl_tag)) {\n\t\t\tshow_line(stream, &acl_names, acl, &acl_ent, acl_mask,\n\t\t\t          NULL, NULL, NULL, NULL);\n\t\t\tcontinue;\n\t\t} else if (dacl && (!acl || dacl_tag < acl_tag)) {\n\t\t\tshow_line(stream, NULL, NULL, NULL, NULL,\n\t\t\t          &dacl_names, dacl, &dacl_ent, dacl_mask);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (acl_tag == ACL_USER || acl_tag == ACL_GROUP) {\n\t\t\t\tid_t  *acl_id_p = NULL, *dacl_id_p = NULL;\n\t\t\t\tif (acl_ent)\n\t\t\t\t\tacl_id_p = acl_get_qualifier(acl_ent);\n\t\t\t\tif (dacl_ent)\n\t\t\t\t\tdacl_id_p = acl_get_qualifier(dacl_ent);\n\t\t\t\t\n\t\t\t\tif (acl && (!dacl || *acl_id_p < *dacl_id_p)) {\n\t\t\t\t\tshow_line(stream, &acl_names, acl,\n\t\t\t\t\t          &acl_ent, acl_mask,\n\t\t\t\t\t\t  NULL, NULL, NULL, NULL);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (dacl &&\n\t\t\t\t\t(!acl || *dacl_id_p < *acl_id_p)) {\n\t\t\t\t\tshow_line(stream, NULL, NULL, NULL,\n\t\t\t\t\t          NULL, &dacl_names, dacl,\n\t\t\t\t\t\t  &dacl_ent, dacl_mask);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshow_line(stream, &acl_names,  acl,  &acl_ent, acl_mask,\n\t\t\t\t  &dacl_names, dacl, &dacl_ent, dacl_mask);\n\t\t}\n\t}\n\n\tfree_list(first_acl_name);\n\tfree_list(first_dacl_name);\n\n\treturn 0;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static inline float fung(float x)\n{\n\tif (x >= 6.0f \/ 29.0f)\n\t\treturn x * x * x;\n\treturn (108.0f \/ 841.0f) * (x - (4.0f \/ 29.0f));\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"transit_unintern (struct transit *transit)\n{\n  if (transit->refcnt)\n    transit->refcnt--;\n\n  if (transit->refcnt == 0)\n    {\n      hash_release (transit_hash, transit);\n      transit_free (transit);\n    }\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Tracks* Segment::GetTracks() const\n{\n    return m_pTracks;\n }\n","project":"Android","target":1},{"commit_id":"2c75e1c3b98e4e94f50c63e2b7694be5f948477c","func":"status_t OMXNodeInstance::useBuffer(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b\/25884056\");\n return BAD_VALUE;\n }\n\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {\n return BAD_VALUE;\n }\n\n BufferMeta *buffer_meta;\n bool useBackup = mMetadataType[portIndex] != kMetadataBufferTypeInvalid;\n    OMX_U8 *data = static_cast<OMX_U8 *>(params->pointer());\n if (useBackup) {\n        data = new (std::nothrow) OMX_U8[allottedSize];\n if (data == NULL) {\n return NO_MEMORY;\n }\n        memset(data, 0, allottedSize);\n\n if (allottedSize != params->size()) {\n            CLOG_ERROR(useBuffer, BAD_VALUE, SIMPLE_BUFFER(portIndex, (size_t)allottedSize, data));\n delete[] data;\n return BAD_VALUE;\n }\n\n        buffer_meta = new BufferMeta(\n\n                 params, portIndex, false \/* copyToOmx *\/, false \/* copyFromOmx *\/, data);\n     } else {\n         buffer_meta = new BufferMeta(\n                params, portIndex, false \/* copyFromOmx *\/, false \/* copyToOmx *\/, NULL);\n     }\n \n     OMX_BUFFERHEADERTYPE *header;\n\n    OMX_ERRORTYPE err = OMX_UseBuffer(\n            mHandle, &header, portIndex, buffer_meta,\n            allottedSize, data);\n\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(\n                portIndex, (size_t)allottedSize, data));\n\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, buffer_meta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u(%zu)@%p\", allottedSize, params->size(), params->pointer()));\n return OK;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int php_openssl_write_rand_file(const char * file, int egdsocket, int seeded) \/* {{{ *\/\n{\n\tchar buffer[MAXPATHLEN];\n\n\tTSRMLS_FETCH();\n\n\tif (egdsocket || !seeded) {\n\t\t\/* if we did not manage to read the seed file, we should not write\n\t\t * a low-entropy seed file back *\/\n\t\treturn FAILURE;\n\t}\n\tif (file == NULL) {\n\t\tfile = RAND_file_name(buffer, sizeof(buffer));\n\t}\n\tif (file == NULL || !RAND_write_file(file)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"unable to write random state\");\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy,\n          bool recursive, bool glob)\n{\n  ccon con;                     \/* FTP connection *\/\n  uerr_t res;\n\n  *dt = 0;\n\n  xzero (con);\n\n  con.csock = -1;\n  con.st = ON_YOUR_OWN;\n  con.rs = ST_UNIX;\n  con.id = NULL;\n  con.proxy = proxy;\n\n  \/* If the file name is empty, the user probably wants a directory\n     index.  We'll provide one, properly HTML-ized.  Unless\n     opt.htmlify is 0, of course.  :-) *\/\n  if (!*u->file && !recursive)\n    {\n      struct fileinfo *f;\n      res = ftp_get_listing (u, &con, &f);\n\n      if (res == RETROK)\n        {\n          if (opt.htmlify && !opt.spider)\n            {\n              char *filename = (opt.output_document\n                                ? xstrdup (opt.output_document)\n                                : (con.target ? xstrdup (con.target)\n                                   : url_file_name (u, NULL)));\n              res = ftp_index (filename, u, f);\n              if (res == FTPOK && opt.verbose)\n                {\n                  if (!opt.output_document)\n                    {\n                      struct_stat st;\n                      wgint sz;\n                      if (stat (filename, &st) == 0)\n                        sz = st.st_size;\n                      else\n                        sz = -1;\n                      logprintf (LOG_NOTQUIET,\n                                 _(\"Wrote HTML-ized index to %s [%s].\\n\"),\n                                 quote (filename), number_to_static_string (sz));\n                    }\n                  else\n                    logprintf (LOG_NOTQUIET,\n                               _(\"Wrote HTML-ized index to %s.\\n\"),\n                               quote (filename));\n                }\n              xfree (filename);\n            }\n          freefileinfo (f);\n        }\n    }\n  else\n    {\n      bool ispattern = false;\n      if (glob)\n        {\n          \/* Treat the URL as a pattern if the file name part of the\n             URL path contains wildcards.  (Don't check for u->file\n             because it is unescaped and therefore doesn't leave users\n             the option to escape literal '*' as %2A.)  *\/\n          char *file_part = strrchr (u->path, '\/');\n          if (!file_part)\n            file_part = u->path;\n          ispattern = has_wildcards_p (file_part);\n        }\n      if (ispattern || recursive || opt.timestamping || opt.preserve_perm)\n        {\n          \/* ftp_retrieve_glob is a catch-all function that gets called\n             if we need globbing, time-stamping, recursion or preserve\n             permissions.  Its third argument is just what we really need.  *\/\n          res = ftp_retrieve_glob (u, &con,\n                                   ispattern ? GLOB_GLOBALL : GLOB_GETONE);\n        }\n      else\n        res = ftp_loop_internal (u, NULL, &con, local_file, false);\n    }\n  if (res == FTPOK)\n    res = RETROK;\n  if (res == RETROK)\n    *dt |= RETROKF;\n  \/* If a connection was left, quench it.  *\/\n  if (con.csock != -1)\n    fd_close (con.csock);\n  xfree (con.id);\n  xfree (con.target);\n  return res;\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Chapters::Display::~Display()\n{\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* Chapters::Display::GetLanguage() const\n{\n    return m_language;\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_drop_material(fz_context *ctx, pdf_material *mat)\n{\n\tfz_drop_colorspace(ctx, mat->colorspace);\n\tpdf_drop_pattern(ctx, mat->pattern);\n\tfz_drop_shade(ctx, mat->shade);\n\treturn mat;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void RunCoeffCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 5000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j)\n        input_block[j] = rnd.Rand8() - rnd.Rand8();\n \n       fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);\n      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j)\n        EXPECT_EQ(output_block[j], output_ref_block[j]);\n }\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long ContentEncoding::ParseContentEncodingEntry(long long start,\n                                                long long size,\n                                                 IMkvReader* pReader) {\n   assert(pReader);\n \n long long pos = start;\n const long long stop = start + size;\n\n int compression_count = 0;\n int encryption_count = 0;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  \/\/error\n       return status;\n \n     if (id == 0x1034)  \/\/ ContentCompression ID\n ++compression_count;\n\n\n     if (id == 0x1035)  \/\/ ContentEncryption ID\n       ++encryption_count;\n \n    pos += size;  \/\/consume payload\n     assert(pos <= stop);\n   }\n \n if (compression_count <= 0 && encryption_count <= 0)\n return -1;\n\n \n   if (compression_count > 0) {\n     compression_entries_ =\n        new (std::nothrow) ContentCompression*[compression_count];\n     if (!compression_entries_)\n       return -1;\n     compression_entries_end_ = compression_entries_;\n }\n\n \n   if (encryption_count > 0) {\n     encryption_entries_ =\n        new (std::nothrow) ContentEncryption*[encryption_count];\n     if (!encryption_entries_) {\n      delete [] compression_entries_;\n       return -1;\n     }\n     encryption_entries_end_ = encryption_entries_;\n }\n\n\n   pos = start;\n   while (pos < stop) {\n     long long id, size;\n    long status = ParseElementHeader(pReader,\n                                     pos,\n                                     stop,\n                                     id,\n                                     size);\n    if (status < 0)  \/\/error\n       return status;\n \n     if (id == 0x1031) {\n      encoding_order_ = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x1032) {\n      encoding_scope_ = UnserializeUInt(pReader, pos, size);\n if (encoding_scope_ < 1)\n return -1;\n } else if (id == 0x1033) {\n      encoding_type_ = UnserializeUInt(pReader, pos, size);\n\n     } else if (id == 0x1034) {\n       ContentCompression* const compression =\n        new (std::nothrow) ContentCompression();\n       if (!compression)\n         return -1;\n \n      status = ParseCompressionEntry(pos, size, pReader, compression);\n if (status) {\n delete compression;\n return status;\n }\n *compression_entries_end_++ = compression;\n } else if (id == 0x1035) {\n ContentEncryption* const encryption =\n new (std::nothrow) ContentEncryption();\n if (!encryption)\n return -1;\n\n      status = ParseEncryptionEntry(pos, size, pReader, encryption);\n if (status) {\n delete encryption;\n return status;\n }\n\n       *encryption_entries_end_++ = encryption;\n     }\n \n    pos += size;  \/\/consume payload\n     assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n\n   return 0;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"int Block::GetFrameCount() const\n{\n    return m_frame_count;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_cmm_fin_profile(fz_context *ctx, fz_iccprofile *profile)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tif (profile && profile->cmm_handle != NULL)\n\t\t\tctx->colorspace->cmm->fin_profile(ctx->cmm_instance, profile);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::Load(long long& pos, long& len) const\n{\n    assert(m_pSegment);\n    assert(m_pos >= m_element_start);\n \n    if (m_timecode >= 0)  \/\/at least partially loaded\n        return 0;\n \n    assert(m_pos == m_element_start);\n    assert(m_element_size < 0);\n \n    IMkvReader* const pReader = m_pSegment->m_pReader;\n \n    long long total, avail;\n \n    const int status = pReader->Length(&total, &avail);\n \n    if (status < 0)  \/\/error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n    assert((total < 0) || (m_pos <= total));  \/\/TODO: verify this\n \n    pos = m_pos;\n \n    long long cluster_size = -1;\n    {\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  \/\/error or underflow\n            return static_cast<long>(result);\n        if (result > 0)  \/\/underflow (weird)\n            return E_BUFFER_NOT_FULL;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id_ = ReadUInt(pReader, pos, len);\n        if (id_ < 0)  \/\/error\n            return static_cast<long>(id_);\n        if (id_ != 0x0F43B675)  \/\/Cluster ID\n            return E_FILE_FORMAT_INVALID;\n        pos += len;  \/\/consume id\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  \/\/error\n            return static_cast<long>(cluster_size);\n        if (size == 0)\n            return E_FILE_FORMAT_INVALID;  \/\/TODO: verify this\n        pos += len;  \/\/consume length of size of element\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size != unknown_size)\n            cluster_size = size;\n     }\n \n\/\/\/\/ pos points to start of payload\n \n #if 0\n     len = static_cast<long>(size_);\n\n if (cluster_stop > avail)\n\n         return E_BUFFER_NOT_FULL;\n #endif\n \n    long long timecode = -1;\n    long long new_pos = -1;\n    bool bBlock = false;\n \n    long long cluster_stop = (cluster_size < 0) ? -1 : pos + cluster_size;\n \n    for (;;)\n    {\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            break;\n \n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0) \/\/error\n            return static_cast<long>(id);\n        if (id == 0)\n            return E_FILE_FORMAT_INVALID;\n        if (id == 0x0F43B675)  \/\/Cluster ID\n            break;\n        if (id == 0x0C53BB6B)  \/\/Cues ID\n            break;\n        pos += len;  \/\/consume ID field\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  \/\/error\n            return static_cast<long>(size);\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;\n        pos += len;  \/\/consume size field\n        if ((cluster_stop >= 0) && (pos > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (size == 0)  \/\/weird\n            continue;\n        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (id == 0x67)  \/\/TimeCode ID\n        {\n            len = static_cast<long>(size);\n            if ((pos + size) > avail)\n                return E_BUFFER_NOT_FULL;\n            timecode = UnserializeUInt(pReader, pos, size);\n            if (timecode < 0)  \/\/error (or underflow)\n                return static_cast<long>(timecode);\n            new_pos = pos + size;\n            if (bBlock)\n                break;\n        }\n        else if (id == 0x20)  \/\/BlockGroup ID\n        {\n            bBlock = true;\n            break;\n        }\n        else if (id == 0x23)  \/\/SimpleBlock ID\n        {\n            bBlock = true;\n            break;\n        }\n        pos += size;  \/\/consume payload\n        assert((cluster_stop < 0) || (pos <= cluster_stop));\n    }\n    assert((cluster_stop < 0) || (pos <= cluster_stop));\n    if (timecode < 0)  \/\/no timecode found\n        return E_FILE_FORMAT_INVALID;\n    if (!bBlock)\n        return E_FILE_FORMAT_INVALID;\n    m_pos = new_pos;  \/\/designates position just beyond timecode payload\n    m_timecode = timecode;  \/\/ m_timecode >= 0 means we're partially loaded\n    if (cluster_size >= 0)\n        m_element_size = cluster_stop - m_element_start;\n    return 0;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Cues::~Cues()\n{\n    const long n = m_count + m_preload_count;\n \n    CuePoint** p = m_cue_points;\n    CuePoint** const q = p + n;\n \n    while (p != q)\n    {\n        CuePoint* const pCP = *p++;\n        assert(pCP);\n \n        delete pCP;\n    }\n \n     delete[] m_cue_points;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" int main(int argc, char **argv) {\n   FILE *infile = NULL;\n  vpx_codec_ctx_t codec = {0};\n  vpx_codec_enc_cfg_t cfg = {0};\n   int frame_count = 0;\n  vpx_image_t raw = {0};\n   vpx_codec_err_t res;\n  VpxVideoInfo info = {0};\n   VpxVideoWriter *writer = NULL;\n   const VpxInterface *encoder = NULL;\n   const int fps = 2;        \/\/ TODO(dkovalev) add command line argument\n   const double bits_per_pixel_per_frame = 0.067;\n \n   exec_name = argv[0];\n   if (argc != 6)\n     die(\"Invalid number of arguments\");\n \n  encoder = get_vpx_encoder_by_name(argv[1]);\n  if (!encoder)\n    die(\"Unsupported codec.\");\n \n   info.codec_fourcc = encoder->fourcc;\n   info.frame_width = strtol(argv[2], NULL, 0);\n   info.frame_height = strtol(argv[3], NULL, 0);\n  info.time_base.numerator = 1;\n  info.time_base.denominator = fps;\n\n if (info.frame_width <= 0 ||\n      info.frame_height <= 0 ||\n (info.frame_width % 2) != 0 ||\n (info.frame_height % 2) != 0) {\n    die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);\n }\n\n if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n                                             info.frame_height, 1)) {\n\n     die(\"Failed to allocate image.\");\n   }\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));\n \n  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \"Failed to get default codec config.\");\n \n  cfg.g_w = info.frame_width;\n  cfg.g_h = info.frame_height;\n  cfg.g_timebase.num = info.time_base.numerator;\n  cfg.g_timebase.den = info.time_base.denominator;\n  cfg.rc_target_bitrate = (unsigned int)(bits_per_pixel_per_frame * cfg.g_w *\n                                         cfg.g_h * fps \/ 1000);\n  cfg.g_lag_in_frames = 0;\n\n  writer = vpx_video_writer_open(argv[5], kContainerIVF, &info);\n if (!writer)\n    die(\"Failed to open %s for writing.\", argv[5]);\n\n\n   if (!(infile = fopen(argv[4], \"rb\")))\n     die(\"Failed to open %s for reading.\", argv[4]);\n \n  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n     die_codec(&codec, \"Failed to initialize encoder\");\n \n   while (vpx_img_read(&raw, infile)) {\n     ++frame_count;\n \n if (frame_count == 22 && encoder->fourcc == VP8_FOURCC) {\n      set_roi_map(&cfg, &codec);\n } else if (frame_count == 33) {\n      set_active_map(&cfg, &codec);\n } else if (frame_count == 44) {\n      unset_active_map(&cfg, &codec);\n }\n\n \n     encode_frame(&codec, &raw, frame_count, writer);\n   }\n  encode_frame(&codec, NULL, -1, writer);\n   printf(\"\\n\");\n   fclose(infile);\n   printf(\"Processed %d frames.\\n\", frame_count);\n\n  vpx_img_free(&raw);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_writer_close(writer);\n\n return EXIT_SUCCESS;\n}\n","project":"Android","target":1},{"commit_id":"268068f25673242d1d5130d96202d3288c91b700","func":"static void local_socket_close(asocket* s) {\n    adb_mutex_lock(&socket_list_lock);\n    local_socket_close_locked(s);\n    adb_mutex_unlock(&socket_list_lock);\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"static void die(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    vprintf(fmt, ap);\n    if(fmt[strlen(fmt)-1] != '\\n')\n        printf(\"\\n\");\n    exit(EXIT_FAILURE);\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_munge_as4_attrs (struct peer *const peer,\n                          struct attr *const attr,\n                          struct aspath *as4_path, as_t as4_aggregator,\n                          struct in_addr *as4_aggregator_addr)\n{\n  int ignore_as4_path = 0;\n  struct aspath *newpath;\n  struct attr_extra *attre = attr->extra;\n    \n  if (CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV))\n    {\n      \/* peer can do AS4, so we ignore AS4_PATH and AS4_AGGREGATOR\n       * if given.\n       * It is worth a warning though, because the peer really\n       * should not send them\n       *\/\n      if (BGP_DEBUG(as4, AS4))\n        {\n          if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH)))\n            zlog_debug (\"[AS4] %s %s AS4_PATH\",\n                        peer->host, \"AS4 capable peer, yet it sent\");\n          \n          if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR)))\n            zlog_debug (\"[AS4] %s %s AS4_AGGREGATOR\",\n                        peer->host, \"AS4 capable peer, yet it sent\");\n        }\n      \n      return BGP_ATTR_PARSE_PROCEED;\n    }\n  \n  \/* We have a asn16 peer.  First, look for AS4_AGGREGATOR\n   * because that may override AS4_PATH\n   *\/\n  if (attr->flag & (ATTR_FLAG_BIT (BGP_ATTR_AS4_AGGREGATOR) ) )\n    {\n      if (attr->flag & (ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR) ) )\n        {\n          assert (attre);\n          \n          \/* received both.\n           * if the as_number in aggregator is not AS_TRANS,\n           *  then AS4_AGGREGATOR and AS4_PATH shall be ignored\n           *        and the Aggregator shall be taken as \n           *        info on the aggregating node, and the AS_PATH\n           *        shall be taken as the AS_PATH\n           *  otherwise\n           *        the Aggregator shall be ignored and the\n           *        AS4_AGGREGATOR shall be taken as the\n           *        Aggregating node and the AS_PATH is to be\n           *        constructed \"as in all other cases\"\n           *\/\n          if (attre->aggregator_as != BGP_AS_TRANS)\n            {\n              \/* ignore *\/\n              if ( BGP_DEBUG(as4, AS4))\n                zlog_debug (\"[AS4] %s BGP not AS4 capable peer\" \n                            \" send AGGREGATOR != AS_TRANS and\"\n                            \" AS4_AGGREGATOR, so ignore\"\n                            \" AS4_AGGREGATOR and AS4_PATH\", peer->host);\n              ignore_as4_path = 1;\n            }\n          else\n            {\n              \/* \"New_aggregator shall be taken as aggregator\" *\/\n              attre->aggregator_as = as4_aggregator;\n              attre->aggregator_addr.s_addr = as4_aggregator_addr->s_addr;\n            }\n        }\n      else\n        {\n          \/* We received a AS4_AGGREGATOR but no AGGREGATOR.\n           * That is bogus - but reading the conditions\n           * we have to handle AS4_AGGREGATOR as if it were\n           * AGGREGATOR in that case\n           *\/\n          if ( BGP_DEBUG(as4, AS4))\n            zlog_debug (\"[AS4] %s BGP not AS4 capable peer send\"\n                        \" AS4_AGGREGATOR but no AGGREGATOR, will take\"\n                        \" it as if AGGREGATOR with AS_TRANS had been there\", peer->host);\n          (attre = bgp_attr_extra_get (attr))->aggregator_as = as4_aggregator;\n          \/* sweep it under the carpet and simulate a \"good\" AGGREGATOR *\/\n          attr->flag |= (ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR));\n        }\n    }\n\n  \/* need to reconcile NEW_AS_PATH and AS_PATH *\/\n  if (!ignore_as4_path && (attr->flag & (ATTR_FLAG_BIT( BGP_ATTR_AS4_PATH))))\n    {\n       newpath = aspath_reconcile_as4 (attr->aspath, as4_path);\n       aspath_unintern (&attr->aspath);\n       attr->aspath = aspath_intern (newpath);\n    }\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_check (struct peer *peer, struct attr *attr)\n{\n  u_char type = 0;\n  \n  if (! CHECK_FLAG (attr->flag, ATTR_FLAG_BIT (BGP_ATTR_ORIGIN)))\n    type = BGP_ATTR_ORIGIN;\n\n  if (! CHECK_FLAG (attr->flag, ATTR_FLAG_BIT (BGP_ATTR_AS_PATH)))\n    type = BGP_ATTR_AS_PATH;\n\n  if (! CHECK_FLAG (attr->flag, ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP)))\n    type = BGP_ATTR_NEXT_HOP;\n\n  if (peer_sort (peer) == BGP_PEER_IBGP\n      && ! CHECK_FLAG (attr->flag, ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF)))\n    type = BGP_ATTR_LOCAL_PREF;\n\n  if (type)\n    {\n      zlog (peer->log, LOG_WARNING, \n\t    \"%s Missing well-known attribute %d.\",\n\t    peer->host, type);\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_UPDATE_ERR, \n\t\t\t\t BGP_NOTIFY_UPDATE_MISS_ATTR,\n\t\t\t\t &type, 1);\n      return BGP_ATTR_PARSE_ERROR;\n    }\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_device_n(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->type == FZ_COLORSPACE_SEPARATION);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_cmm_init_link(fz_context *ctx, fz_icclink *link, const fz_iccprofile *dst, int dst_extras, const fz_iccprofile *src, int src_extras, const fz_iccprofile *prf, const fz_color_params *rend, int cmm_flags, int num_bytes, int copy_spots)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->init_link(ctx->cmm_instance, link, dst, dst_extras, src, src_extras, prf, rend, cmm_flags, num_bytes, copy_spots);\n}\n","project":"ghostscript","target":0},{"commit_id":"45737cb776625f17384540523674761e6313e6d4","func":"bool SampleTable::isValid() const {\n\n     return mChunkOffsetOffset >= 0\n         && mSampleToChunkOffset >= 0\n         && mSampleSizeOffset >= 0\n        && mTimeToSample != NULL;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"cmyk2bgr(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n#ifdef SLOWCMYK\n\tfloat rgb[3];\n\tcmyk_to_rgb(ctx, NULL, sv, rgb);\n\tdv[0] = rgb[2];\n\tdv[1] = rgb[1];\n\tdv[2] = rgb[0];\n#else\n\tdv[0] = 1 - fz_min(sv[2] + sv[3], 1);\n\tdv[1] = 1 - fz_min(sv[1] + sv[3], 1);\n\tdv[2] = 1 - fz_min(sv[0] + sv[3], 1);\n#endif\n}\n","project":"ghostscript","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftFlacEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n    ALOGV(\"SoftFlacEncoder::internalGetParameter(index=0x%x)\", index);\n\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n\n         case OMX_IndexParamAudioFlac:\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             flacParams->nCompressionLevel = mCompressionLevel;\n             flacParams->nChannels = mNumChannels;\n             flacParams->nSampleRate = mSampleRate;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftMP3::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioMp3:\n {\n\n             OMX_AUDIO_PARAM_MP3TYPE *mp3Params =\n                 (OMX_AUDIO_PARAM_MP3TYPE *)params;\n \n             if (mp3Params->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mp3Params->nChannels = mNumChannels;\n            mp3Params->nBitRate = 0 \/* unknown *\/;\n            mp3Params->nSampleRate = mSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 4;\n     fwd_txfm_ref = fdct4x4_ref;\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long BlockEntry::GetIndex() const\n{\n    return m_index;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"CuePoint::CuePoint(long idx, long long pos) :\n    m_element_start(0),\n    m_element_size(0),\n    m_index(idx),\n    m_timecode(-1 * pos),\n    m_track_positions(NULL),\n    m_track_positions_count(0)\n{\n    assert(pos > 0);\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" static void set_roi_map(const vpx_codec_enc_cfg_t *cfg,\n                         vpx_codec_ctx_t *codec) {\n   unsigned int i;\n  vpx_roi_map_t roi = {0};\n \n   roi.rows = (cfg->g_h + 15) \/ 16;\n   roi.cols = (cfg->g_w + 15) \/ 16;\n\n  roi.delta_q[0] = 0;\n  roi.delta_q[1] = -2;\n  roi.delta_q[2] = -4;\n  roi.delta_q[3] = -6;\n\n  roi.delta_lf[0] = 0;\n  roi.delta_lf[1] = 1;\n  roi.delta_lf[2] = 2;\n  roi.delta_lf[3] = 3;\n\n  roi.static_threshold[0] = 1500;\n  roi.static_threshold[1] = 1000;\n  roi.static_threshold[2] = 500;\n  roi.static_threshold[3] = 0;\n\n  roi.roi_map = (uint8_t *)malloc(roi.rows * roi.cols);\n for (i = 0; i < roi.rows * roi.cols; ++i)\n    roi.roi_map[i] = i % 4;\n\n if (vpx_codec_control(codec, VP8E_SET_ROI_MAP, &roi))\n    die_codec(codec, \"Failed to set ROI map\");\n\n  free(roi.roi_map);\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void RunCoeffCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j)\n        input_block[j] = rnd.Rand8() - rnd.Rand8();\n \n       fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);\n      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j)\n        EXPECT_EQ(output_block[j], output_ref_block[j]);\n }\n }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"char * phar_decompress_filter(phar_entry_info * entry, int return_unknown) \/* {{{ *\/\n{\n\tphp_uint32 flags;\n\n\tif (entry->is_modified) {\n\t\tflags = entry->old_flags;\n\t} else {\n\t\tflags = entry->flags;\n\t}\n\n\tswitch (flags & PHAR_ENT_COMPRESSION_MASK) {\n\t\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\t\treturn \"zlib.inflate\";\n\t\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\t\treturn \"bzip2.decompress\";\n\t\tdefault:\n\t\t\treturn return_unknown ? \"unknown\" : NULL;\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"icc_base_conv_color(fz_context *ctx, fz_color_converter *cc, float *dstv, const float *srcv)\n{\n\tconst fz_colorspace *srcs = cc->ss;\n\n\tfloat local_src_map[FZ_MAX_COLORS];\n\tfloat local_src_map2[FZ_MAX_COLORS];\n\tfloat *src_map = local_src_map;\n\n\tdo\n\t{\n\t\tsrcs->to_ccs(ctx, srcs, srcv, src_map);\n\t\tsrcs = srcs->get_base(srcs);\n\t\tsrcs->clamp(srcs, src_map, src_map);\n\t\tsrcv = src_map;\n\t\tsrc_map = (src_map == local_src_map ? local_src_map2 : local_src_map);\n\t}\n\twhile (!fz_colorspace_is_icc(ctx, srcs) && !fz_colorspace_is_cal(ctx, srcs));\n\n\ticc_conv_color(ctx, cc, dstv, srcv);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void Encoder::EncodeFrameInternal(const VideoSource &video,\n const unsigned long frame_flags) {\n\n   vpx_codec_err_t res;\n   const vpx_image_t *img = video.img();\n \n  if (!encoder_.priv) {\n    cfg_.g_w = img->d_w;\n    cfg_.g_h = img->d_h;\n    cfg_.g_timebase = video.timebase();\n    cfg_.rc_twopass_stats_in = stats_->buf();\n    res = vpx_codec_enc_init(&encoder_, CodecInterface(), &cfg_,\n                             init_flags_);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n  }\n   if (cfg_.g_w != img->d_w || cfg_.g_h != img->d_h) {\n     cfg_.g_w = img->d_w;\n    cfg_.g_h = img->d_h;\n    res = vpx_codec_enc_config_set(&encoder_, &cfg_);\n    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n\n   }\n \n  REGISTER_STATE_CHECK(\n      res = vpx_codec_encode(&encoder_,\n                             video.img(), video.pts(), video.duration(),\n                              frame_flags, deadline_));\n   ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Segment::ParseCues(\n    long long off,\n    long long& pos,\n    long& len)\n{\n    if (m_pCues)\n        return 0;  \/\/success\n \n    if (off < 0)\n        return -1;\n \n    long long total, avail;\n \n    const int status = m_pReader->Length(&total, &avail);\n \n    if (status < 0)  \/\/error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    pos = m_start + off;\n \n    if ((total < 0) || (pos >= total))\n        return 1;  \/\/don't bother parsing cues\n \n    const long long element_start = pos;\n    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n \n    if ((pos + 1) > avail)\n    {\n        len = 1;\n        return E_BUFFER_NOT_FULL;\n    }\n \n    long long result = GetUIntLength(m_pReader, pos, len);\n \n    if (result < 0)  \/\/error\n        return static_cast<long>(result);\n \n    if (result > 0) \/\/underflow (weird)\n    {\n        len = 1;\n        return E_BUFFER_NOT_FULL;\n    }\n \n    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n        return E_FILE_FORMAT_INVALID;\n \n    if ((pos + len) > avail)\n        return E_BUFFER_NOT_FULL;\n \n    const long long idpos = pos;\n \n    const long long id = ReadUInt(m_pReader, idpos, len);\n \n    if (id != 0x0C53BB6B)  \/\/Cues ID\n        return E_FILE_FORMAT_INVALID;\n \n    pos += len;  \/\/consume ID\n    assert((segment_stop < 0) || (pos <= segment_stop));\n \n \n    if ((pos + 1) > avail)\n    {\n        len = 1;\n        return E_BUFFER_NOT_FULL;\n    }\n \n    result = GetUIntLength(m_pReader, pos, len);\n \n    if (result < 0)  \/\/error\n        return static_cast<long>(result);\n \n    if (result > 0) \/\/underflow (weird)\n    {\n        len = 1;\n        return E_BUFFER_NOT_FULL;\n    }\n \n    if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n        return E_FILE_FORMAT_INVALID;\n \n    if ((pos + len) > avail)\n        return E_BUFFER_NOT_FULL;\n \n    const long long size = ReadUInt(m_pReader, pos, len);\n \n    if (size < 0)  \/\/error\n        return static_cast<long>(size);\n \n    if (size == 0)  \/\/weird, although technically not illegal\n        return 1;   \/\/done\n \n    pos += len;  \/\/consume length of size of element\n    assert((segment_stop < 0) || (pos <= segment_stop));\n \n \n    const long long element_stop = pos + size;\n \n    if ((segment_stop >= 0) && (element_stop > segment_stop))\n        return E_FILE_FORMAT_INVALID;\n \n    if ((total >= 0) && (element_stop > total))\n        return 1;  \/\/don't bother parsing anymore\n \n    len = static_cast<long>(size);\n \n    if (element_stop > avail)\n        return E_BUFFER_NOT_FULL;\n \n    const long long element_size = element_stop - element_start;\n \n    m_pCues = new (std::nothrow) Cues(\n                                    this,\n                                    pos,\n                                    size,\n                                    element_start,\n                                    element_size);\n    assert(m_pCues);  \/\/TODO\n \n    return 0;  \/\/success\n }\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAAC2::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            aacParams->nBitRate = 0;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = OMX_AUDIO_AACObjectMain;\n\n            aacParams->eAACStreamFormat =\n                mIsADTS\n ? OMX_AUDIO_AACStreamFormatMP4ADTS\n : OMX_AUDIO_AACStreamFormatMP4FF;\n\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n if (!isConfigured()) {\n                aacParams->nChannels = 1;\n                aacParams->nSampleRate = 44100;\n                aacParams->nFrameLength = 0;\n } else {\n                aacParams->nChannels = mStreamInfo->numChannels;\n                aacParams->nSampleRate = mStreamInfo->sampleRate;\n                aacParams->nFrameLength = mStreamInfo->frameSize;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n            pcmParams->eChannelMapping[2] = OMX_AUDIO_ChannelCF;\n            pcmParams->eChannelMapping[3] = OMX_AUDIO_ChannelLFE;\n            pcmParams->eChannelMapping[4] = OMX_AUDIO_ChannelLS;\n            pcmParams->eChannelMapping[5] = OMX_AUDIO_ChannelRS;\n\n if (!isConfigured()) {\n                pcmParams->nChannels = 1;\n                pcmParams->nSamplingRate = 44100;\n } else {\n                pcmParams->nChannels = mStreamInfo->numChannels;\n                pcmParams->nSamplingRate = mStreamInfo->sampleRate;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static bool check_rodc_critical_attribute(struct ldb_message *msg)\n{\n\tuint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;\n\n\tschemaFlagsEx = ldb_msg_find_attr_as_uint(msg, \"schemaFlagsEx\", 0);\n\tsearchFlags = ldb_msg_find_attr_as_uint(msg, \"searchFlags\", 0);\n\trodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE\n\t\t\t      | SEARCH_FLAG_CONFIDENTIAL);\n\n\tif ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&\n\t\t((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n","project":"samba","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Block::GetTrackNumber() const\n{\n    return m_track;\n }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_copy_pattern_gstate(fz_context *ctx, pdf_gstate *gs, const pdf_gstate *old)\n{\n\tgs->ctm = old->ctm;\n\n\tpdf_drop_font(ctx, gs->text.font);\n\tgs->text.font = pdf_keep_font(ctx, old->text.font);\n\n\tpdf_drop_xobject(ctx, gs->softmask);\n\tgs->softmask = pdf_keep_xobject(ctx, old->softmask);\n\n\tfz_drop_stroke_state(ctx, gs->stroke_state);\n\tgs->stroke_state = fz_keep_stroke_state(ctx, old->stroke_state);\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_drop_gstate(fz_context *ctx, pdf_gstate *gs)\n{\n\tpdf_drop_material(ctx, &gs->stroke);\n\tpdf_drop_material(ctx, &gs->fill);\n\tpdf_drop_font(ctx, gs->text.font);\n\tpdf_drop_xobject(ctx, gs->softmask);\n\tpdf_drop_obj(ctx, gs->softmask_resources);\n\tfz_drop_stroke_state(ctx, gs->stroke_state);\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_dh_compute_key)\n{\n\tzval *key;\n\tchar *pub_str;\n\tint pub_len;\n\tEVP_PKEY *pkey;\n\tBIGNUM *pub;\n\tchar *data;\n\tint len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sr\", &pub_str, &pub_len, &key) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(pkey, EVP_PKEY *, &key, -1, \"OpenSSL key\", le_key);\n\tif (!pkey || EVP_PKEY_type(pkey->type) != EVP_PKEY_DH || !pkey->pkey.dh) {\n\t\tRETURN_FALSE;\n\t}\n\n\tpub = BN_bin2bn((unsigned char*)pub_str, pub_len, NULL);\n\n\tdata = emalloc(DH_size(pkey->pkey.dh) + 1);\n\tlen = DH_compute_key((unsigned char*)data, pub, pkey->pkey.dh);\n\n\tif (len >= 0) {\n\t\tdata[len] = 0;\n\t\tRETVAL_STRINGL(data, len, 0);\n\t} else {\n\t\tefree(data);\n\t\tRETVAL_FALSE;\n\t}\n\n\tBN_free(pub);\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void fht16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n   vp9_fht16x16_c(in, out, stride, tx_type);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_cmm_instance *fz_cmm_new_instance(fz_context *ctx)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm)\n\t\treturn ctx->colorspace->cmm->new_instance(ctx);\n\treturn NULL;\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_EMC(fz_context *ctx, pdf_processor *proc)\n{\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   static void TearDownTestCase() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    vpx_free(reference_data_);\n    reference_data_ = NULL;\n   }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" TileIndependenceTest()\n : EncoderTest(GET_PARAM(0)),\n        md5_fw_order_(),\n\n         md5_inv_order_(),\n         n_tiles_(GET_PARAM(1)) {\n     init_flags_ = VPX_CODEC_USE_PSNR;\n    vpx_codec_dec_cfg_t cfg;\n     cfg.w = 704;\n     cfg.h = 144;\n     cfg.threads = 1;\n    fw_dec_ = codec_->CreateDecoder(cfg, 0);\n    inv_dec_ = codec_->CreateDecoder(cfg, 0);\n    inv_dec_->Control(VP9_INVERT_TILE_DECODE_ORDER, 1);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_drop_default_colorspaces(fz_context *ctx, fz_default_colorspaces *default_cs)\n{\n\tif (fz_drop_imp(ctx, default_cs, &default_cs->refs))\n\t{\n\t\tfz_drop_colorspace(ctx, default_cs->gray);\n\t\tfz_drop_colorspace(ctx, default_cs->rgb);\n\t\tfz_drop_colorspace(ctx, default_cs->cmyk);\n\t\tfz_drop_colorspace(ctx, default_cs->oi);\n\t\tfz_free(ctx, default_cs);\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const BlockEntry* Segment::GetBlock(\n    const CuePoint& cp,\n    const CuePoint::TrackPosition& tp)\n{\n    Cluster** const ii = m_clusters;\n    Cluster** i = ii;\n \n    const long count = m_clusterCount + m_clusterPreloadCount;\n \n    Cluster** const jj = ii + count;\n    Cluster** j = jj;\n \n    while (i < j)\n    {\n \n        Cluster** const k = i + (j - i) \/ 2;\n        assert(k < jj);\n        Cluster* const pCluster = *k;\n        assert(pCluster);\n        const long long pos = pCluster->GetPosition();\n        assert(pos >= 0);\n        if (pos < tp.m_pos)\n            i = k + 1;\n        else if (pos > tp.m_pos)\n            j = k;\n        else\n            return pCluster->GetEntry(cp, tp);\n    }\n    assert(i == j);\n    Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos); \/\/, -1);\n     assert(pCluster);\n \n    const ptrdiff_t idx = i - m_clusters;\n \n    PreloadCluster(pCluster, idx);\n    assert(m_clusters);\n    assert(m_clusterPreloadCount > 0);\n    assert(m_clusters[idx] == pCluster);\n \n    return pCluster->GetEntry(cp, tp);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"lab_to_rgb(fz_context *ctx, const fz_colorspace *cs, const float *lab, float *rgb)\n{\n\t\/* input is in range (0..100, -128..127, -128..127) not (0..1, 0..1, 0..1) *\/\n\tfloat lstar, astar, bstar, l, m, n, x, y, z, r, g, b;\n\tlstar = lab[0];\n\tastar = lab[1];\n\tbstar = lab[2];\n\tm = (lstar + 16) \/ 116;\n\tl = m + astar \/ 500;\n\tn = m - bstar \/ 200;\n\tx = fung(l);\n\ty = fung(m);\n\tz = fung(n);\n\tr = (3.240449f * x + -1.537136f * y + -0.498531f * z) * 0.830026f;\n\tg = (-0.969265f * x + 1.876011f * y + 0.041556f * z) * 1.05452f;\n\tb = (0.055643f * x + -0.204026f * y + 1.057229f * z) * 1.1003f;\n\trgb[0] = sqrtf(fz_clamp(r, 0, 1));\n\trgb[1] = sqrtf(fz_clamp(g, 0, 1));\n\trgb[2] = sqrtf(fz_clamp(b, 0, 1));\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" void EncoderTest::InitializeConfig() {\n   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);\n   ASSERT_EQ(VPX_CODEC_OK, res);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_default_rgb(fz_context *ctx, const fz_default_colorspaces *default_cs)\n{\n\tif (default_cs)\n\t\treturn default_cs->rgb;\n\telse\n\t\treturn fz_device_rgb(ctx);\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"transit_hash_key_make (void *p)\n{\n  const struct transit * transit = p;\n\n  return jhash(transit->val, transit->length, 0);\n}\n","project":"savannah","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_MP(fz_context *ctx, pdf_processor *proc, const char *tag)\n{\n}\n","project":"ghostscript","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_copy_entry_fp(phar_entry_info *source, phar_entry_info *dest, char **error TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_entry_info *link;\n\n\tif (FAILURE == phar_open_entry_fp(source, error, 1 TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (dest->link) {\n\t\tefree(dest->link);\n\t\tdest->link = NULL;\n\t\tdest->tar_type = (dest->is_tar ? TAR_FILE : '\\0');\n\t}\n\n\tdest->fp_type = PHAR_MOD;\n\tdest->offset = 0;\n\tdest->is_modified = 1;\n\tdest->fp = php_stream_fopen_tmpfile();\n\tif (dest->fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn EOF;\n\t}\n\tphar_seek_efp(source, 0, SEEK_SET, 0, 1 TSRMLS_CC);\n\tlink = phar_get_link_source(source TSRMLS_CC);\n\n\tif (!link) {\n\t\tlink = source;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), dest->fp, link->uncompressed_filesize, NULL)) {\n\t\tphp_stream_close(dest->fp);\n\t\tdest->fp_type = PHAR_FP;\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: unable to copy contents of file \\\"%s\\\" to \\\"%s\\\" in phar archive \\\"%s\\\"\", source->filename, dest->filename, source->phar->fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_SC_pattern(fz_context *ctx, pdf_processor *proc, const char *name, pdf_pattern *pat, int n, float *color)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpr->dev->flags &= ~FZ_DEVFLAG_STROKECOLOR_UNDEFINED;\n\tpdf_set_pattern(ctx, pr, PDF_STROKE, pat, color);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Cues::LoadCuePoint() const\n{\n    const long long stop = m_start + m_size;\n    if (m_pos >= stop)\n        return false;  \/\/nothing else to do\n    Init();\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    while (m_pos < stop)\n    {\n        const long long idpos = m_pos;\n        long len;\n        const long long id = ReadUInt(pReader, m_pos, len);\n        assert(id >= 0);  \/\/TODO\n        assert((m_pos + len) <= stop);\n        m_pos += len;  \/\/consume ID\n        const long long size = ReadUInt(pReader, m_pos, len);\n        assert(size >= 0);\n        assert((m_pos + len) <= stop);\n        m_pos += len;  \/\/consume Size field\n        assert((m_pos + size) <= stop);\n        if (id != 0x3B)  \/\/CuePoint ID\n        {\n            m_pos += size;  \/\/consume payload\n            assert(m_pos <= stop);\n            continue;\n        }\n        assert(m_preload_count > 0);\n        CuePoint* const pCP = m_cue_points[m_count];\n        assert(pCP);\n        assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));\n        if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))\n            return false;\n        pCP->Load(pReader);\n        ++m_count;\n        --m_preload_count;\n        m_pos += size;  \/\/consume payload\n        assert(m_pos <= stop);\n        return true;  \/\/yes, we loaded a cue point\n    }\n    return false;  \/\/no, we did not load a cue point\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_new_colorspace_context(fz_context *ctx)\n{\n\tctx->colorspace = fz_malloc_struct(ctx, fz_colorspace_context);\n\tctx->colorspace->ctx_refs = 1;\n\tset_no_icc(ctx->colorspace);\n#ifdef NO_ICC\n\tfz_set_cmm_engine(ctx, NULL);\n#else\n\tfz_set_cmm_engine(ctx, &fz_cmm_engine_lcms);\n#endif\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"attr_unknown_count (void)\n{\n  return transit_hash->count;\n}\n","project":"savannah","target":0},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_do_pasv (int csock, ip_address *addr, int *port)\n{\n  if (!opt.server_response)\n    logputs (LOG_VERBOSE, \"==> PASV ... \");\n  return ftp_pasv (csock, addr, port);\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::GetIndex() const\n{\n    return m_index;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::CreateBlockGroup(\n    long long start_offset,\n    long long size,\n    long long discard_padding)\n{\n    assert(m_entries);\n    assert(m_entries_size > 0);\n    assert(m_entries_count >= 0);\n    assert(m_entries_count < m_entries_size);\n \n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long pos = start_offset;\n    const long long stop = start_offset + size;\n    long long prev = 1;  \/\/nonce\n    long long next = 0;  \/\/nonce\n    long long duration = -1;  \/\/really, this is unsigned\n    long long bpos = -1;\n    long long bsize = -1;\n    while (pos < stop)\n    {\n        long len;\n        const long long id = ReadUInt(pReader, pos, len);\n        assert(id >= 0);  \/\/TODO\n        assert((pos + len) <= stop);\n        pos += len;  \/\/consume ID\n        const long long size = ReadUInt(pReader, pos, len);\n        assert(size >= 0);  \/\/TODO\n        assert((pos + len) <= stop);\n        pos += len;  \/\/consume size\n        if (id == 0x21) \/\/Block ID\n        {\n            if (bpos < 0) \/\/Block ID\n            {\n                bpos = pos;\n                bsize = size;\n            }\n        }\n        else if (id == 0x1B)  \/\/Duration ID\n        {\n            assert(size <= 8);\n            duration = UnserializeUInt(pReader, pos, size);\n            assert(duration >= 0);  \/\/TODO\n        }\n        else if (id == 0x7B)  \/\/ReferenceBlock\n        {\n            assert(size <= 8);\n            const long size_ = static_cast<long>(size);\n            long long time;\n            long status = UnserializeInt(pReader, pos, size_, time);\n            assert(status == 0);\n            if (status != 0)\n                return -1;\n            if (time <= 0)  \/\/see note above\n                prev = time;\n            else  \/\/weird\n                next = time;\n        }\n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n    assert(bpos >= 0);\n    assert(bsize >= 0);\n \n    const long idx = m_entries_count;\n    BlockEntry** const ppEntry = m_entries + idx;\n    BlockEntry*& pEntry = *ppEntry;\n    pEntry = new (std::nothrow) BlockGroup(\n                                  this,\n                                  idx,\n                                  bpos,\n                                  bsize,\n                                  prev,\n                                  next,\n                                  duration,\n                                  discard_padding);\n    if (pEntry == NULL)\n        return -1;  \/\/generic error\n    BlockGroup* const p = static_cast<BlockGroup*>(pEntry);\n    const long status = p->Parse();\n    if (status == 0)  \/\/success\n    {\n        ++m_entries_count;\n        return 0;\n    }\n    delete pEntry;\n    pEntry = 0;\n    return status;\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftVPXEncoder::setConfig(\n        OMX_INDEXTYPE index, const OMX_PTR _params) {\n switch (index) {\n case OMX_IndexConfigVideoIntraVOPRefresh:\n {\n\n             OMX_CONFIG_INTRAREFRESHVOPTYPE *params =\n                 (OMX_CONFIG_INTRAREFRESHVOPTYPE *)_params;\n \n             if (params->nPortIndex != kOutputPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n            mKeyFrameRequested = params->IntraRefreshVOP;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexConfigVideoBitrate:\n {\n\n             OMX_VIDEO_CONFIG_BITRATETYPE *params =\n                 (OMX_VIDEO_CONFIG_BITRATETYPE *)_params;\n \n             if (params->nPortIndex != kOutputPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n if (mBitrate != params->nEncodeBitrate) {\n                mBitrate = params->nEncodeBitrate;\n                mBitrateUpdated = true;\n }\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::setConfig(index, _params);\n }\n}\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::prepareForAdaptivePlayback(\n\n         OMX_U32 portIndex, OMX_BOOL enable, OMX_U32 maxFrameWidth,\n         OMX_U32 maxFrameHeight) {\n     Mutex::Autolock autolock(mLock);\n     CLOG_CONFIG(prepareForAdaptivePlayback, \"%s:%u en=%d max=%ux%u\",\n             portString(portIndex), portIndex, enable, maxFrameWidth, maxFrameHeight);\n \n    OMX_INDEXTYPE index;\n    OMX_STRING name = const_cast<OMX_STRING>(\n \"OMX.google.android.index.prepareForAdaptivePlayback\");\n\n    OMX_ERRORTYPE err = OMX_GetExtensionIndex(mHandle, name, &index);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR_IF(enable, getExtensionIndex, err, \"%s\", name);\n return StatusFromOMXError(err);\n }\n\n PrepareForAdaptivePlaybackParams params;\n InitOMXParams(&params);\n    params.nPortIndex = portIndex;\n    params.bEnable = enable;\n    params.nMaxFrameWidth = maxFrameWidth;\n    params.nMaxFrameHeight = maxFrameHeight;\n\n    err = OMX_SetParameter(mHandle, index, &params);\n    CLOG_IF_ERROR(setParameter, err, \"%s(%#x): %s:%u en=%d max=%ux%u\", name, index,\n            portString(portIndex), portIndex, enable, maxFrameWidth, maxFrameHeight);\n return StatusFromOMXError(err);\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const BlockEntry* Cues::GetBlock(\n    const CuePoint* pCP,\n    const CuePoint::TrackPosition* pTP) const\n{\n    if (pCP == NULL)\n        return NULL;\n \n    if (pTP == NULL)\n        return NULL;\n    return m_pSegment->GetBlock(*pCP, *pTP);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cues::GetCount() const\n{\n    if (m_cue_points == NULL)\n        return -1;\n \n    return m_count;  \/\/TODO: really ignore preload count?\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_SC_color(fz_context *ctx, pdf_processor *proc, int n, float *color)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpr->dev->flags &= ~FZ_DEVFLAG_STROKECOLOR_UNDEFINED;\n\tpdf_set_color(ctx, pr, PDF_STROKE, color);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" void RunExtremalCheck() {\n\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     int max_error = 0;\n     int total_error = 0;\n     const int count_test_block = 100000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j) {\n        src[j] = rnd.Rand8() % 2 ? 255 : 0;\n        dst[j] = src[j] > 0 ? 0 : 255;\n        test_input_block[j] = src[j] - dst[j];\n       }\n \n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n      REGISTER_STATE_CHECK(\n          RunInvTxfm(test_temp_block, dst, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n         const int diff = dst[j] - src[j];\n         const int error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n         total_error += error;\n       }\n \n      EXPECT_GE(1, max_error)\n           << \"Error: Extremal 8x8 FDCT\/IDCT or FHT\/IHT has\"\n           << \"an individual roundtrip error > 1\";\n \n      EXPECT_GE(count_test_block\/5, total_error)\n           << \"Error: Extremal 8x8 FDCT\/IDCT or FHT\/IHT has average\"\n           << \" roundtrip error > 1\/5 per block\";\n     }\n   }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int php_openssl_parse_config(struct php_x509_request * req, zval * optional_args TSRMLS_DC) \/* {{{ *\/\n{\n\tchar * str;\n\tzval ** item;\n\n\tSET_OPTIONAL_STRING_ARG(\"config\", req->config_filename, default_ssl_conf_filename);\n\tSET_OPTIONAL_STRING_ARG(\"config_section_name\", req->section_name, \"req\");\n\treq->global_config = CONF_load(NULL, default_ssl_conf_filename, NULL);\n\treq->req_config = CONF_load(NULL, req->config_filename, NULL);\n\n\tif (req->req_config == NULL) {\n\t\treturn FAILURE;\n\t}\n\n\t\/* read in the oids *\/\n\tstr = CONF_get_string(req->req_config, NULL, \"oid_file\");\n\tif (str && !php_openssl_safe_mode_chk(str TSRMLS_CC)) {\n\t\tBIO *oid_bio = BIO_new_file(str, \"r\");\n\t\tif (oid_bio) {\n\t\t\tOBJ_create_objects(oid_bio);\n\t\t\tBIO_free(oid_bio);\n\t\t}\n\t}\n\tif (add_oid_section(req TSRMLS_CC) == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\tSET_OPTIONAL_STRING_ARG(\"digest_alg\", req->digest_name,\n\t\tCONF_get_string(req->req_config, req->section_name, \"default_md\"));\n\tSET_OPTIONAL_STRING_ARG(\"x509_extensions\", req->extensions_section,\n\t\tCONF_get_string(req->req_config, req->section_name, \"x509_extensions\"));\n\tSET_OPTIONAL_STRING_ARG(\"req_extensions\", req->request_extensions_section,\n\t\tCONF_get_string(req->req_config, req->section_name, \"req_extensions\"));\n\tSET_OPTIONAL_LONG_ARG(\"private_key_bits\", req->priv_key_bits,\n\t\tCONF_get_number(req->req_config, req->section_name, \"default_bits\"));\n\n\tSET_OPTIONAL_LONG_ARG(\"private_key_type\", req->priv_key_type, OPENSSL_KEYTYPE_DEFAULT);\n\n\tif (optional_args && zend_hash_find(Z_ARRVAL_P(optional_args), \"encrypt_key\", sizeof(\"encrypt_key\"), (void**)&item) == SUCCESS) {\n\t\treq->priv_key_encrypt = Z_BVAL_PP(item);\n\t} else {\n\t\tstr = CONF_get_string(req->req_config, req->section_name, \"encrypt_rsa_key\");\n\t\tif (str == NULL) {\n\t\t\tstr = CONF_get_string(req->req_config, req->section_name, \"encrypt_key\");\n\t\t}\n\t\tif (str && strcmp(str, \"no\") == 0) {\n\t\t\treq->priv_key_encrypt = 0;\n\t\t} else {\n\t\t\treq->priv_key_encrypt = 1;\n\t\t}\n\t}\n\t\n\t\/* digest alg *\/\n\tif (req->digest_name == NULL) {\n\t\treq->digest_name = CONF_get_string(req->req_config, req->section_name, \"default_md\");\n\t}\n\tif (req->digest_name) {\n\t\treq->digest = req->md_alg = EVP_get_digestbyname(req->digest_name);\n\t}\n\tif (req->md_alg == NULL) {\n\t\treq->md_alg = req->digest = EVP_md5();\n\t}\n\n\tPHP_SSL_CONFIG_SYNTAX_CHECK(extensions_section);\n\n\t\/* set the string mask *\/\n\tstr = CONF_get_string(req->req_config, req->section_name, \"string_mask\");\n\tif (str && !ASN1_STRING_set_default_mask_asc(str)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid global string mask setting %s\", str);\n\t\treturn FAILURE;\n\t}\n\n\tPHP_SSL_CONFIG_SYNTAX_CHECK(request_extensions_section);\n\t\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"dump_splay(cmap_splay *tree, unsigned int node, int depth, const char *pre)\n{\n\tint i;\n\n\tif (node == EMPTY)\n\t\treturn;\n\n\tfor (i = 0; i < depth; i++)\n\t\tfprintf(stderr, \" \");\n\tfprintf(stderr, \"%s%d:\", pre, node);\n\tif (tree[node].parent == EMPTY)\n\t\tfprintf(stderr, \"^EMPTY\");\n\telse\n\t\tfprintf(stderr, \"^%d\", tree[node].parent);\n\tif (tree[node].left == EMPTY)\n\t\tfprintf(stderr, \"<EMPTY\");\n\telse\n\t\tfprintf(stderr, \"<%d\", tree[node].left);\n\tif (tree[node].right == EMPTY)\n\t\tfprintf(stderr, \">EMPTY\");\n\telse\n\t\tfprintf(stderr, \">%d\", tree[node].right);\n\tfprintf(stderr, \"(%x,%x,%x,%d)\\n\", tree[node].low, tree[node].high, tree[node].out, tree[node].many);\n\tassert(tree[node].parent == EMPTY || depth);\n\tassert(tree[node].left == EMPTY || tree[tree[node].left].parent == node);\n\tassert(tree[node].right == EMPTY || tree[tree[node].right].parent == node);\n\tdump_splay(tree, tree[node].left, depth+1, \"L\");\n\tdump_splay(tree, tree[node].right, depth+1, \"R\");\n}\n","project":"ghostscript","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_next_step(struct samldb_ctx *ac)\n{\n\tif (ac->curstep->next) {\n\t\tac->curstep = ac->curstep->next;\n\t\treturn ac->curstep->fn(ac);\n\t}\n\n\t\/* We exit the samldb module here. If someone set an \"ares\" to forward\n\t * controls and response back to the caller, use them. *\/\n\tif (ac->ares) {\n\t\treturn ldb_module_done(ac->req, ac->ares->controls,\n\t\t\t\t       ac->ares->response, LDB_SUCCESS);\n\t} else {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, LDB_SUCCESS);\n\t}\n}\n","project":"samba","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_rgb_to_gray(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tint sn = src->n;\n\tint ss = src->s;\n\tint sa = src->alpha;\n\tint dn = dst->n;\n\tint ds = dst->s;\n\tint da = dst->alpha;\n\tptrdiff_t d_line_inc = dst->stride - w * dn;\n\tptrdiff_t s_line_inc = src->stride - w * sn;\n\n\t\/* If copying spots, they must match, and we can never drop alpha (but we can invent it) *\/\n\tif ((copy_spots && ss != ds) || (!da && sa))\n\t{\n\t\tassert(\"This should never happen\" == NULL);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Cannot convert between incompatible pixmaps\");\n\t}\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\tif (ss == 0 && ds == 0)\n\t{\n\t\t\/* Common, no spots case *\/\n\t\tif (da)\n\t\t{\n\t\t\tif (sa)\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = ((s[0]+1) * 77 + (s[1]+1) * 150 + (s[2]+1) * 28) >> 8;\n\t\t\t\t\t\td[1] = s[3];\n\t\t\t\t\t\ts += 4;\n\t\t\t\t\t\td += 2;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = ((s[0]+1) * 77 + (s[1]+1) * 150 + (s[2]+1) * 28) >> 8;\n\t\t\t\t\t\td[1] = 255;\n\t\t\t\t\t\ts += 3;\n\t\t\t\t\t\td += 2;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\td[0] = ((s[0]+1) * 77 + (s[1]+1) * 150 + (s[2]+1) * 28) >> 8;\n\t\t\t\t\ts += 3;\n\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\td += d_line_inc;\n\t\t\t\ts += s_line_inc;\n\t\t\t}\n\t\t}\n\t}\n\telse if (copy_spots)\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\tint i;\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = ((s[0]+1) * 77 + (s[1]+1) * 150 + (s[2]+1) * 28) >> 8;\n\t\t\t\ts += 3;\n\t\t\t\td++;\n\t\t\t\tfor (i=ss; i > 0; i--)\n\t\t\t\t\t*d++ = *s++;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = sa ? *s++ : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = ((s[0]+1) * 77 + (s[1]+1) * 150 + (s[2]+1) * 28) >> 8;\n\t\t\t\ts += sn;\n\t\t\t\td += dn;\n\t\t\t\tif (da)\n\t\t\t\t\td[-1] = sa ? s[-1] : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long BlockGroup::GetDurationTimeCode() const\n{\n    return m_duration;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Chapters::Atom::Atom()\n{\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static void openssl_add_method(const OBJ_NAME *name, void *arg) \/* {{{ *\/\n{\n\tif (name->alias == 0) {\n\t\tadd_next_index_string((zval*)arg, (char*)name->name, 1);\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Cluster::GetTime() const\n{\n    const long long tc = GetTimeCode();\n    if (tc < 0)\n        return tc;\n    const SegmentInfo* const pInfo = m_pSegment->GetInfo();\n    assert(pInfo);\n    const long long scale = pInfo->GetTimeCodeScale();\n    assert(scale >= 1);\n    const long long t = m_timecode * scale;\n    return t;\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_FUNCTION(preg_replace_callback)\n{\n\tpreg_replace_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, 0);\n}\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static STACK_OF(X509) * load_all_certs_from_file(char *certfile)\n{\n\tSTACK_OF(X509_INFO) *sk=NULL;\n\tSTACK_OF(X509) *stack=NULL, *ret=NULL;\n\tBIO *in=NULL;\n\tX509_INFO *xi;\n\tTSRMLS_FETCH();\n\n\tif(!(stack = sk_X509_new_null())) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"memory allocation failure\");\n\t\tgoto end;\n\t}\n\n\tif (php_openssl_safe_mode_chk(certfile TSRMLS_CC)) {\n\t\tsk_X509_free(stack);\n\t\tgoto end;\n\t}\n\n\tif(!(in=BIO_new_file(certfile, \"r\"))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error opening the file, %s\", certfile);\n\t\tsk_X509_free(stack);\n\t\tgoto end;\n\t}\n\n\t\/* This loads from a file, a stack of x509\/crl\/pkey sets *\/\n\tif(!(sk=PEM_X509_INFO_read_bio(in, NULL, NULL, NULL))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error reading the file, %s\", certfile);\n\t\tsk_X509_free(stack);\n\t\tgoto end;\n\t}\n\n\t\/* scan over it and pull out the certs *\/\n\twhile (sk_X509_INFO_num(sk)) {\n\t\txi=sk_X509_INFO_shift(sk);\n\t\tif (xi->x509 != NULL) {\n\t\t\tsk_X509_push(stack,xi->x509);\n\t\t\txi->x509=NULL;\n\t\t}\n\t\tX509_INFO_free(xi);\n\t}\n\tif(!sk_X509_num(stack)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"no certificates in file, %s\", certfile);\n\t\tsk_X509_free(stack);\n\t\tgoto end;\n\t}\n\tret=stack;\nend:\n\tBIO_free(in);\n\tsk_X509_INFO_free(sk);\n\n\treturn ret;\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 8;\n     fwd_txfm_ref = fdct8x8_ref;\n   }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_gray_to_rgb(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tint sn = src->n;\n\tint ss = src->s;\n\tint sa = src->alpha;\n\tint dn = dst->n;\n\tint ds = dst->s;\n\tint da = dst->alpha;\n\tptrdiff_t d_line_inc = dst->stride - w * dn;\n\tptrdiff_t s_line_inc = src->stride - w * sn;\n\n\t\/* If copying spots, they must match, and we can never drop alpha (but we can invent it) *\/\n\tif ((copy_spots && ss != ds) || (!da && sa))\n\t{\n\t\tassert(\"This should never happen\" == NULL);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Cannot convert between incompatible pixmaps\");\n\t}\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\tif (ss == 0 && ds == 0)\n\t{\n\t\t\/* Common, no spots case *\/\n\t\tif (da)\n\t\t{\n\t\t\tif (sa)\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = s[0];\n\t\t\t\t\t\td[1] = s[0];\n\t\t\t\t\t\td[2] = s[0];\n\t\t\t\t\t\td[3] = s[1];\n\t\t\t\t\t\ts += 2;\n\t\t\t\t\t\td += 4;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = s[0];\n\t\t\t\t\t\td[1] = s[0];\n\t\t\t\t\t\td[2] = s[0];\n\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\ts++;\n\t\t\t\t\t\td += 4;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\td[0] = s[0];\n\t\t\t\t\td[1] = s[0];\n\t\t\t\t\td[2] = s[0];\n\t\t\t\t\ts++;\n\t\t\t\t\td += 3;\n\t\t\t\t}\n\t\t\t\td += d_line_inc;\n\t\t\t\ts += s_line_inc;\n\t\t\t}\n\t\t}\n\t}\n\telse if (copy_spots)\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\tint i;\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = s[0];\n\t\t\t\td[1] = s[0];\n\t\t\t\td[2] = s[0];\n\t\t\t\ts += 1;\n\t\t\t\td += 3;\n\t\t\t\tfor (i=ss; i > 0; i--)\n\t\t\t\t\t*d++ = *s++;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = sa ? *s++ : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = s[0];\n\t\t\t\td[1] = s[0];\n\t\t\t\td[2] = s[0];\n\t\t\t\ts += sn;\n\t\t\t\td += dn;\n\t\t\t\tif (da)\n\t\t\t\t\td[-1] = sa ? s[-1] : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftRaw::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.raw\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mChannelCount = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"free_indexed(fz_context *ctx, fz_colorspace *cs)\n{\n\tstruct indexed *idx = cs->data;\n\tfz_drop_colorspace(ctx, idx->base);\n\tfz_free(ctx, idx->lookup);\n\tfz_free(ctx, idx);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   int ReturnFrameBuffer(vpx_codec_frame_buffer_t *fb) {\n    EXPECT_TRUE(fb != NULL);\n     ExternalFrameBuffer *const ext_fb =\n         reinterpret_cast<ExternalFrameBuffer*>(fb->priv);\n    EXPECT_TRUE(ext_fb != NULL);\n     EXPECT_EQ(1, ext_fb->in_use);\n     ext_fb->in_use = 0;\n     return 0;\n }\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_FUNCTION(preg_grep)\n{\n\tchar\t\t\t\t*regex;\t\t\t\/* Regular expression *\/\n\tint\t\t\t\t \t regex_len;\n\tzval\t\t\t\t*input;\t\t\t\/* Input array *\/\n\tlong\t\t\t\t flags = 0;\t\t\/* Match control flags *\/\n\tpcre_cache_entry\t*pce;\t\t\t\/* Compiled regular expression *\/\n\n\t\/* Get arguments and do error checking *\/\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sa|l\", &regex, &regex_len,\n\t\t\t\t\t\t\t  &input, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\t\/* Compile regex or get it from cache. *\/\n\tif ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\tphp_pcre_grep_impl(pce, input, return_value, flags TSRMLS_CC);\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Cluster::GetTimeCode() const\n{\n     long long pos;\n     long len;\n \n    const long status = Load(pos, len);\n \n    if (status < 0) \/\/error\n        return status;\n    return m_timecode;\n}\n","project":"Android","target":1},{"commit_id":"1f4b49e64adf4623eefda503bca61e253597b9bf","func":"status_t Parcel::readUtf8FromUtf16(std::string* str) const {\n size_t utf16Size = 0;\n const char16_t* src = readString16Inplace(&utf16Size);\n if (!src) {\n return UNEXPECTED_NULL;\n }\n\n if (utf16Size == 0u) {\n        str->clear();\n\n        return NO_ERROR;\n     }\n \n    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size);\n    if (utf8Size < 0) {\n         return BAD_VALUE;\n     }\n    str->resize(utf8Size + 1);\n    utf16_to_utf8(src, utf16Size, &((*str)[0]));\n     str->resize(utf8Size);\n     return NO_ERROR;\n }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_F(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_path(ctx, pr, 0, 1, 0, 0);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* SegmentInfo::GetMuxingAppAsUTF8() const\n{\n    return m_pMuxingAppAsUTF8;\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"attrhash_init (void)\n{\n  attrhash = hash_create (attrhash_key_make, attrhash_cmp);\n}\n","project":"savannah","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_med (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  \/* Length check. *\/\n  if (length != 4)\n    {\n      zlog (peer->log, LOG_ERR, \n\t    \"MED attribute length isn't four [%d]\", length);\n\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n\n  attr->med = stream_getl (peer->ibuf);\n\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Cluster* Segment::GetFirst() const\n{\n    if ((m_clusters == NULL) || (m_clusterCount <= 0))\n       return &m_eos;\n \n    Cluster* const pCluster = m_clusters[0];\n    assert(pCluster);\n    return pCluster;\n }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_mp_reach_parse (struct bgp_attr_parser_args *args,\n                    struct bgp_nlri *mp_update)\n{\n  afi_t afi;\n  safi_t safi;\n  bgp_size_t nlri_len;\n  size_t start;\n  int ret;\n  struct stream *s;\n  struct peer *const peer = args->peer;  \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  struct attr_extra *attre = bgp_attr_extra_get(attr);\n  \n  \/* Set end of packet. *\/\n  s = BGP_INPUT(peer);\n  start = stream_get_getp(s);\n  \n  \/* safe to read statically sized header? *\/\n#define BGP_MP_REACH_MIN_SIZE 5\n#define LEN_LEFT\t(length - (stream_get_getp(s) - start))\n  if ((length > STREAM_READABLE(s)) || (length < BGP_MP_REACH_MIN_SIZE))\n    {\n      zlog_info (\"%s: %s sent invalid length, %lu\", \n\t\t __func__, peer->host, (unsigned long)length);\n      return BGP_ATTR_PARSE_ERROR;\n    }\n  \n  \/* Load AFI, SAFI. *\/\n  afi = stream_getw (s);\n  safi = stream_getc (s);\n\n  \/* Get nexthop length. *\/\n  attre->mp_nexthop_len = stream_getc (s);\n  \n  if (LEN_LEFT < attre->mp_nexthop_len)\n    {\n      zlog_info (\"%s: %s, MP nexthop length, %u, goes past end of attribute\", \n\t\t __func__, peer->host, attre->mp_nexthop_len);\n      return BGP_ATTR_PARSE_ERROR;\n    }\n  \n  \/* Nexthop length check. *\/\n  switch (attre->mp_nexthop_len)\n    {\n    case 4:\n      stream_get (&attre->mp_nexthop_global_in, s, 4);\n      \/* Probably needed for RFC 2283 *\/\n      if (attr->nexthop.s_addr == 0)\n        memcpy(&attr->nexthop.s_addr, &attre->mp_nexthop_global_in, 4);\n      break;\n    case 12:\n      stream_getl (s); \/* RD high *\/\n      stream_getl (s); \/* RD low *\/\n      stream_get (&attre->mp_nexthop_global_in, s, 4);\n      break;\n#ifdef HAVE_IPV6\n    case 16:\n      stream_get (&attre->mp_nexthop_global, s, 16);\n      break;\n    case 32:\n      stream_get (&attre->mp_nexthop_global, s, 16);\n      stream_get (&attre->mp_nexthop_local, s, 16);\n      if (! IN6_IS_ADDR_LINKLOCAL (&attre->mp_nexthop_local))\n\t{\n\t  char buf1[INET6_ADDRSTRLEN];\n\t  char buf2[INET6_ADDRSTRLEN];\n\n\t  if (BGP_DEBUG (update, UPDATE_IN))\n\t    zlog_debug (\"%s got two nexthop %s %s but second one is not a link-local nexthop\", peer->host,\n\t\t       inet_ntop (AF_INET6, &attre->mp_nexthop_global,\n\t\t\t\t  buf1, INET6_ADDRSTRLEN),\n\t\t       inet_ntop (AF_INET6, &attre->mp_nexthop_local,\n\t\t\t\t  buf2, INET6_ADDRSTRLEN));\n\n\t  attre->mp_nexthop_len = 16;\n\t}\n      break;\n#endif \/* HAVE_IPV6 *\/\n    default:\n      zlog_info (\"%s: (%s) Wrong multiprotocol next hop length: %d\", \n\t\t __func__, peer->host, attre->mp_nexthop_len);\n      return BGP_ATTR_PARSE_ERROR;\n    }\n\n  if (!LEN_LEFT)\n    {\n      zlog_info (\"%s: (%s) Failed to read SNPA and NLRI(s)\",\n                 __func__, peer->host);\n      return BGP_ATTR_PARSE_ERROR;\n    }\n  \n  {\n    u_char val; \n    if ((val = stream_getc (s)))\n    zlog_warn (\"%s sent non-zero value, %u, for defunct SNPA-length field\",\n                peer->host, val);\n  }\n  \n  \/* must have nrli_len, what is left of the attribute *\/\n  nlri_len = LEN_LEFT;\n  if ((!nlri_len) || (nlri_len > STREAM_READABLE(s)))\n    {\n      zlog_info (\"%s: (%s) Failed to read NLRI\",\n                 __func__, peer->host);\n      return BGP_ATTR_PARSE_ERROR;\n    }\n \n  if (safi != SAFI_MPLS_LABELED_VPN)\n    {\n      ret = bgp_nlri_sanity_check (peer, afi, stream_pnt (s), nlri_len);\n      if (ret < 0) \n        {\n          zlog_info (\"%s: (%s) NLRI doesn't pass sanity check\",\n                     __func__, peer->host);\n\t  return BGP_ATTR_PARSE_ERROR;\n\t}\n    }\n\n  mp_update->afi = afi;\n  mp_update->safi = safi;\n  mp_update->nlri = stream_pnt (s);\n  mp_update->length = nlri_len;\n\n  stream_forward_getp (s, nlri_len);\n\n  return BGP_ATTR_PARSE_PROCEED;\n#undef LEN_LEFT\n}\n","project":"savannah","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_x509_free)\n{\n\tzval *x509;\n\tX509 *cert;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &x509) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(cert, X509 *, &x509, -1, \"OpenSSL X.509\", le_x509);\n\tzend_list_delete(Z_LVAL_P(x509));\n}\n","project":"php","target":0},{"commit_id":"e629194c62a9a129ce378e08cb1059a8a53f1795","func":"WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,\n                                 UWORD8 u1_nal_ref_idc,\n dec_struct_t *ps_dec \/* Decoder parameters *\/\n )\n{\n dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;\n dec_pic_params_t *ps_pps;\n dec_seq_params_t *ps_seq;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n pocstruct_t s_tmp_poc;\n    WORD32 i_delta_poc[2];\n    WORD32 i4_poc = 0;\n    UWORD16 u2_first_mb_in_slice, u2_frame_num;\n    UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;\n    UWORD32 u4_idr_pic_id = 0;\n    UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;\n\n    UWORD8 u1_nal_unit_type;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    WORD8 i1_is_end_of_poc;\n\n    WORD32 ret, end_of_frame;\n    WORD32 prev_slice_err, num_mb_skipped;\n    UWORD8 u1_mbaff;\n pocstruct_t *ps_cur_poc;\n\n    UWORD32 u4_temp;\n    WORD32 i_temp;\n    UWORD32 u4_call_end_of_pic = 0;\n\n \/* read FirstMbInSlice  and slice type*\/\n    ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;\n    u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n if(u2_first_mb_in_slice\n > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))\n {\n\n return ERROR_CORRUPTED_SLICE;\n }\n\n \/*we currently don not support ASO*\/\n if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)\n <= ps_dec->u2_cur_mb_addr) && (ps_dec->u2_cur_mb_addr != 0)\n && (ps_dec->u4_first_slice_in_pic != 0))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n    COPYTHECONTEXT(\"SH: first_mb_in_slice\",u2_first_mb_in_slice);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > 9)\n return ERROR_INV_SLC_TYPE_T;\n\n    u1_slice_type = u4_temp;\n    COPYTHECONTEXT(\"SH: slice_type\",(u1_slice_type));\n    ps_dec->u1_sl_typ_5_9 = 0;\n \/* Find Out the Slice Type is 5 to 9 or not then Set the Flag   *\/\n \/* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*\/\n \/* will be of same type of current                            *\/\n if(u1_slice_type > 4)\n {\n        u1_slice_type -= 5;\n        ps_dec->u1_sl_typ_5_9 = 1;\n }\n\n {\n        UWORD32 skip;\n\n if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)\n || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))\n {\n            UWORD32 u4_bit_stream_offset = 0;\n\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else if((I_SLICE == u1_slice_type)\n && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else\n {\n                skip = 1;\n }\n\n \/* If one frame worth of data is already skipped, do not skip the next one *\/\n if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))\n {\n                skip = 0;\n }\n\n if(skip)\n {\n                ps_dec->u4_prev_nal_skipped = 1;\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;\n return 0;\n }\n else\n {\n \/* If the previous NAL was skipped, then\n                 do not process that buffer in this call.\n                 Return to app and process it in the next call.\n                 This is necessary to handle cases where I\/IDR is not complete in\n                 the current buffer and application intends to fill the remaining part of the bitstream\n                 later. This ensures we process only frame worth of data in every call *\/\n if(1 == ps_dec->u4_prev_nal_skipped)\n {\n                    ps_dec->u4_return_to_app = 1;\n return 0;\n }\n }\n }\n\n }\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp & MASK_ERR_PIC_SET_ID)\n return ERROR_INV_SPS_PPS_T;\n \/* discard slice if pic param is invalid *\/\n    COPYTHECONTEXT(\"SH: pic_parameter_set_id\", u4_temp);\n    ps_pps = &ps_dec->ps_pps[u4_temp];\n if(FALSE == ps_pps->u1_is_valid)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n    ps_seq = ps_pps->ps_sps;\n if(!ps_seq)\n return ERROR_INV_SPS_PPS_T;\n if(FALSE == ps_seq->u1_is_valid)\n return ERROR_INV_SPS_PPS_T;\n\n \/* Get the frame num *\/\n    u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,\n                                         ps_seq->u1_bits_in_frm_num);\n\n    COPYTHECONTEXT(\"SH: frame_num\", u2_frame_num);\n\n \/* Get the field related flags  *\/\n if(!ps_seq->u1_frame_mbs_only_flag)\n {\n\n        u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);\n        COPYTHECONTEXT(\"SH: field_pic_flag\", u1_field_pic_flag);\n        u1_bottom_field_flag = 0;\n\n if(u1_field_pic_flag)\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;\n            u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: bottom_field_flag\", u1_bottom_field_flag);\n\n }\n else\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n }\n else\n {\n        u1_field_pic_flag = 0;\n        u1_bottom_field_flag = 0;\n\n        ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n\n    u1_nal_unit_type = SLICE_NAL;\n if(u1_is_idr_slice)\n {\n if(0 == u1_field_pic_flag)\n {\n            ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n }\n        u1_nal_unit_type = IDR_SLICE_NAL;\n        u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,\n                                   pu4_bitstrm_buf);\n if(u4_idr_pic_id > 65535)\n return ERROR_INV_SPS_PPS_T;\n        COPYTHECONTEXT(\"SH:  \", u4_idr_pic_id);\n }\n\n \/* read delta pic order count information*\/\n    i_delta_poc[0] = i_delta_poc[1] = 0;\n    s_tmp_poc.i4_pic_order_cnt_lsb = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;\n    u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;\n if(u1_pic_order_cnt_type == 0)\n {\n        i_temp = ih264d_get_bits_h264(\n                        ps_bitstrm,\n                        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);\n if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)\n return ERROR_INV_SPS_PPS_T;\n        s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;\n        COPYTHECONTEXT(\"SH: pic_order_cnt_lsb\", s_tmp_poc.i4_pic_order_cnt_lsb);\n\n if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))\n {\n            s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt_bottom\",\n                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);\n }\n }\n\n    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;\n if(u1_pic_order_cnt_type == 1\n && (!ps_seq->u1_delta_pic_order_always_zero_flag))\n {\n        s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SH: delta_pic_order_cnt[0]\",\n                        s_tmp_poc.i4_delta_pic_order_cnt[0]);\n\n if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)\n {\n            s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt[1]\",\n                            s_tmp_poc.i4_delta_pic_order_cnt[1]);\n }\n }\n\n if(ps_pps->u1_redundant_pic_cnt_present_flag)\n {\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_REDUNDANT_PIC_CNT)\n return ERROR_INV_SPS_PPS_T;\n        u1_redundant_pic_cnt = u4_temp;\n        COPYTHECONTEXT(\"SH: redundant_pic_cnt\", u1_redundant_pic_cnt);\n }\n\n \/*--------------------------------------------------------------------*\/\n \/* Check if the slice is part of new picture                          *\/\n \/*--------------------------------------------------------------------*\/\n    i1_is_end_of_poc = 0;\n if(!ps_dec->u1_first_slice_in_stream)\n {\n        i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,\n &s_tmp_poc, &ps_dec->s_cur_pic_poc,\n                                            ps_cur_slice, u1_pic_order_cnt_type,\n                                            u1_nal_unit_type, u4_idr_pic_id,\n                                            u1_field_pic_flag,\n                                            u1_bottom_field_flag);\n\n \/* since we support only Full frame decode, every new process should\n         * process a new pic\n         *\/\n if((ps_dec->u4_first_slice_in_pic == 2) && (i1_is_end_of_poc == 0))\n {\n \/* if it is the first slice is process call ,it should be a new frame. If it is not\n             * reject current pic and dont add it to dpb\n             *\/\n            ps_dec->ps_dec_err_status->u1_err_flag |= REJECT_CUR_PIC;\n            i1_is_end_of_poc = 1;\n }\n else\n {\n \/* reset REJECT_CUR_PIC *\/\n            ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;\n }\n }\n\n \/*--------------------------------------------------------------------*\/\n \/* Check for error in slice and parse the missing\/corrupted MB's      *\/\n \/* as skip-MB's in an inserted P-slice                                *\/\n \/*--------------------------------------------------------------------*\/\n    u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);\n    prev_slice_err = 0;\n\n if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)\n {\n if(u2_frame_num != ps_dec->u2_prv_frame_num\n && ps_dec->u1_top_bottom_decoded != 0\n && ps_dec->u1_top_bottom_decoded\n != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))\n {\n            ps_dec->u1_dangling_field = 1;\n if(ps_dec->u4_first_slice_in_pic)\n {\n                prev_slice_err = 1;\n }\n else\n {\n                prev_slice_err = 2;\n }\n\n if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)\n                ps_cur_slice->u1_bottom_field_flag = 1;\n else\n                ps_cur_slice->u1_bottom_field_flag = 0;\n\n            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &ps_dec->s_cur_pic_poc;\n\n            u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;\n }\n else if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice > 0)\n {\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n                ps_cur_poc = &s_tmp_poc;\n\n                ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n                ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n                ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n                ps_cur_slice->i4_pic_order_cnt_lsb =\n                        s_tmp_poc.i4_pic_order_cnt_lsb;\n                ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n                ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n                ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n                ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n }\n }\n else\n {\n\n if(ps_dec->u4_first_slice_in_pic)\n {\n \/* if valid slice header is not decoded do start of pic processing\n                 * since in the current process call, frame num is not updated in the slice structure yet\n                 * ih264d_is_end_of_pic is checked with valid frame num of previous process call,\n                 * although i1_is_end_of_poc is set there could be  more slices in the frame,\n                 * so conceal only till cur slice *\/\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n }\n else\n {\n \/* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame\n                 * completely *\/\n                prev_slice_err = 2;\n                num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n }\n            ps_cur_poc = &s_tmp_poc;\n }\n }\n else\n {\n if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)\n {\n            prev_slice_err = 2;\n            num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &s_tmp_poc;\n }\n else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)\n {\n return ERROR_CORRUPTED_SLICE;\n }\n }\n\n if(prev_slice_err)\n {\n        ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);\n\n if(ps_dec->u1_dangling_field == 1)\n {\n            ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;\n            ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n            ps_dec->u2_prv_frame_num = u2_frame_num;\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_DANGLING_FIELD_IN_PIC;\n }\n\n if(prev_slice_err == 2)\n {\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_INCOMPLETE_FRAME;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n \/* return if all MBs in frame are parsed*\/\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_IN_LAST_SLICE_OF_PIC;\n }\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n            ih264d_err_pic_dispbuf_mgr(ps_dec);\n return ERROR_NEW_FRAME_EXPECTED;\n }\n\n if(ret != OK)\n return ret;\n\n        i1_is_end_of_poc = 0;\n }\n\n if (ps_dec->u4_first_slice_in_pic == 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->u1_slice_header_done = 0;\n\n \/*--------------------------------------------------------------------*\/\n \/* If the slice is part of new picture, do End of Pic processing.     *\/\n \/*--------------------------------------------------------------------*\/\n if(!ps_dec->u1_first_slice_in_stream)\n {\n        UWORD8 uc_mbs_exceed = 0;\n\n if(ps_dec->u2_total_mbs_coded\n == (ps_dec->ps_cur_sps->u2_max_mb_addr + 1))\n {\n \/*u2_total_mbs_coded is forced  to u2_max_mb_addr+ 1 at the end of decode ,so\n             ,if it is first slice in pic dont consider u2_total_mbs_coded to detect new picture *\/\n if(ps_dec->u4_first_slice_in_pic == 0)\n                uc_mbs_exceed = 1;\n }\n\n if(i1_is_end_of_poc || uc_mbs_exceed)\n {\n\n if(1 == ps_dec->u1_last_pic_not_decoded)\n {\n                ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n\n if(ret != OK)\n return ret;\n\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n if(ret != OK)\n return ret;\n#if WIN32\n                H264_DEC_DEBUG_PRINT(\" ------ PIC SKIPPED ------\\n\");\n#endif\n return RET_LAST_SKIP;\n }\n else\n {\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n if(ret != OK)\n return ret;\n }\n\n }\n }\n\n if(u1_field_pic_flag)\n {\n        ps_dec->u2_prv_frame_num = u2_frame_num;\n }\n\n if(ps_cur_slice->u1_mmco_equalto5)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n\n if(!ps_cur_slice->u1_field_pic_flag) \/\/ or a complementary field pair\n {\n            i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n            i4_bot_field_order_poc =\n                            ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n            i4_temp_poc = MIN(i4_top_field_order_poc,\n                                     i4_bot_field_order_poc);\n }\n else if(!ps_cur_slice->u1_bottom_field_flag)\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n else\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n\n        ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n        ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,\n &ps_dec->s_prev_pic_poc,\n &s_tmp_poc, ps_cur_slice, ps_pps,\n                                          u1_nal_ref_idc,\n                                          u1_bottom_field_flag,\n                                          u1_field_pic_flag, &i4_poc);\n if(ret != OK)\n return ret;\n \/* Display seq no calculations *\/\n if(i4_poc >= ps_dec->i4_max_poc)\n            ps_dec->i4_max_poc = i4_poc;\n \/* IDR Picture or POC wrap around *\/\n if(i4_poc == 0)\n {\n            ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq\n + ps_dec->i4_max_poc\n + ps_dec->u1_max_dec_frame_buffering + 1;\n            ps_dec->i4_max_poc = 0;\n }\n }\n\n \/*--------------------------------------------------------------------*\/\n \/* Copy the values read from the bitstream to the slice header and then*\/\n \/* If the slice is first slice in picture, then do Start of Picture   *\/\n \/* processing.                                                        *\/\n \/*--------------------------------------------------------------------*\/\n    ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];\n    ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];\n    ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n    ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;\n    ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n    ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n    ps_cur_slice->u1_slice_type = u1_slice_type;\n    ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;\n\n    ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n    ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n    ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n    ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n\n if(ps_seq->u1_frame_mbs_only_flag)\n        ps_cur_slice->u1_direct_8x8_inference_flag =\n                        ps_seq->u1_direct_8x8_inference_flag;\n else\n        ps_cur_slice->u1_direct_8x8_inference_flag = 1;\n\n if(u1_slice_type == B_SLICE)\n {\n        ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SH: direct_spatial_mv_pred_flag\",\n                        ps_cur_slice->u1_direct_spatial_mv_pred_flag);\n\n if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;\n else\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;\n }\n else\n {\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n }\n\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice == 0)\n {\n            ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);\n if(ret != OK)\n return ret;\n }\n\n        ps_dec->u4_output_present = 0;\n\n {\n            ih264d_get_next_display_field(ps_dec,\n                                          ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n \/* If error code is non-zero then there is no buffer available for display,\n             hence avoid format conversion *\/\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                ps_dec->u4_output_present = 1;\n }\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                ps_dec->u4_start_recon_deblk = 0;\n                ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n\n }\n\n \/* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions *\/\n {\n        UWORD8 uc_nofield_nombaff;\n\n\n\n        uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)\n && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)\n && (u1_slice_type != B_SLICE)\n && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));\n\n \/* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc *\/\n\n if(uc_nofield_nombaff)\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n }\n else\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;\n }\n\n\n }\n\n \/*\n     * Decide whether to decode the current picture or not\n     *\/\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_err->u4_frm_sei_sync == u2_frame_num)\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n            ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;\n }\n        ps_err->u4_cur_frm = u2_frame_num;\n }\n\n \/* Decision for decoding if the picture is to be skipped *\/\n {\n        WORD32 i4_skip_b_pic, i4_skip_p_pic;\n\n        i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)\n && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n        i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)\n && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n \/**************************************************************\/\n \/* Skip the B picture if skip mask is set for B picture and   *\/\n \/* Current B picture is a non reference B picture or there is *\/\n \/* no user for reference B picture                            *\/\n \/**************************************************************\/\n if(i4_skip_b_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n \/* Don't decode the picture in SKIP-B mode if that picture is B *\/\n \/* and also it is not to be used as a reference picture         *\/\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n \/**************************************************************\/\n \/* Skip the P picture if skip mask is set for P picture and   *\/\n \/* Current P picture is a non reference P picture or there is *\/\n \/* no user for reference P picture                            *\/\n \/**************************************************************\/\n if(i4_skip_p_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n \/* Don't decode the picture in SKIP-P mode if that picture is P *\/\n \/* and also it is not to be used as a reference picture         *\/\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n }\n\n {\n        UWORD16 u2_mb_x, u2_mb_y;\n\n        ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice\n << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)\n - SUB_BLK_SIZE;\n if(u2_first_mb_in_slice)\n {\n            UWORD8 u1_mb_aff;\n            UWORD8 u1_field_pic;\n            UWORD16 u2_frm_wd_in_mbs;\n            u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n            u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;\n            u1_field_pic = ps_cur_slice->u1_field_pic_flag;\n\n {\n                UWORD32 x_offset;\n                UWORD32 y_offset;\n                UWORD32 u4_frame_stride;\n tfr_ctxt_t *ps_trns_addr; \/\/ = &ps_dec->s_tran_addrecon_parse;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n                u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n                u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n\n                u2_mb_y <<= u1_mb_aff;\n\n if((u2_mb_x > u2_frm_wd_in_mbs - 1)\n || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n                u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;\n                x_offset = u2_mb_x << 4;\n                y_offset = (u2_mb_y * u4_frame_stride) << 4;\n\n                ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset\n + y_offset;\n\n                u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;\n                x_offset >>= 1;\n                y_offset = (u2_mb_y * u4_frame_stride) << 3;\n\n                x_offset *= YUV420SP_FACTOR;\n\n                ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset\n + y_offset;\n                ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset\n + y_offset;\n\n                ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n                ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n                ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n\n if(ps_dec->u1_separate_parse == 1)\n {\n                    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n else\n {\n                        ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n\n                ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);\n\n                ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv\n + ((u2_first_mb_in_slice << u1_mb_aff) << 4);\n }\n }\n else\n {\n tfr_ctxt_t *ps_trns_addr;\n\n if(ps_dec->u1_separate_parse)\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n\n            u2_mb_x = 0xffff;\n            u2_mb_y = 0;\n            ps_dec->u2_cur_mb_addr = 0;\n            ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n            ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n            ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n            ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n            ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n            ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n            ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n            ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n }\n\n        ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n        ps_dec->u2_mbx =\n (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby =\n (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;\n        ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n        ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n }\n\n \/* RBSP stop bit is used for CABAC decoding*\/\n    ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;\n\n    ps_dec->u1_B = (u1_slice_type == B_SLICE);\n    ps_dec->u4_next_mb_skip = 0;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =\n                    ps_dec->ps_cur_slice->u2_first_mb_in_slice;\n    ps_dec->ps_parse_cur_slice->slice_type =\n                    ps_dec->ps_cur_slice->u1_slice_type;\n\n\n    ps_dec->u4_start_recon_deblk = 1;\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MAX_FRAMES;\n if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n (0 == ps_dec->i4_display_delay))\n {\n            num_entries = 1;\n }\n        num_entries = ((2 * num_entries) + 1);\n if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)\n {\n            num_entries *= 2;\n }\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;\n }\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n\n         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n     }\n \n    ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\n     if(u1_slice_type == I_SLICE)\n     {\n         ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;\n\n        ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);\n\n if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)\n            ps_dec->i4_pic_type = I_SLICE;\n\n }\n else if(u1_slice_type == P_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n        ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n if(ps_dec->i4_pic_type != B_SLICE)\n            ps_dec->i4_pic_type = P_SLICE;\n }\n else if(u1_slice_type == B_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n        ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n        ps_dec->i4_pic_type = B_SLICE;\n }\n else\n return ERROR_INV_SLC_TYPE_T;\n\n if(ps_dec->u1_slice_header_done)\n {\n \/* set to zero to indicate a valid slice has been decoded *\/\n \/* first slice header successfully decoded *\/\n        ps_dec->u4_first_slice_in_pic = 0;\n        ps_dec->u1_first_slice_in_stream = 0;\n }\n\n if(ret != OK)\n return ret;\n\n    ps_dec->u2_cur_slice_num++;\n \/* storing last Mb X and MbY of the slice *\/\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n \/* End of Picture detection *\/\n\n if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))\n {\n        ps_dec->u1_pic_decode_done = 1;\n\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if((ps_err->u1_err_flag & REJECT_PB_PICS)\n && (ps_err->u1_cur_pic_type == PIC_TYPE_I))\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n    PRINT_BIN_BIT_RATIO(ps_dec)\n\n return ret;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* Chapters::Display::GetString() const\n{\n    return m_string;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* Track::GetCodecId() const\n{\n    return m_info.codecId;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_rgb_to_cmyk(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tint sn = src->n;\n\tint ss = src->s;\n\tint sa = src->alpha;\n\tint dn = dst->n;\n\tint ds = dst->s;\n\tint da = dst->alpha;\n\tptrdiff_t d_line_inc = dst->stride - w * dn;\n\tptrdiff_t s_line_inc = src->stride - w * sn;\n\n\t\/* Spots must match, and we can never drop alpha (but we can invent it) *\/\n\tif ((copy_spots || ss != ds) || (!da && sa))\n\t{\n\t\tassert(\"This should never happen\" == NULL);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Cannot convert between incompatible pixmaps\");\n\t}\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\tif (ss == 0 && ds == 0)\n\t{\n\t\t\/* Common, no spots case *\/\n\t\tif (da)\n\t\t{\n\t\t\tif (sa)\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char c = s[0];\n\t\t\t\t\t\tunsigned char m = s[1];\n\t\t\t\t\t\tunsigned char y = s[2];\n\t\t\t\t\t\tunsigned char k = (unsigned char)fz_mini(c, fz_mini(m, y));\n\t\t\t\t\t\td[0] = c - k;\n\t\t\t\t\t\td[1] = m - k;\n\t\t\t\t\t\td[2] = y - k;\n\t\t\t\t\t\td[3] = k;\n\t\t\t\t\t\td[4] = s[3];\n\t\t\t\t\t\ts += 4;\n\t\t\t\t\t\td += 5;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char c = s[0];\n\t\t\t\t\t\tunsigned char m = s[1];\n\t\t\t\t\t\tunsigned char y = s[2];\n\t\t\t\t\t\tunsigned char k = (unsigned char)fz_mini(c, fz_mini(m, y));\n\t\t\t\t\t\td[0] = c - k;\n\t\t\t\t\t\td[1] = m - k;\n\t\t\t\t\t\td[2] = y - k;\n\t\t\t\t\t\td[3] = k;\n\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\ts += 3;\n\t\t\t\t\t\td += 5;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\tunsigned char c = s[0];\n\t\t\t\t\tunsigned char m = s[1];\n\t\t\t\t\tunsigned char y = s[2];\n\t\t\t\t\tunsigned char k = (unsigned char)fz_mini(c, fz_mini(m, y));\n\t\t\t\t\td[0] = c - k;\n\t\t\t\t\td[1] = m - k;\n\t\t\t\t\td[2] = y - k;\n\t\t\t\t\td[3] = k;\n\t\t\t\t\ts += 3;\n\t\t\t\t\td += 4;\n\t\t\t\t}\n\t\t\t\td += d_line_inc;\n\t\t\t\ts += s_line_inc;\n\t\t\t}\n\t\t}\n\t}\n\telse if (copy_spots)\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\twhile (h--)\n\t\t{\n\t\t\tint i;\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tunsigned char c = s[0];\n\t\t\t\tunsigned char m = s[1];\n\t\t\t\tunsigned char y = s[2];\n\t\t\t\tunsigned char k = (unsigned char)fz_mini(c, fz_mini(m, y));\n\t\t\t\td[0] = c - k;\n\t\t\t\td[1] = m - k;\n\t\t\t\td[2] = y - k;\n\t\t\t\td[3] = k;\n\t\t\t\ts += 3;\n\t\t\t\td += 4;\n\t\t\t\tfor (i=ss; i > 0; i--)\n\t\t\t\t\t*d++ = *s++;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = sa ? *s++ : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tunsigned char c = s[0];\n\t\t\t\tunsigned char m = s[1];\n\t\t\t\tunsigned char y = s[2];\n\t\t\t\tunsigned char k = (unsigned char)(255 - fz_maxi(c, fz_maxi(m, y)));\n\t\t\t\td[0] = c + k;\n\t\t\t\td[1] = m + k;\n\t\t\t\td[2] = y + k;\n\t\t\t\td[3] = 255 - k;\n\t\t\t\ts += sn;\n\t\t\t\td += dn;\n\t\t\t\tif (da)\n\t\t\t\t\td[-1] = sa ? s[-1] : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":" long Cluster::HasBlockEntries(\n     const Segment* pSegment,\n    long long off,  \/\/relative to start of segment payload\n    long long& pos,\n    long& len)\n{\n    assert(pSegment);\n    assert(off >= 0);  \/\/relative to segment\n \n    IMkvReader* const pReader = pSegment->m_pReader;\n \n    long long total, avail;\n \n    long status = pReader->Length(&total, &avail);\n \n    if (status < 0)  \/\/error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    pos = pSegment->m_start + off;  \/\/absolute\n \n    if ((total >= 0) && (pos >= total))\n        return 0;  \/\/we don't even have a complete cluster\n \n    const long long segment_stop =\n        (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;\n \n    long long cluster_stop = -1;  \/\/interpreted later to mean \"unknown size\"\n \n    {\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/need more data\n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((total >= 0) && ((pos + len) > total))\n            return 0;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0)  \/\/error\n            return static_cast<long>(id);\n        if (id != 0x0F43B675)  \/\/weird: not cluster ID\n            return -1;         \/\/generic error\n        pos += len;  \/\/consume Cluster ID field\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((total >= 0) && ((pos + len) > total))\n            return 0;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  \/\/error\n            return static_cast<long>(size);\n        if (size == 0)\n            return 0;  \/\/cluster does not have entries\n        pos += len;  \/\/consume size field\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size != unknown_size)\n        {\n            cluster_stop = pos + size;\n            assert(cluster_stop >= 0);\n            if ((segment_stop >= 0) && (cluster_stop > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n            if ((total >= 0) && (cluster_stop > total))\n                return 0;  \/\/cluster does not have any entries\n        }\n     }\n \n    for (;;)\n    {\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            return 0;  \/\/no entries detected\n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(pReader, pos, len);\n \n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n \n        if (result > 0)  \/\/need more data\n            return E_BUFFER_NOT_FULL;\n \n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long id = ReadUInt(pReader, pos, len);\n \n        if (id < 0)  \/\/error\n            return static_cast<long>(id);\n \n \n        if (id == 0x0F43B675)  \/\/Cluster ID\n            return 0;  \/\/no entries found\n \n        if (id == 0x0C53BB6B)  \/\/Cues ID\n            return 0;  \/\/no entries found\n        pos += len;  \/\/consume id field\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/underflow\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  \/\/error\n            return static_cast<long>(size);\n        pos += len;  \/\/consume size field\n        if ((cluster_stop >= 0) && (pos > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (size == 0)  \/\/weird\n            continue;\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;  \/\/not supported inside cluster\n        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (id == 0x20)  \/\/BlockGroup ID\n            return 1;    \/\/have at least one entry\n        if (id == 0x23)  \/\/SimpleBlock ID\n            return 1;    \/\/have at least one entry\n        pos += size;  \/\/consume payload\n        assert((cluster_stop < 0) || (pos <= cluster_stop));\n     }\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_gray_to_cmyk(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tint sn = src->n;\n\tint ss = src->s;\n\tint sa = src->alpha;\n\tint dn = dst->n;\n\tint ds = dst->s;\n\tint da = dst->alpha;\n\tptrdiff_t d_line_inc = dst->stride - w * dn;\n\tptrdiff_t s_line_inc = src->stride - w * sn;\n\n\t\/* If copying spots, they must match, and we can never drop alpha (but we can invent it) *\/\n\tif ((copy_spots && ss != ds) || (!da && sa))\n\t{\n\t\tassert(\"This should never happen\" == NULL);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Cannot convert between incompatible pixmaps\");\n\t}\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\tif (ss == 0 && ds == 0)\n\t{\n\t\t\/* Common, no spots case *\/\n\t\tif (da)\n\t\t{\n\t\t\tif (sa)\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = 0;\n\t\t\t\t\t\td[1] = 0;\n\t\t\t\t\t\td[2] = 0;\n\t\t\t\t\t\td[3] = 255 - s[0];\n\t\t\t\t\t\td[4] = s[1];\n\t\t\t\t\t\ts += 2;\n\t\t\t\t\t\td += 5;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = 0;\n\t\t\t\t\t\td[1] = 0;\n\t\t\t\t\t\td[2] = 0;\n\t\t\t\t\t\td[3] = 255 - s[0];\n\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\ts++;\n\t\t\t\t\t\td += 5;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\td[0] = 0;\n\t\t\t\t\td[1] = 0;\n\t\t\t\t\td[2] = 0;\n\t\t\t\t\td[3] = 255 - s[0];\n\t\t\t\t\ts++;\n\t\t\t\t\td += 4;\n\t\t\t\t}\n\t\t\t\td += d_line_inc;\n\t\t\t\ts += s_line_inc;\n\t\t\t}\n\t\t}\n\t}\n\telse if (copy_spots)\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\tint i;\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = 0;\n\t\t\t\td[1] = 0;\n\t\t\t\td[2] = 0;\n\t\t\t\td[3] = 255 - s[0];\n\t\t\t\ts += 1;\n\t\t\t\td += 4;\n\t\t\t\tfor (i=ss; i > 0; i--)\n\t\t\t\t\t*d++ = *s++;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = sa ? *s++ : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = 0;\n\t\t\t\td[1] = 0;\n\t\t\t\td[2] = 0;\n\t\t\t\td[3] = 255 - s[0];\n\t\t\t\ts += sn;\n\t\t\t\td += dn;\n\t\t\t\tif (da)\n\t\t\t\t\td[-1] = sa ? s[-1] : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunInvAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        in[j] = src[j] - dst[j];\n       }\n \n       fwd_txfm_ref(in, coeff, pitch_, tx_type_);\n \n      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n        EXPECT_GE(1u, error)\n            << \"Error: 16x16 IDCT has error \" << error\n             << \" at index \" << j;\n       }\n     }\n }\n","project":"Android","target":1},{"commit_id":"1e72dc7a3074cd0b44d89afbf39bbf5000ef7cc3","func":"static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\n if (parcel == NULL) {\n return NULL;\n }\n\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n\n const size_t size = p->readInt32();\n const void* regionData = p->readInplace(size);\n if (regionData == NULL) {\n\n         return NULL;\n     }\n     SkRegion* region = new SkRegion;\n    region->readFromMemory(regionData, size);\n \n     return reinterpret_cast<jlong>(region);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void rgb_to_cmyk(fz_context *ctx, const fz_colorspace *cs, const float *rgb, float *cmyk)\n{\n\tfloat c, m, y, k;\n\tc = 1 - rgb[0];\n\tm = 1 - rgb[1];\n\ty = 1 - rgb[2];\n\tk = fz_min(c, fz_min(m, y));\n\tcmyk[0] = c - k;\n\tcmyk[1] = m - k;\n\tcmyk[2] = y - k;\n\tcmyk[3] = k;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Chapters::Edition::ParseAtom(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    if (!ExpandAtomsArray())\n        return -1;\n \n    Atom& a = m_atoms[m_atoms_count++];\n    a.Init();\n \n    return a.Parse(pReader, pos, size);\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   static void SetUpTestCase() {\n    source_data_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBlockSize));\n    reference_data_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kDataBufferSize));\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"CuePoint::~CuePoint()\n{\n    delete[] m_track_positions;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"EBMLHeader::~EBMLHeader()\n{\n     delete[] m_docType;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_icc(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->flags & FZ_COLORSPACE_IS_ICC);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void Predict(MB_PREDICTION_MODE mode) {\n     mbptr_->mode_info_context->mbmi.mode = mode;\n    REGISTER_STATE_CHECK(pred_fn_(mbptr_,\n                                  data_ptr_[0] - kStride,\n                                  data_ptr_[0] - 1, kStride,\n                                  data_ptr_[0], kStride));\n   }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"attrhash_finish (void)\n{\n  hash_free (attrhash);\n  attrhash = NULL;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_drop_colorspace_store_key(fz_context *ctx, fz_colorspace *cs)\n{\n\tfz_drop_key_storable_key(ctx, &cs->key_storable);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_bgr_to_gray(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tint sn = src->n;\n\tint ss = src->s;\n\tint sa = src->alpha;\n\tint dn = dst->n;\n\tint ds = dst->s;\n\tint da = dst->alpha;\n\tptrdiff_t d_line_inc = dst->stride - w * dn;\n\tptrdiff_t s_line_inc = src->stride - w * sn;\n\n\t\/* If copying spots, they must match, and we can never drop alpha (but we can invent it) *\/\n\tif ((copy_spots && ss != ds) || (!da && sa))\n\t{\n\t\tassert(\"This should never happen\" == NULL);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Cannot convert between incompatible pixmaps\");\n\t}\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\tif (ss == 0 && ds == 0)\n\t{\n\t\t\/* Common, no spots case *\/\n\t\tif (da)\n\t\t{\n\t\t\tif (sa)\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = ((s[0]+1) * 28 + (s[1]+1) * 150 + (s[2]+1) * 77) >> 8;\n\t\t\t\t\t\td[1] = s[3];\n\t\t\t\t\t\ts += 4;\n\t\t\t\t\t\td += 2;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = ((s[0]+1) * 28 + (s[1]+1) * 150 + (s[2]+1) * 77) >> 8;\n\t\t\t\t\t\td[1] = 255;\n\t\t\t\t\t\ts += 3;\n\t\t\t\t\t\td += 2;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint si = 3 + src->alpha;\n\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\td[0] = ((s[0]+1) * 28 + (s[1]+1) * 150 + (s[2]+1) * 77) >> 8;\n\t\t\t\t\ts += si;\n\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\td += d_line_inc;\n\t\t\t\ts += s_line_inc;\n\t\t\t}\n\t\t}\n\t}\n\telse if (copy_spots)\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\twhile (h--)\n\t\t{\n\t\t\tint i;\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = ((s[0]+1) * 28 + (s[1]+1) * 150 + (s[2]+1) * 77) >> 8;\n\t\t\t\ts += 3;\n\t\t\t\td++;\n\t\t\t\tfor (i=ss; i > 0; i--)\n\t\t\t\t\t*d++ = *s++;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = sa ? *s++ : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = ((s[0]+1) * 28 + (s[1]+1) * 150 + (s[2]+1) * 77) >> 8;\n\t\t\t\ts += sn;\n\t\t\t\td += dn;\n\t\t\t\tif (da)\n\t\t\t\t\td[-1] = sa ? s[-1] : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Block::IsKey() const\n{\n    return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Segment::DoLoadClusterUnknownSize(\n    long long& pos,\n    long& len)\n{\n    assert(m_pos < 0);\n    assert(m_pUnknownSize);\n \n #if 0\n     assert(m_pUnknownSize->GetElementSize() < 0);  \/\/TODO: verify this\n\n const long long element_start = m_pUnknownSize->m_element_start;\n\n    pos = -m_pos;\n    assert(pos > element_start);\n\n\n long long total, avail;\n\n long status = m_pReader->Length(&total, &avail);\n\n if (status < 0) \/\/error\n return status;\n\n    assert((total < 0) || (avail <= total));\n\n const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n\n \n     long long element_size = -1;\n \n    for (;;)  \/\/determine cluster size\n    {\n         if ((total >= 0) && (pos >= total))\n         {\n             element_size = total - element_start;\n            assert(element_size > 0);\n\n break;\n }\n\n if ((segment_stop >= 0) && (pos >= segment_stop))\n {\n            element_size = segment_stop - element_start;\n            assert(element_size > 0);\n\n break;\n }\n\n\n if ((pos + 1) > avail)\n {\n            len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \/\/error\n return static_cast<long>(result);\n\n if (result > 0) \/\/weird\n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long idpos = pos;\n const long long id = ReadUInt(m_pReader, idpos, len);\n\n if (id < 0) \/\/error (or underflow)\n return static_cast<long>(id);\n\n\n \n        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) \/\/Cluster ID or Cues ID\n        {\n             element_size = pos - element_start;\n             assert(element_size > 0);\n \n break;\n }\n\n#ifdef _DEBUG\n switch (id)\n {\n case 0x20: \/\/BlockGroup\n case 0x23: \/\/Simple Block\n case 0x67: \/\/TimeCode\n case 0x2B: \/\/PrevSize\n break;\n\n default:\n                assert(false);\n break;\n }\n#endif\n\n        pos += len; \/\/consume ID (of sub-element)\n\n\n if ((pos + 1) > avail)\n {\n            len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n        result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) \/\/error\n return static_cast<long>(result);\n\n if (result > 0) \/\/weird\n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) \/\/error\n return static_cast<long>(size);\n\n        pos += len; \/\/consume size field of element\n\n\n if (size == 0) \/\/weird\n continue;\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID; \/\/not allowed for sub-elements\n\n if ((segment_stop >= 0) && ((pos + size) > segment_stop)) \/\/weird\n return E_FILE_FORMAT_INVALID;\n\n        pos += size; \/\/consume payload of sub-element\n        assert((segment_stop < 0) || (pos <= segment_stop));\n } \/\/determine cluster size\n\n    assert(element_size >= 0);\n\n    m_pos = element_start + element_size;\n    m_pUnknownSize = 0;\n\n \n     return 2;  \/\/continue parsing\n #else\n    const long status = m_pUnknownSize->Parse(pos, len);\n \n    if (status < 0)  \/\/error or underflow\n        return status;\n \n    if (status == 0)  \/\/parsed a block\n        return 2;     \/\/continue parsing\n \n    assert(status > 0);   \/\/nothing left to parse of this cluster\n \n    const long long start = m_pUnknownSize->m_element_start;\n \n    const long long size = m_pUnknownSize->GetElementSize();\n    assert(size >= 0);\n \n    pos = start + size;\n    m_pos = pos;\n \n    m_pUnknownSize = 0;\n \n    return 2;  \/\/continue parsing\n #endif\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void rgb_to_bgr(fz_context *ctx, const fz_colorspace *cs, const float *rgb, float *bgr)\n{\n\tbgr[0] = rgb[2];\n\tbgr[1] = rgb[1];\n\tbgr[2] = rgb[0];\n}\n","project":"ghostscript","target":0},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"static long timelib_parse_tz_cor(char **ptr)\n{\n\tchar *begin = *ptr, *end;\n\tlong  tmp;\n\n\twhile (isdigit(**ptr) || **ptr == ':') {\n\t\t++*ptr;\n\t}\n\tend = *ptr;\n\tswitch (end - begin) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\treturn HOUR(strtol(begin, NULL, 10));\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\t\tif (begin[1] == ':') {\n\t\t\t\ttmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 2, NULL, 10);\n\t\t\t\treturn tmp;\n\t\t\t} else if (begin[2] == ':') {\n\t\t\t\ttmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);\n\t\t\t\treturn tmp;\n\t\t\t} else {\n\t\t\t\ttmp = strtol(begin, NULL, 10);\n\t\t\t\treturn HOUR(tmp \/ 100) + tmp % 100;\n\t\t\t}\n\t\tcase 5:\n\t\t\ttmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);\n\t\t\treturn tmp;\n\t}\n\treturn 0;\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool mkvparser::Match(\n    IMkvReader* pReader,\n    long long& pos,\n    unsigned long id_,\n    long long& val)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    long long total, available;\n \n    const long status = pReader->Length(&total, &available);\n    assert(status >= 0);\n    assert((total < 0) || (available <= total));\n    if (status < 0)\n        return false;\n \n    long len;\n \n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);\n    assert(len > 0);\n    assert(len <= 8);\n    assert((pos + len) <= available);\n \n    if ((unsigned long)id != id_)\n        return false;\n \n    pos += len;  \/\/consume id\n \n    const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0);\n    assert(size <= 8);\n    assert(len > 0);\n    assert(len <= 8);\n    assert((pos + len) <= available);\n \n    pos += len;  \/\/consume length of size of payload\n \n    val = UnserializeUInt(pReader, pos, size);\n    assert(val >= 0);\n \n    pos += size;  \/\/consume size of payload\n    return true;\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int php_openssl_make_REQ(struct php_x509_request * req, X509_REQ * csr, zval * dn, zval * attribs TSRMLS_DC)\n{\n\tSTACK_OF(CONF_VALUE) * dn_sk, *attr_sk = NULL;\n\tchar * str, *dn_sect, *attr_sect;\n\n\tdn_sect = CONF_get_string(req->req_config, req->section_name, \"distinguished_name\");\n\tif (dn_sect == NULL) {\n\t\treturn FAILURE;\n\t}\n\tdn_sk = CONF_get_section(req->req_config, dn_sect);\n\tif (dn_sk == NULL) { \n\t\treturn FAILURE;\n\t}\n\tattr_sect = CONF_get_string(req->req_config, req->section_name, \"attributes\");\n\tif (attr_sect == NULL) {\n\t\tattr_sk = NULL;\n\t} else {\n\t\tattr_sk = CONF_get_section(req->req_config, attr_sect);\n\t\tif (attr_sk == NULL) {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\t\/* setup the version number: version 1 *\/\n\tif (X509_REQ_set_version(csr, 0L)) {\n\t\tint i, nid;\n\t\tchar * type;\n\t\tCONF_VALUE * v;\n\t\tX509_NAME * subj;\n\t\tHashPosition hpos;\n\t\tzval ** item;\n\t\t\n\t\tsubj = X509_REQ_get_subject_name(csr);\n\t\t\/* apply values from the dn hash *\/\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(dn), &hpos);\n\t\twhile(zend_hash_get_current_data_ex(HASH_OF(dn), (void**)&item, &hpos) == SUCCESS) {\n\t\t\tchar * strindex = NULL; \n\t\t\tuint strindexlen = 0;\n\t\t\tulong intindex;\n\t\t\t\n\t\t\tzend_hash_get_current_key_ex(HASH_OF(dn), &strindex, &strindexlen, &intindex, 0, &hpos);\n\n\t\t\tconvert_to_string_ex(item);\n\n\t\t\tif (strindex) {\n\t\t\t\tint nid;\n\n\t\t\t\tnid = OBJ_txt2nid(strindex);\n\t\t\t\tif (nid != NID_undef) {\n\t\t\t\t\tif (!X509_NAME_add_entry_by_NID(subj, nid, MBSTRING_ASC, \n\t\t\t\t\t\t\t\t(unsigned char*)Z_STRVAL_PP(item), -1, -1, 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"dn: add_entry_by_NID %d -> %s (failed)\", nid, Z_STRVAL_PP(item));\n\t\t\t\t\t\treturn FAILURE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"dn: %s is not a recognized name\", strindex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_move_forward_ex(HASH_OF(dn), &hpos);\n\t\t}\n\n\t\t\/* Finally apply defaults from config file *\/\n\t\tfor(i = 0; i < sk_CONF_VALUE_num(dn_sk); i++) {\n\t\t\tint len;\n\t\t\tchar buffer[200 + 1]; \/*200 + \\0 !*\/\n\t\t\t\n\t\t\tv = sk_CONF_VALUE_value(dn_sk, i);\n\t\t\ttype = v->name;\n\t\t\t\n\t\t\tlen = strlen(type);\n\t\t\tif (len < sizeof(\"_default\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen -= sizeof(\"_default\") - 1;\n\t\t\tif (strcmp(\"_default\", type + len) != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (len > 200) {\n\t\t\t\tlen = 200;\n\t\t\t}\n\t\t\tmemcpy(buffer, type, len);\n\t\t\tbuffer[len] = '\\0';\n\t\t\ttype = buffer;\n\t\t\n\t\t\t\/* Skip past any leading X. X: X, etc to allow for multiple\n\t\t\t * instances *\/\n\t\t\tfor (str = type; *str; str++) {\n\t\t\t\tif (*str == ':' || *str == ',' || *str == '.') {\n\t\t\t\t\tstr++;\n\t\t\t\t\tif (*str) {\n\t\t\t\t\t\ttype = str;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/* if it is already set, skip this *\/\n\t\t\tnid = OBJ_txt2nid(type);\n\t\t\tif (X509_NAME_get_index_by_NID(subj, nid, -1) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!X509_NAME_add_entry_by_txt(subj, type, MBSTRING_ASC, (unsigned char*)v->value, -1, -1, 0)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_entry_by_txt %s -> %s (failed)\", type, v->value);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (!X509_NAME_entry_count(subj)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"no objects specified in config file\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t\tif (attribs) {\n\t\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(attribs), &hpos);\n\t\t\twhile(zend_hash_get_current_data_ex(HASH_OF(attribs), (void**)&item, &hpos) == SUCCESS) {\n\t\t\t\tchar *strindex = NULL;\n\t\t\t\tuint strindexlen;\n\t\t\t\tulong intindex;\n\n\t\t\t\tzend_hash_get_current_key_ex(HASH_OF(attribs), &strindex, &strindexlen, &intindex, 0, &hpos);\n\t\t\t\tconvert_to_string_ex(item);\n\n\t\t\t\tif (strindex) {\n\t\t\t\t\tint nid;\n\n\t\t\t\t\tnid = OBJ_txt2nid(strindex);\n\t\t\t\t\tif (nid != NID_undef) {\n\t\t\t\t\t\tif (!X509_NAME_add_entry_by_NID(subj, nid, MBSTRING_ASC, (unsigned char*)Z_STRVAL_PP(item), -1, -1, 0)) {\n\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"attribs: add_entry_by_NID %d -> %s (failed)\", nid, Z_STRVAL_PP(item));\n\t\t\t\t\t\t\treturn FAILURE;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"dn: %s is not a recognized name\", strindex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzend_hash_move_forward_ex(HASH_OF(attribs), &hpos);\n\t\t\t}\n\t\t\tfor (i = 0; i < sk_CONF_VALUE_num(attr_sk); i++) {\n\t\t\t\tv = sk_CONF_VALUE_value(attr_sk, i);\n\t\t\t\t\/* if it is already set, skip this *\/\n\t\t\t\tnid = OBJ_txt2nid(v->name);\n\t\t\t\tif (X509_REQ_get_attr_by_NID(csr, nid, -1) >= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!X509_REQ_add1_attr_by_txt(csr, v->name, MBSTRING_ASC, (unsigned char*)v->value, -1)) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add1_attr_by_txt %s -> %s (failed)\", v->name, v->value);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tX509_REQ_set_pubkey(csr, req->priv_key);\n\treturn SUCCESS;\n}\n","project":"php","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAVCEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamVideoBitrate:\n {\n\n             OMX_VIDEO_PARAM_BITRATETYPE *bitRate =\n                 (OMX_VIDEO_PARAM_BITRATETYPE *) params;\n \n             if (bitRate->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            bitRate->eControlRate = OMX_Video_ControlRateVariable;\n            bitRate->nTargetBitrate = mBitrate;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoAvc:\n {\n\n             OMX_VIDEO_PARAM_AVCTYPE *avcParams =\n                 (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n             if (avcParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            avcParams->eProfile = OMX_VIDEO_AVCProfileBaseline;\n            OMX_U32 omxLevel = AVC_LEVEL2;\n if (OMX_ErrorNone !=\n ConvertAvcSpecLevelToOmxAvcLevel(mAVCEncLevel, &omxLevel)) {\n return OMX_ErrorUndefined;\n }\n\n            avcParams->eLevel = (OMX_VIDEO_AVCLEVELTYPE) omxLevel;\n            avcParams->nRefFrames = 1;\n            avcParams->nBFrames = 0;\n            avcParams->bUseHadamard = OMX_TRUE;\n            avcParams->nAllowedPictureTypes =\n (OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP);\n            avcParams->nRefIdx10ActiveMinus1 = 0;\n            avcParams->nRefIdx11ActiveMinus1 = 0;\n            avcParams->bWeightedPPrediction = OMX_FALSE;\n            avcParams->bEntropyCodingCABAC = OMX_FALSE;\n            avcParams->bconstIpred = OMX_FALSE;\n            avcParams->bDirect8x8Inference = OMX_FALSE;\n            avcParams->bDirectSpatialTemporal = OMX_FALSE;\n            avcParams->nCabacInitIdc = 0;\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"d2f47191538837e796e2b10c1ff7e1ee35f6e0ab","func":"void SoftAVC::onQueueFilled(OMX_U32 \/* portIndex *\/) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (mEOSStatus == OUTPUT_FRAMES_FLUSHED) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n if (mHeadersDecoded) {\n\n        drainAllOutputBuffers(false \/* eos *\/);\n }\n\n    H264SwDecRet ret = H264SWDEC_PIC_RDY;\n bool portWillReset = false;\n while ((mEOSStatus != INPUT_DATA_AVAILABLE || !inQueue.empty())\n && outQueue.size() == kNumOutputBuffers) {\n\n if (mEOSStatus == INPUT_EOS_SEEN) {\n            drainAllOutputBuffers(true \/* eos *\/);\n return;\n }\n\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n ++mPicId;\n\n        OMX_BUFFERHEADERTYPE *header = new OMX_BUFFERHEADERTYPE;\n        memset(header, 0, sizeof(OMX_BUFFERHEADERTYPE));\n        header->nTimeStamp = inHeader->nTimeStamp;\n        header->nFlags = inHeader->nFlags;\n if (header->nFlags & OMX_BUFFERFLAG_EOS) {\n            mEOSStatus = INPUT_EOS_SEEN;\n }\n        mPicToHeaderMap.add(mPicId, header);\n        inQueue.erase(inQueue.begin());\n\n        H264SwDecInput inPicture;\n        H264SwDecOutput outPicture;\n        memset(&inPicture, 0, sizeof(inPicture));\n        inPicture.dataLen = inHeader->nFilledLen;\n        inPicture.pStream = inHeader->pBuffer + inHeader->nOffset;\n        inPicture.picId = mPicId;\n        inPicture.intraConcealmentMethod = 1;\n        H264SwDecPicture decodedPicture;\n\n while (inPicture.dataLen > 0) {\n            ret = H264SwDecDecode(mHandle, &inPicture, &outPicture);\n if (ret == H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY ||\n                ret == H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY) {\n                inPicture.dataLen -= (u32)(outPicture.pStrmCurrPos - inPicture.pStream);\n                inPicture.pStream = outPicture.pStrmCurrPos;\n if (ret == H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY) {\n                    mHeadersDecoded = true;\n                    H264SwDecInfo decoderInfo;\n                    CHECK(H264SwDecGetInfo(mHandle, &decoderInfo) == H264SWDEC_OK);\n\n SoftVideoDecoderOMXComponent::CropSettingsMode cropSettingsMode =\n                        handleCropParams(decoderInfo);\n                    handlePortSettingsChange(\n &portWillReset, decoderInfo.picWidth, decoderInfo.picHeight,\n                            cropSettingsMode);\n }\n } else {\n if (portWillReset) {\n if (H264SwDecNextPicture(mHandle, &decodedPicture, 0)\n == H264SWDEC_PIC_RDY) {\n\n                        saveFirstOutputBuffer(\n                            decodedPicture.picId,\n (uint8_t *)decodedPicture.pOutputPicture);\n }\n }\n                inPicture.dataLen = 0;\n if (ret < 0) {\n                    ALOGE(\"Decoder failed: %d\", ret);\n\n                    notify(OMX_EventError, OMX_ErrorUndefined,\n                           ERROR_MALFORMED, NULL);\n\n                    mSignalledError = true;\n return;\n }\n }\n }\n        inInfo->mOwnedByUs = false;\n        notifyEmptyBufferDone(inHeader);\n\n if (portWillReset) {\n return;\n\n         }\n \n         if (mFirstPicture && !outQueue.empty()) {\n            drainOneOutputBuffer(mFirstPictureId, mFirstPicture);\n             delete[] mFirstPicture;\n             mFirstPicture = NULL;\n             mFirstPictureId = -1;\n }\n\n        drainAllOutputBuffers(false \/* eos *\/);\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long mkvparser::UnserializeInt(\n    IMkvReader* pReader,\n    long long pos,\n    long size,\n    long long& result)\n{\n    assert(pReader);\n    assert(pos >= 0);\n    assert(size > 0);\n    assert(size <= 8);\n \n    {\n        signed char b;\n \n        const long status = pReader->Read(pos, 1, (unsigned char*)&b);\n \n        if (status < 0)\n            return status;\n \n        result = b;\n \n        ++pos;\n    }\n \n    for (long i = 1; i < size; ++i)\n    {\n        unsigned char b;\n        const long status = pReader->Read(pos, 1, &b);\n        if (status < 0)\n            return status;\n        result <<= 8;\n        result |= b;\n        ++pos;\n    }\n    return 0;  \/\/success\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void SetUp() {\n\n     fwd_txfm_ = GET_PARAM(0);\n     inv_txfm_ = GET_PARAM(1);\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 16;\n     fwd_txfm_ref = fht16x16_ref;\n   }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_device_rgb(fz_context *ctx)\n{\n\treturn ctx->colorspace->rgb;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Cluster::GetLastTime() const\n{\n    const BlockEntry* pEntry;\n    const long status = GetLast(pEntry);\n    if (status < 0)  \/\/error\n        return status;\n    if (pEntry == NULL)  \/\/empty cluster\n        return GetTime();\n    const Block* const pBlock = pEntry->GetBlock();\n    assert(pBlock);\n    return pBlock->GetTime(this);\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkcs12_read)\n{\n\tzval *zout = NULL, *zextracerts, *zcert, *zpkey;\n\tchar *pass, *zp12;\n\tint pass_len, zp12_len;\n\tPKCS12 * p12 = NULL;\n\tEVP_PKEY * pkey = NULL;\n\tX509 * cert = NULL;\n\tSTACK_OF(X509) * ca = NULL;\n\tBIO * bio_in = NULL;\n\tint i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"szs\", &zp12, &zp12_len, &zout, &pass, &pass_len) == FAILURE)\n\t\treturn;\n\n\tRETVAL_FALSE;\n\t\n\tbio_in = BIO_new(BIO_s_mem());\n\t\n\tif(!BIO_write(bio_in, zp12, zp12_len))\n\t\tgoto cleanup;\n\t\n\tif(d2i_PKCS12_bio(bio_in, &p12)) {\n\t\tif(PKCS12_parse(p12, pass, &pkey, &cert, &ca)) {\n\t\t\tBIO * bio_out;\n\n\t\t\tzval_dtor(zout);\n\t\t\tarray_init(zout);\n\n\t\t\tbio_out = BIO_new(BIO_s_mem());\n\t\t\tif (PEM_write_bio_X509(bio_out, cert)) {\n\t\t\t\tBUF_MEM *bio_buf;\n\t\t\t\tBIO_get_mem_ptr(bio_out, &bio_buf);\n\t\t\t\tMAKE_STD_ZVAL(zcert);\n\t\t\t\tZVAL_STRINGL(zcert, bio_buf->data, bio_buf->length, 1);\n\t\t\t\tadd_assoc_zval(zout, \"cert\", zcert);\n\t\t\t}\n\t\t\tBIO_free(bio_out);\n\n\t\t\tbio_out = BIO_new(BIO_s_mem());\n\t\t\tif (PEM_write_bio_PrivateKey(bio_out, pkey, NULL, NULL, 0, 0, NULL)) {\n\t\t\t\tBUF_MEM *bio_buf;\n\t\t\t\tBIO_get_mem_ptr(bio_out, &bio_buf);\n\t\t\t\tMAKE_STD_ZVAL(zpkey);\n\t\t\t\tZVAL_STRINGL(zpkey, bio_buf->data, bio_buf->length, 1);\n\t\t\t\tadd_assoc_zval(zout, \"pkey\", zpkey);\n\t\t\t}\n\t\t\tBIO_free(bio_out);\n\n\t\t\tMAKE_STD_ZVAL(zextracerts);\n\t\t\tarray_init(zextracerts);\n\t\t\t\n\t\t\tfor (i=0;;i++) {\n\t\t\t\tzval * zextracert;\n\t\t\t\tX509* aCA = sk_X509_pop(ca);\n\t\t\t\tif (!aCA) break;\n\t\t\t\t\n\t\t\t\tbio_out = BIO_new(BIO_s_mem());\n\t\t\t\tif (PEM_write_bio_X509(bio_out, aCA)) {\n\t\t\t\t\tBUF_MEM *bio_buf;\n\t\t\t\t\tBIO_get_mem_ptr(bio_out, &bio_buf);\n\t\t\t\t\tMAKE_STD_ZVAL(zextracert);\n\t\t\t\t\tZVAL_STRINGL(zextracert, bio_buf->data, bio_buf->length, 1);\n\t\t\t\t\tadd_index_zval(zextracerts, i, zextracert);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tBIO_free(bio_out);\n\n\t\t\t\tX509_free(aCA);\n\t\t\t}\n\t\t\tif(ca) {\n\t\t\t\tsk_X509_free(ca);\n\t\t\t\tadd_assoc_zval(zout, \"extracerts\", zextracerts);\n\t\t\t} else {\n\t\t\t\tzval_dtor(zextracerts);\n\t\t\t}\n\t\t\t\n\t\t\tRETVAL_TRUE;\n\t\t\t\n\t\t\tPKCS12_free(p12);\n\t\t}\n\t}\n\t\n  cleanup:\n\tif (bio_in) {\n\t\tBIO_free(bio_in);\n\t}\n\tif (pkey) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tif (cert) { \n\t\tX509_free(cert);\n\t}\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_gray(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && cs->type == FZ_COLORSPACE_GRAY;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void FillRandom(uint8_t *data, int stride) {\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n        data[h * stride + w] = rnd_.Rand8();\n       }\n     }\n   }\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":" status_t OMXNodeInstance::sendCommand(\n         OMX_COMMANDTYPE cmd, OMX_S32 param) {\n    const sp<GraphicBufferSource>& bufferSource(getGraphicBufferSource());\n     if (bufferSource != NULL && cmd == OMX_CommandStateSet) {\n         if (param == OMX_StateIdle) {\n            bufferSource->omxIdle();\n } else if (param == OMX_StateLoaded) {\n            bufferSource->omxLoaded();\n            setGraphicBufferSource(NULL);\n }\n\n }\n\n Mutex::Autolock autoLock(mLock);\n\n {\n Mutex::Autolock _l(mDebugLock);\n        bumpDebugLevel_l(2 \/* numInputBuffers *\/, 2 \/* numOutputBuffers *\/);\n }\n\n const char *paramString =\n        cmd == OMX_CommandStateSet ? asString((OMX_STATETYPE)param) : portString(param);\n    CLOG_STATE(sendCommand, \"%s(%d), %s(%d)\", asString(cmd), cmd, paramString, param);\n    OMX_ERRORTYPE err = OMX_SendCommand(mHandle, cmd, param, NULL);\n    CLOG_IF_ERROR(sendCommand, err, \"%s(%d), %s(%d)\", asString(cmd), cmd, paramString, param);\n\n     return StatusFromOMXError(err);\n }\n","project":"Android","target":1},{"commit_id":"6c327afb263837bc90760c55c6605b26161a4eb9","func":" WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)\n {\n     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;\n    dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;\n     dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n     WORD32 j;\n     UWORD8 u1_buf_mode;\n struct MMCParams *ps_mmc_params;\n    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;\n\n    ps_slice->u1_mmco_equalto5 = 0;\n {\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_slice->u1_no_output_of_prior_pics_flag =\n                            ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: no_output_of_prior_pics_flag\",\n                            ps_slice->u1_no_output_of_prior_pics_flag);\n            ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(\n                            ps_bitstrm);\n            COPYTHECONTEXT(\"SH: long_term_reference_flag\",\n                            ps_slice->u1_long_term_reference_flag);\n            ps_dpb_cmds->u1_idr_pic = 1;\n            ps_dpb_cmds->u1_no_output_of_prior_pics_flag =\n                            ps_slice->u1_no_output_of_prior_pics_flag;\n            ps_dpb_cmds->u1_long_term_reference_flag =\n                            ps_slice->u1_long_term_reference_flag;\n }\n else\n {\n            u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm); \/\/0 - sliding window; 1 - arbitrary\n            COPYTHECONTEXT(\"SH: adaptive_ref_pic_buffering_flag\", u1_buf_mode);\n            ps_dpb_cmds->u1_buf_mode = u1_buf_mode;\n            j = 0;\n\n if(u1_buf_mode == 1)\n {\n                UWORD32 u4_mmco;\n                UWORD32 u4_diff_pic_num;\n                UWORD32 u4_lt_idx, u4_max_lt_idx;\n\n                u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n while(u4_mmco != END_OF_MMCO)\n {\n if (j >= MAX_REF_BUFS)\n {\n#ifdef __ANDROID__\n                        ALOGE(\"b\/25818142\");\n                        android_errorWriteLog(0x534e4554, \"25818142\");\n#endif\n                        ps_dpb_cmds->u1_num_of_commands = 0;\n return -1;\n }\n                    ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];\n                    ps_mmc_params->u4_mmco = u4_mmco;\n switch(u4_mmco)\n {\n case MARK_ST_PICNUM_AS_NONREF:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n break;\n\n case MARK_LT_INDEX_AS_NONREF:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n case MARK_ST_PICNUM_AS_LT_INDEX:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n case SET_MAX_LT_INDEX:\n {\n                            u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                       pu4_bitstrm_buf);\n                            ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;\n break;\n }\n case RESET_REF_PICTURES:\n {\n                            ps_slice->u1_mmco_equalto5 = 1;\n break;\n }\n\n case SET_LT_INDEX:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n default:\n break;\n }\n                    u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n                                         pu4_bitstrm_buf);\n\n                    j++;\n }\n                ps_dpb_cmds->u1_num_of_commands = j;\n\n }\n }\n        ps_dpb_cmds->u1_dpb_commands_read = 1;\n        ps_dpb_cmds->u1_dpb_commands_read_slc = 1;\n\n }\n    u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;\n return u4_bit_ofst;\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"attr_show_all_iterator (struct hash_backet *backet, struct vty *vty)\n{\n  struct attr *attr = backet->data;\n\n  vty_out (vty, \"attr[%ld] nexthop %s%s\", attr->refcnt, \n\t   inet_ntoa (attr->nexthop), VTY_NEWLINE);\n}\n","project":"savannah","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex >= mPorts.size()) {\n                 return OMX_ErrorBadPortIndex;\n             }\n if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {\n return OMX_ErrorUnsupportedSetting;\n }\n\n PortInfo *port =\n &mPorts.editItemAt(defParams->nPortIndex);\n\n if (defParams->nBufferSize > port->mDef.nBufferSize) {\n                port->mDef.nBufferSize = defParams->nBufferSize;\n }\n\n if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {\n                ALOGW(\"component requires at least %u buffers (%u requested)\",\n                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);\n return OMX_ErrorUnsupportedSetting;\n }\n\n            port->mDef.nBufferCountActual = defParams->nBufferCountActual;\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_flush (struct attr *attr)\n{\n  if (attr->aspath && ! attr->aspath->refcnt)\n    aspath_free (attr->aspath);\n  if (attr->community && ! attr->community->refcnt)\n    community_free (attr->community);\n  if (attr->extra)\n    {\n      struct attr_extra *attre = attr->extra;\n\n      if (attre->ecommunity && ! attre->ecommunity->refcnt)\n        ecommunity_free (&attre->ecommunity);\n      if (attre->cluster && ! attre->cluster->refcnt)\n        cluster_free (attre->cluster);\n      if (attre->transit && ! attre->transit->refcnt)\n        transit_free (attre->transit);\n    }\n}\n","project":"savannah","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_extra_new (void)\n{\n  return XCALLOC (MTYPE_ATTR_EXTRA, sizeof (struct attr_extra));\n}\n","project":"savannah","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_S(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_path(ctx, pr, 0, 0, 1, 0);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Block::Lacing Block::GetLacing() const\n{\n    const int value = int(m_flags & 0x06) >> 1;\n    return static_cast<Lacing>(value);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_rgb_to_bgr(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tint sn = src->n;\n\tint ss = src->s;\n\tint sa = src->alpha;\n\tint dn = dst->n;\n\tint ds = dst->s;\n\tint da = dst->alpha;\n\tptrdiff_t d_line_inc = dst->stride - w * dn;\n\tptrdiff_t s_line_inc = src->stride - w * sn;\n\n\t\/* If copying spots, they must match, and we can never drop alpha (but we can invent it) *\/\n\tif ((copy_spots && ss != ds) || (!da && sa))\n\t{\n\t\tassert(\"This should never happen\" == NULL);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Cannot convert between incompatible pixmaps\");\n\t}\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\tif (ss == 0 && ds == 0)\n\t{\n\t\t\/* Common, no spots case *\/\n\t\tif (da)\n\t\t{\n\t\t\tif (sa)\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = s[2];\n\t\t\t\t\t\td[1] = s[1];\n\t\t\t\t\t\td[2] = s[0];\n\t\t\t\t\t\td[3] = s[3];\n\t\t\t\t\t\ts += 4;\n\t\t\t\t\t\td += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\td[0] = s[2];\n\t\t\t\t\t\td[1] = s[1];\n\t\t\t\t\t\td[2] = s[0];\n\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\ts += 3;\n\t\t\t\t\t\td += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\td[0] = s[2];\n\t\t\t\t\td[1] = s[1];\n\t\t\t\t\td[2] = s[0];\n\t\t\t\t\ts += 3;\n\t\t\t\t\td += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (copy_spots)\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\twhile (h--)\n\t\t{\n\t\t\tint i;\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = s[2];\n\t\t\t\td[1] = s[1];\n\t\t\t\td[2] = s[0];\n\t\t\t\ts += 3;\n\t\t\t\td += 3;\n\t\t\t\tfor (i=ss; i > 0; i--)\n\t\t\t\t\t*d++ = *s++;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = sa ? *s++ : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\td[0] = s[2];\n\t\t\t\td[1] = s[1];\n\t\t\t\td[2] = s[0];\n\t\t\t\ts += sn;\n\t\t\t\td += dn;\n\t\t\t\tif (da)\n\t\t\t\t\td[-1] = sa ? s[-1] : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const\n{\n    assert(pReader);\n    assert(buf);\n    const long status = pReader->Read(pos, len, buf);\n    return status;\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"char *phar_find_in_include_path(char *filename, int filename_len, phar_archive_data **pphar TSRMLS_DC) \/* {{{ *\/\n{\n\tchar *path, *fname, *arch, *entry, *ret, *test;\n\tint arch_len, entry_len, fname_len, ret_len;\n\tphar_archive_data *phar;\n\n\tif (pphar) {\n\t\t*pphar = NULL;\n\t} else {\n\t\tpphar = &phar;\n\t}\n\n\tif (!zend_is_executing(TSRMLS_C) || !PHAR_G(cwd)) {\n\t\treturn phar_save_resolve_path(filename, filename_len TSRMLS_CC);\n\t}\n\n\tfname = (char*)zend_get_executed_filename(TSRMLS_C);\n\tfname_len = strlen(fname);\n\n\tif (PHAR_G(last_phar) && !memcmp(fname, \"phar:\/\/\", 7) && fname_len - 7 >= PHAR_G(last_phar_name_len) && !memcmp(fname + 7, PHAR_G(last_phar_name), PHAR_G(last_phar_name_len))) {\n\t\tarch = estrndup(PHAR_G(last_phar_name), PHAR_G(last_phar_name_len));\n\t\tarch_len = PHAR_G(last_phar_name_len);\n\t\tphar = PHAR_G(last_phar);\n\t\tgoto splitted;\n\t}\n\n\tif (fname_len < 7 || memcmp(fname, \"phar:\/\/\", 7) || SUCCESS != phar_split_fname(fname, strlen(fname), &arch, &arch_len, &entry, &entry_len, 1, 0 TSRMLS_CC)) {\n\t\treturn phar_save_resolve_path(filename, filename_len TSRMLS_CC);\n\t}\n\n\tefree(entry);\n\n\tif (*filename == '.') {\n\t\tint try_len;\n\n\t\tif (FAILURE == phar_get_archive(&phar, arch, arch_len, NULL, 0, NULL TSRMLS_CC)) {\n\t\t\tefree(arch);\n\t\t\treturn phar_save_resolve_path(filename, filename_len TSRMLS_CC);\n\t\t}\nsplitted:\n\t\tif (pphar) {\n\t\t\t*pphar = phar;\n\t\t}\n\n\t\ttry_len = filename_len;\n\t\ttest = phar_fix_filepath(estrndup(filename, filename_len), &try_len, 1 TSRMLS_CC);\n\n\t\tif (*test == '\/') {\n\t\t\tif (zend_hash_exists(&(phar->manifest), test + 1, try_len - 1)) {\n\t\t\t\tspprintf(&ret, 0, \"phar:\/\/%s%s\", arch, test);\n\t\t\t\tefree(arch);\n\t\t\t\tefree(test);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (zend_hash_exists(&(phar->manifest), test, try_len)) {\n\t\t\t\tspprintf(&ret, 0, \"phar:\/\/%s\/%s\", arch, test);\n\t\t\t\tefree(arch);\n\t\t\t\tefree(test);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tefree(test);\n\t}\n\n\tspprintf(&path, MAXPATHLEN, \"phar:\/\/%s\/%s%c%s\", arch, PHAR_G(cwd), DEFAULT_DIR_SEPARATOR, PG(include_path));\n\tefree(arch);\n\tret = php_resolve_path(filename, filename_len, path TSRMLS_CC);\n\tefree(path);\n\n\tif (ret && strlen(ret) > 8 && !strncmp(ret, \"phar:\/\/\", 7)) {\n\t\tret_len = strlen(ret);\n\t\t\/* found phar:\/\/ *\/\n\n\t\tif (SUCCESS != phar_split_fname(ret, ret_len, &arch, &arch_len, &entry, &entry_len, 1, 0 TSRMLS_CC)) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tzend_hash_find(&(PHAR_GLOBALS->phar_fname_map), arch, arch_len, (void **) &pphar);\n\n\t\tif (!pphar && PHAR_G(manifest_cached)) {\n\t\t\tzend_hash_find(&cached_phars, arch, arch_len, (void **) &pphar);\n\t\t}\n\n\t\tefree(arch);\n\t\tefree(entry);\n\t}\n\n\treturn ret;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n        data[h * stride + w] = fill_constant;\n       }\n     }\n   }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"php_stream *phar_wrapper_open_dir(php_stream_wrapper *wrapper, char *path, char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC) \/* {{{ *\/\n{\n\tphp_url *resource = NULL;\n\tphp_stream *ret;\n\tchar *internal_file, *error, *str_key;\n\tphar_zstr key;\n\tuint keylen;\n\tulong unused;\n\tphar_archive_data *phar;\n\tphar_entry_info *entry = NULL;\n\tuint host_len;\n\n\tif ((resource = phar_parse_url(wrapper, path, mode, options TSRMLS_CC)) == NULL) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar url \\\"%s\\\" is unknown\", path);\n\t\treturn NULL;\n\t}\n\n\t\/* we must have at the very least phar:\/\/alias.phar\/ *\/\n\tif (!resource->scheme || !resource->host || !resource->path) {\n\t\tif (resource->host && !resource->path) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: no directory in \\\"%s\\\", must have at least phar:\/\/%s\/ for root directory (always use full path to a new phar)\", path, resource->host);\n\t\t\tphp_url_free(resource);\n\t\t\treturn NULL;\n\t\t}\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: invalid url \\\"%s\\\", must have at least phar:\/\/%s\/\", path, path);\n\t\treturn NULL;\n\t}\n\n\tif (strcasecmp(\"phar\", resource->scheme)) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: not a phar url \\\"%s\\\"\", path);\n\t\treturn NULL;\n\t}\n\n\thost_len = strlen(resource->host);\n\tphar_request_initialize(TSRMLS_C);\n\tinternal_file = resource->path + 1; \/* strip leading \"\/\" *\/\n\n\tif (FAILURE == phar_get_archive(&phar, resource->host, host_len, NULL, 0, &error TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar file \\\"%s\\\" is unknown\", resource->host);\n\t\t}\n\t\tphp_url_free(resource);\n\t\treturn NULL;\n\t}\n\n\tif (error) {\n\t\tefree(error);\n\t}\n\n\tif (*internal_file == '\\0') {\n\t\t\/* root directory requested *\/\n\t\tinternal_file = estrndup(internal_file - 1, 1);\n\t\tret = phar_make_dirstream(internal_file, &phar->manifest TSRMLS_CC);\n\t\tphp_url_free(resource);\n\t\treturn ret;\n\t}\n\n\tif (!phar->manifest.arBuckets) {\n\t\tphp_url_free(resource);\n\t\treturn NULL;\n\t}\n\n\tif (SUCCESS == zend_hash_find(&phar->manifest, internal_file, strlen(internal_file), (void**)&entry) && !entry->is_dir) {\n\t\tphp_url_free(resource);\n\t\treturn NULL;\n\t} else if (entry && entry->is_dir) {\n\t\tif (entry->is_mounted) {\n\t\t\tphp_url_free(resource);\n\t\t\treturn php_stream_opendir(entry->tmp, options, context);\n\t\t}\n\t\tinternal_file = estrdup(internal_file);\n\t\tphp_url_free(resource);\n\t\treturn phar_make_dirstream(internal_file, &phar->manifest TSRMLS_CC);\n\t} else {\n\t\tint i_len = strlen(internal_file);\n\n\t\t\/* search for directory *\/\n\t\tzend_hash_internal_pointer_reset(&phar->manifest);\n\t\twhile (FAILURE != zend_hash_has_more_elements(&phar->manifest)) {\n\t\t\tif (HASH_KEY_NON_EXISTENT != \n\t\t\t\t\tzend_hash_get_current_key_ex(\n\t\t\t\t\t\t&phar->manifest, &key, &keylen, &unused, 0, NULL)) {\n\t\t\t\tPHAR_STR(key, str_key);\n\t\t\t\tif (keylen > (uint)i_len && 0 == memcmp(str_key, internal_file, i_len)) {\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\t\/* directory found *\/\n\t\t\t\t\tinternal_file = estrndup(internal_file,\n\t\t\t\t\t\t\ti_len);\n\t\t\t\t\tphp_url_free(resource);\n\t\t\t\t\treturn phar_make_dirstream(internal_file, &phar->manifest TSRMLS_CC);\n\t\t\t\t}\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t}\n\n\t\t\tif (SUCCESS != zend_hash_move_forward(&phar->manifest)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tphp_url_free(resource);\n\treturn NULL;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) \/* {{{ *\/\n{\n\t\/* parameters *\/\n\tchar\t\t\t *regex;\t\t\t\/* Regular expression *\/\n\tchar\t\t\t *subject;\t\t\t\/* String to match against *\/\n\tint\t\t\t\t  regex_len;\n\tint\t\t\t\t  subject_len;\n\tpcre_cache_entry *pce;\t\t\t\t\/* Compiled regular expression *\/\n\tzval\t\t\t *subpats = NULL;\t\/* Array for subpatterns *\/\n\tlong\t\t\t  flags = 0;\t\t\/* Match control flags *\/\n\tlong\t\t\t  start_offset = 0;\t\/* Where the new search starts *\/\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|zll\", &regex, &regex_len,\n\t\t\t\t\t\t\t  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\t\/* Compile regex or get it from cache. *\/\n\tif ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_pcre_match_impl(pce, subject, subject_len, return_value, subpats, \n\t\tglobal, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAAC2::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch ((int)index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.aac\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             const OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (const OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (aacParams->eAACStreamFormat == OMX_AUDIO_AACStreamFormatMP4FF) {\n                mIsADTS = false;\n } else if (aacParams->eAACStreamFormat\n == OMX_AUDIO_AACStreamFormatMP4ADTS) {\n                mIsADTS = true;\n } else {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAndroidAacPresentation:\n\n         {\n             const OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE *aacPresParams =\n                     (const OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE *)params;\n if (aacPresParams->nMaxOutputChannels >= 0) {\n int max;\n if (aacPresParams->nMaxOutputChannels >= 8) { max = 8; }\n else if (aacPresParams->nMaxOutputChannels >= 6) { max = 6; }\n else if (aacPresParams->nMaxOutputChannels >= 2) { max = 2; }\n else {\n                    max = aacPresParams->nMaxOutputChannels;\n }\n                ALOGV(\"set nMaxOutputChannels=%d\", max);\n                aacDecoder_SetParam(mAACDecoder, AAC_PCM_MAX_OUTPUT_CHANNELS, max);\n }\n bool updateDrcWrapper = false;\n if (aacPresParams->nDrcBoost >= 0) {\n                ALOGV(\"set nDrcBoost=%d\", aacPresParams->nDrcBoost);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_DESIRED_BOOST_FACTOR,\n                        aacPresParams->nDrcBoost);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nDrcCut >= 0) {\n                ALOGV(\"set nDrcCut=%d\", aacPresParams->nDrcCut);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_DESIRED_ATT_FACTOR, aacPresParams->nDrcCut);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nHeavyCompression >= 0) {\n                ALOGV(\"set nHeavyCompression=%d\", aacPresParams->nHeavyCompression);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_DESIRED_HEAVY,\n                        aacPresParams->nHeavyCompression);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nTargetReferenceLevel >= 0) {\n                ALOGV(\"set nTargetReferenceLevel=%d\", aacPresParams->nTargetReferenceLevel);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_DESIRED_TARGET,\n                        aacPresParams->nTargetReferenceLevel);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nEncodedTargetLevel >= 0) {\n                ALOGV(\"set nEncodedTargetLevel=%d\", aacPresParams->nEncodedTargetLevel);\n                mDrcWrap.setParam(DRC_PRES_MODE_WRAP_ENCODER_TARGET,\n                        aacPresParams->nEncodedTargetLevel);\n                updateDrcWrapper = true;\n }\n if (aacPresParams->nPCMLimiterEnable >= 0) {\n                aacDecoder_SetParam(mAACDecoder, AAC_PCM_LIMITER_ENABLE,\n (aacPresParams->nPCMLimiterEnable != 0));\n }\n if (updateDrcWrapper) {\n                mDrcWrap.update();\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftVorbis::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.vorbis\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioVorbis:\n {\n\n             const OMX_AUDIO_PARAM_VORBISTYPE *vorbisParams =\n                 (const OMX_AUDIO_PARAM_VORBISTYPE *)params;\n \n             if (vorbisParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long SegmentInfo::Parse()\n{\n    assert(m_pMuxingAppAsUTF8 == NULL);\n    assert(m_pWritingAppAsUTF8 == NULL);\n    assert(m_pTitleAsUTF8 == NULL);\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long pos = m_start;\n    const long long stop = m_start + m_size;\n    m_timecodeScale = 1000000;\n    m_duration = -1;\n    while (pos < stop)\n    {\n        long long id, size;\n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n        if (status < 0)  \/\/error\n            return status;\n        if (id == 0x0AD7B1)  \/\/Timecode Scale\n        {\n            m_timecodeScale = UnserializeUInt(pReader, pos, size);\n            if (m_timecodeScale <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x0489)  \/\/Segment duration\n        {\n            const long status = UnserializeFloat(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    m_duration);\n            if (status < 0)\n                return status;\n            if (m_duration < 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x0D80)  \/\/MuxingApp\n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    m_pMuxingAppAsUTF8);\n            if (status)\n                return status;\n        }\n        else if (id == 0x1741)  \/\/WritingApp\n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    m_pWritingAppAsUTF8);\n            if (status)\n                return status;\n        }\n        else if (id == 0x3BA9)  \/\/Title\n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    m_pTitleAsUTF8);\n            if (status)\n                return status;\n        }\n        pos += size;\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    return 0;\n}\n","project":"Android","target":1},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)\n\t{\n\tint ret=0;\n\n#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_RSA)\n\tif (\n#ifndef OPENSSL_NO_RSA\n\t    cmd == SSL_CTRL_SET_TMP_RSA ||\n\t    cmd == SSL_CTRL_SET_TMP_RSA_CB ||\n#endif\n#ifndef OPENSSL_NO_DSA\n\t    cmd == SSL_CTRL_SET_TMP_DH ||\n\t    cmd == SSL_CTRL_SET_TMP_DH_CB ||\n#endif\n\t\t0)\n\t\t{\n\t\tif (!ssl_cert_inst(&s->cert))\n\t\t    \t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_MALLOC_FAILURE);\n\t\t\treturn(0);\n\t\t\t}\n\t\t}\n#endif\n\n\tswitch (cmd)\n\t\t{\n\tcase SSL_CTRL_GET_SESSION_REUSED:\n\t\tret=s->hit;\n\t\tbreak;\n\tcase SSL_CTRL_GET_CLIENT_CERT_REQUEST:\n\t\tbreak;\n\tcase SSL_CTRL_GET_NUM_RENEGOTIATIONS:\n\t\tret=s->s3->num_renegotiations;\n\t\tbreak;\n\tcase SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS:\n\t\tret=s->s3->num_renegotiations;\n\t\ts->s3->num_renegotiations=0;\n\t\tbreak;\n\tcase SSL_CTRL_GET_TOTAL_RENEGOTIATIONS:\n\t\tret=s->s3->total_renegotiations;\n\t\tbreak;\n\tcase SSL_CTRL_GET_FLAGS:\n\t\tret=(int)(s->s3->flags);\n\t\tbreak;\n#ifndef OPENSSL_NO_RSA\n\tcase SSL_CTRL_NEED_TMP_RSA:\n\t\tif ((s->cert != NULL) && (s->cert->rsa_tmp == NULL) &&\n\t\t    ((s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\n\t\t     (EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) > (512\/8))))\n\t\t\tret = 1;\n\t\tbreak;\n\tcase SSL_CTRL_SET_TMP_RSA:\n\t\t{\n\t\t\tRSA *rsa = (RSA *)parg;\n\t\t\tif (rsa == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\tif ((rsa = RSAPrivateKey_dup(rsa)) == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_RSA_LIB);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\tif (s->cert->rsa_tmp != NULL)\n\t\t\t\tRSA_free(s->cert->rsa_tmp);\n\t\t\ts->cert->rsa_tmp = rsa;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tcase SSL_CTRL_SET_TMP_RSA_CB:\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\treturn(ret);\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DH\n\tcase SSL_CTRL_SET_TMP_DH:\n\t\t{\n\t\t\tDH *dh = (DH *)parg;\n\t\t\tif (dh == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\tif ((dh = DHparams_dup(dh)) == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\tif (!(s->options & SSL_OP_SINGLE_DH_USE))\n\t\t\t\t{\n\t\t\t\tif (!DH_generate_key(dh))\n\t\t\t\t\t{\n\t\t\t\t\tDH_free(dh);\n\t\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\n\t\t\t\t\treturn(ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (s->cert->dh_tmp != NULL)\n\t\t\t\tDH_free(s->cert->dh_tmp);\n\t\t\ts->cert->dh_tmp = dh;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tcase SSL_CTRL_SET_TMP_DH_CB:\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\treturn(ret);\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tcase SSL_CTRL_SET_TMP_ECDH:\n\t\t{\n\t\tEC_KEY *ecdh = NULL;\n \t\t\t\n\t\tif (parg == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n\t\t\treturn(ret);\n\t\t\t}\n\t\tif (!EC_KEY_up_ref((EC_KEY *)parg))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL,ERR_R_ECDH_LIB);\n\t\t\treturn(ret);\n\t\t\t}\n\t\tecdh = (EC_KEY *)parg;\n\t\tif (!(s->options & SSL_OP_SINGLE_ECDH_USE))\n\t\t\t{\n\t\t\tif (!EC_KEY_generate_key(ecdh))\n\t\t\t\t{\n\t\t\t\tEC_KEY_free(ecdh);\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL,ERR_R_ECDH_LIB);\n\t\t\t\treturn(ret);\n\t\t\t\t}\n\t\t\t}\n\t\tif (s->cert->ecdh_tmp != NULL)\n\t\t\tEC_KEY_free(s->cert->ecdh_tmp);\n\t\ts->cert->ecdh_tmp = ecdh;\n\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tcase SSL_CTRL_SET_TMP_ECDH_CB:\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\treturn(ret);\n\t\t}\n\t\tbreak;\n#endif \/* !OPENSSL_NO_ECDH *\/\n#ifndef OPENSSL_NO_TLSEXT\n\tcase SSL_CTRL_SET_TLSEXT_HOSTNAME:\n \t\tif (larg == TLSEXT_NAMETYPE_host_name)\n\t\t\t{\n\t\t\tif (s->tlsext_hostname != NULL) \n\t\t\t\tOPENSSL_free(s->tlsext_hostname);\n\t\t\ts->tlsext_hostname = NULL;\n\n\t\t\tret = 1;\n\t\t\tif (parg == NULL) \n\t\t\t\tbreak;\n\t\t\tif (strlen((char *)parg) > TLSEXT_MAXLEN_host_name)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME);\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif ((s->tlsext_hostname = BUF_strdup((char *)parg)) == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTRL, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE);\n\t\t\treturn 0;\n\t\t\t}\n \t\tbreak;\n\tcase SSL_CTRL_SET_TLSEXT_DEBUG_ARG:\n\t\ts->tlsext_debug_arg=parg;\n\t\tret = 1;\n\t\tbreak;\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tcase SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT:\n\t\tif (larg > 12288) \/* actual internal limit is 2^16 for the complete hello message\n\t\t                   * (including the cert chain and everything) *\/\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTRL, SSL_R_OPAQUE_PRF_INPUT_TOO_LONG);\n\t\t\tbreak;\n\t\t\t}\n\t\tif (s->tlsext_opaque_prf_input != NULL)\n\t\t\tOPENSSL_free(s->tlsext_opaque_prf_input);\n\t\tif ((size_t)larg == 0)\n\t\t\ts->tlsext_opaque_prf_input = OPENSSL_malloc(1); \/* dummy byte just to get non-NULL *\/\n\t\telse\n\t\t\ts->tlsext_opaque_prf_input = BUF_memdup(parg, (size_t)larg);\n\t\tif (s->tlsext_opaque_prf_input != NULL)\n\t\t\t{\n\t\t\ts->tlsext_opaque_prf_input_len = (size_t)larg;\n\t\t\tret = 1;\n\t\t\t}\n\t\telse\n\t\t\ts->tlsext_opaque_prf_input_len = 0;\n\t\tbreak;\n#endif\n\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE:\n\t\ts->tlsext_status_type=larg;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS:\n\t\t*(STACK_OF(X509_EXTENSION) **)parg = s->tlsext_ocsp_exts;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS:\n\t\ts->tlsext_ocsp_exts = parg;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS:\n\t\t*(STACK_OF(OCSP_RESPID) **)parg = s->tlsext_ocsp_ids;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS:\n\t\ts->tlsext_ocsp_ids = parg;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP:\n\t\t*(unsigned char **)parg = s->tlsext_ocsp_resp;\n\t\treturn s->tlsext_ocsp_resplen;\n\t\t\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP:\n\t\tif (s->tlsext_ocsp_resp)\n\t\t\tOPENSSL_free(s->tlsext_ocsp_resp);\n\t\ts->tlsext_ocsp_resp = parg;\n\t\ts->tlsext_ocsp_resplen = larg;\n\t\tret = 1;\n\t\tbreak;\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\tcase SSL_CTRL_TLS_EXT_SEND_HEARTBEAT:\n\t\tif (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)\n\t\t\tret = dtls1_heartbeat(s);\n\t\telse\n\t\t\tret = tls1_heartbeat(s);\n\t\tbreak;\n\n\tcase SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING:\n\t\tret = s->tlsext_hb_pending;\n\t\tbreak;\n\n\tcase SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS:\n\t\tif (larg)\n\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\n\t\telse\n\t\t\ts->tlsext_heartbeat &= ~SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\n\t\tret = 1;\n\t\tbreak;\n#endif\n\n#endif \/* !OPENSSL_NO_TLSEXT *\/\n\tdefault:\n\t\tbreak;\n\t\t}\n\treturn(ret);\n\t}\n","project":"openssl","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"EBMLHeader::EBMLHeader() :\n    m_docType(NULL)\n{\n    Init();\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"transit_hash_alloc (void *p)\n{\n  \/* Transit structure is already allocated.  *\/\n  return p;\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"int SeekHead::GetVoidElementCount() const\n{\n    return m_void_element_count;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::CreateSimpleBlock(\n    long long st,\n    long long sz)\n{\n    assert(m_entries);\n    assert(m_entries_size > 0);\n    assert(m_entries_count >= 0);\n    assert(m_entries_count < m_entries_size);\n    const long idx = m_entries_count;\n    BlockEntry** const ppEntry = m_entries + idx;\n    BlockEntry*& pEntry = *ppEntry;\n    pEntry = new (std::nothrow) SimpleBlock(this, idx, st, sz);\n    if (pEntry == NULL)\n        return -1;  \/\/generic error\n    SimpleBlock* const p = static_cast<SimpleBlock*>(pEntry);\n    const long status = p->Parse();\n    if (status == 0)\n    {\n        ++m_entries_count;\n        return 0;\n    }\n    delete pEntry;\n    pEntry = 0;\n    return status;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void reference_32x32_dct_2d(const int16_t input[kNumCoeffs],\n double output[kNumCoeffs]) {\n for (int i = 0; i < 32; ++i) {\n\n     double temp_in[32], temp_out[32];\n     for (int j = 0; j < 32; ++j)\n       temp_in[j] = input[j*32 + i];\n    reference_32x32_dct_1d(temp_in, temp_out, 1);\n     for (int j = 0; j < 32; ++j)\n       output[j * 32 + i] = temp_out[j];\n   }\n for (int i = 0; i < 32; ++i) {\n\n     double temp_in[32], temp_out[32];\n     for (int j = 0; j < 32; ++j)\n       temp_in[j] = output[j + i*32];\n    reference_32x32_dct_1d(temp_in, temp_out, 1);\n     for (int j = 0; j < 32; ++j)\n       output[j + i * 32] = temp_out[j] \/ 4;\n   }\n }\n","project":"Android","target":1},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_num_ciphers(void)\n\t{\n\treturn(SSL3_NUM_CIPHERS);\n\t}\n","project":"openssl","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static bool samldb_msg_add_sid(struct ldb_message *msg,\n\t\t\t\tconst char *name,\n\t\t\t\tconst struct dom_sid *sid)\n{\n\tstruct ldb_val v;\n\tenum ndr_err_code ndr_err;\n\n\tndr_err = ndr_push_struct_blob(&v, msg, sid,\n\t\t\t\t       (ndr_push_flags_fn_t)ndr_push_dom_sid);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\treturn false;\n\t}\n\treturn (ldb_msg_add_value(msg, name, &v, NULL) == 0);\n}\n","project":"samba","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftVorbis::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioVorbis:\n {\n\n             OMX_AUDIO_PARAM_VORBISTYPE *vorbisParams =\n                 (OMX_AUDIO_PARAM_VORBISTYPE *)params;\n \n             if (vorbisParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            vorbisParams->nBitRate = 0;\n            vorbisParams->nMinBitRate = 0;\n            vorbisParams->nMaxBitRate = 0;\n            vorbisParams->nAudioBandWidth = 0;\n            vorbisParams->nQuality = 3;\n            vorbisParams->bManaged = OMX_FALSE;\n            vorbisParams->bDownmix = OMX_FALSE;\n\n if (!isConfigured()) {\n                vorbisParams->nChannels = 1;\n                vorbisParams->nSampleRate = 44100;\n } else {\n                vorbisParams->nChannels = mVi->channels;\n                vorbisParams->nSampleRate = mVi->rate;\n                vorbisParams->nBitRate = mVi->bitrate_nominal;\n                vorbisParams->nMinBitRate = mVi->bitrate_lower;\n                vorbisParams->nMaxBitRate = mVi->bitrate_upper;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n if (!isConfigured()) {\n                pcmParams->nChannels = 1;\n                pcmParams->nSamplingRate = 44100;\n } else {\n                pcmParams->nChannels = mVi->channels;\n                pcmParams->nSamplingRate = mVi->rate;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAVCEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n int32_t indexFull = index;\n\n switch (indexFull) {\n case OMX_IndexParamVideoBitrate:\n {\n\n             OMX_VIDEO_PARAM_BITRATETYPE *bitRate =\n                 (OMX_VIDEO_PARAM_BITRATETYPE *) params;\n \n             if (bitRate->nPortIndex != 1 ||\n                 bitRate->eControlRate != OMX_Video_ControlRateVariable) {\n                 return OMX_ErrorUndefined;\n }\n\n            mBitrate = bitRate->nTargetBitrate;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoAvc:\n {\n\n             OMX_VIDEO_PARAM_AVCTYPE *avcType =\n                 (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n             if (avcType->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (avcType->eProfile != OMX_VIDEO_AVCProfileBaseline ||\n                avcType->nRefFrames != 1 ||\n                avcType->nBFrames != 0 ||\n                avcType->bUseHadamard != OMX_TRUE ||\n (avcType->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) != 0 ||\n                avcType->nRefIdx10ActiveMinus1 != 0 ||\n                avcType->nRefIdx11ActiveMinus1 != 0 ||\n                avcType->bWeightedPPrediction != OMX_FALSE ||\n                avcType->bEntropyCodingCABAC != OMX_FALSE ||\n                avcType->bconstIpred != OMX_FALSE ||\n                avcType->bDirect8x8Inference != OMX_FALSE ||\n                avcType->bDirectSpatialTemporal != OMX_FALSE ||\n                avcType->nCabacInitIdc != 0) {\n return OMX_ErrorUndefined;\n }\n\n if (OK != ConvertOmxAvcLevelToAvcSpecLevel(avcType->eLevel, &mAVCEncLevel)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_free (struct cluster_list *cluster)\n{\n  if (cluster->list)\n    XFREE (MTYPE_CLUSTER_VAL, cluster->list);\n  XFREE (MTYPE_CLUSTER, cluster);\n}\n","project":"savannah","target":0},{"commit_id":"2c75e1c3b98e4e94f50c63e2b7694be5f948477c","func":"status_t OMXNodeInstance::updateNativeHandleInMeta(\n        OMX_U32 portIndex, const sp<NativeHandle>& nativeHandle, OMX::buffer_id buffer) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n if (header == NULL) {\n        ALOGE(\"b\/25884056\");\n return BAD_VALUE;\n }\n\n if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n return BAD_VALUE;\n\n     }\n \n     BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);\n     sp<ABuffer> data = bufferMeta->getBuffer(\n             header, false \/* backup *\/, false \/* limit *\/);\n     bufferMeta->setNativeHandle(nativeHandle);\n if (mMetadataType[portIndex] == kMetadataBufferTypeNativeHandleSource\n && data->capacity() >= sizeof(VideoNativeHandleMetadata)) {\n VideoNativeHandleMetadata &metadata = *(VideoNativeHandleMetadata *)(data->data());\n        metadata.eType = mMetadataType[portIndex];\n        metadata.pHandle =\n            nativeHandle == NULL ? NULL : const_cast<native_handle*>(nativeHandle->handle());\n } else {\n        CLOG_ERROR(updateNativeHandleInMeta, BAD_VALUE, \"%s:%u, %#x bad type (%d) or size (%zu)\",\n            portString(portIndex), portIndex, buffer, mMetadataType[portIndex], data->capacity());\n return BAD_VALUE;\n }\n\n    CLOG_BUFFER(updateNativeHandleInMeta, \"%s:%u, %#x := %p\",\n            portString(portIndex), portIndex, buffer,\n            nativeHandle == NULL ? NULL : nativeHandle->handle());\n return OK;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::GetEntry(long index, const mkvparser::BlockEntry*& pEntry) const\n{\n    assert(m_pos >= m_element_start);\n    pEntry = NULL;\n    if (index < 0)\n        return -1;  \/\/generic error\n    if (m_entries_count < 0)\n        return E_BUFFER_NOT_FULL;\n    assert(m_entries);\n    assert(m_entries_size > 0);\n    assert(m_entries_count <= m_entries_size);\n    if (index < m_entries_count)\n    {\n        pEntry = m_entries[index];\n        assert(pEntry);\n        return 1;  \/\/found entry\n     }\n \n    if (m_element_size < 0)        \/\/we don't know cluster end yet\n        return E_BUFFER_NOT_FULL;  \/\/underflow\n \n    const long long element_stop = m_element_start + m_element_size;\n \n    if (m_pos >= element_stop)\n        return 0;  \/\/nothing left to parse\n    return E_BUFFER_NOT_FULL;  \/\/underflow, since more remains to be parsed\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Block::GetTimeCode(const Cluster* pCluster) const\n{\n    if (pCluster == 0)\n        return m_timecode;\n \n    const long long tc0 = pCluster->GetTimeCode();\n    assert(tc0 >= 0);\n \n    const long long tc = tc0 + m_timecode;\n    return tc;  \/\/unscaled timecode units\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":" ContentEncoding::ContentCompression::~ContentCompression() {\n  delete [] settings;\n }\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAVC::internalSetParameter(OMX_INDEXTYPE index, const OMX_PTR params) {\n int32_t indexFull = index;\n\n\n     switch (indexFull) {\n         case OMX_IndexParamVideoBitrate:\n         {\n            return internalSetBitrateParams(\n                    (const OMX_VIDEO_PARAM_BITRATETYPE *)params);\n         }\n \n         case OMX_IndexParamVideoAvc:\n         {\n             OMX_VIDEO_PARAM_AVCTYPE *avcType = (OMX_VIDEO_PARAM_AVCTYPE *)params;\n \n             if (avcType->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mEntropyMode = 0;\n\n if (OMX_TRUE == avcType->bEntropyCodingCABAC)\n                mEntropyMode = 1;\n\n if ((avcType->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) &&\n                    avcType->nPFrames) {\n                mBframes = avcType->nBFrames \/ avcType->nPFrames;\n }\n\n            mIInterval = avcType->nPFrames + avcType->nBFrames;\n\n if (OMX_VIDEO_AVCLoopFilterDisable == avcType->eLoopFilterMode)\n                mDisableDeblkLevel = 4;\n\n if (avcType->nRefFrames != 1\n || avcType->bUseHadamard != OMX_TRUE\n || avcType->nRefIdx10ActiveMinus1 != 0\n || avcType->nRefIdx11ActiveMinus1 != 0\n || avcType->bWeightedPPrediction != OMX_FALSE\n || avcType->bconstIpred != OMX_FALSE\n || avcType->bDirect8x8Inference != OMX_FALSE\n || avcType->bDirectSpatialTemporal != OMX_FALSE\n || avcType->nCabacInitIdc != 0) {\n return OMX_ErrorUndefined;\n }\n\n if (OK != ConvertOmxAvcLevelToAvcSpecLevel(avcType->eLevel, &mAVCEncLevel)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_check_sAMAccountName(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char *name;\n\tint ret;\n\tstruct ldb_result *res;\n\tconst char * const noattrs[] = { NULL };\n\n\tif (ldb_msg_find_element(ac->msg, \"sAMAccountName\") == NULL) {\n\t\tret = samldb_generate_sAMAccountName(ldb, ac->msg);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tname = ldb_msg_find_attr_as_string(ac->msg, \"sAMAccountName\", NULL);\n\tif (name == NULL) {\n\t\t\/* The \"sAMAccountName\" cannot be nothing *\/\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: Empty account names aren't allowed!\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ldb_get_default_basedn(ldb), LDB_SCOPE_SUBTREE, noattrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(sAMAccountName=%s)\",\n\t\t\t\t ldb_binary_encode_string(ac, name));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb: Account name (sAMAccountName) '%s' already in use!\",\n\t\t\t\t       name);\n\t\ttalloc_free(res);\n\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t}\n\ttalloc_free(res);\n\n\treturn samldb_next_step(ac);\n}\n","project":"samba","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_J(fz_context *ctx, pdf_processor *proc, int linecap)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pdf_flush_text(ctx, pr);\n\n\tpr->dev->flags &= ~(FZ_DEVFLAG_STARTCAP_UNDEFINED | FZ_DEVFLAG_DASHCAP_UNDEFINED | FZ_DEVFLAG_ENDCAP_UNDEFINED);\n\tgstate->stroke_state = fz_unshare_stroke_state(ctx, gstate->stroke_state);\n\tgstate->stroke_state->start_cap = linecap;\n\tgstate->stroke_state->dash_cap = linecap;\n\tgstate->stroke_state->end_cap = linecap;\n}\n","project":"ghostscript","target":0},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"     BufferMeta(const sp<GraphicBuffer> &graphicBuffer, OMX_U32 portIndex)\n         : mGraphicBuffer(graphicBuffer),\n          mIsBackup(false),\n          mPortIndex(portIndex) {\n     }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_ET(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_flush_text(ctx, pr);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long AudioTrack::Parse(\n    Segment* pSegment,\n    const Info& info,\n    long long element_start,\n    long long element_size,\n    AudioTrack*& pResult)\n{\n    if (pResult)\n        return -1;\n \n    if (info.type != Track::kAudio)\n        return -1;\n \n    IMkvReader* const pReader = pSegment->m_pReader;\n \n    const Settings& s = info.settings;\n    assert(s.start >= 0);\n    assert(s.size >= 0);\n \n    long long pos = s.start;\n    assert(pos >= 0);\n \n    const long long stop = pos + s.size;\n \n    double rate = 8000.0;  \/\/ MKV default\n    long long channels = 1;\n    long long bit_depth = 0;\n \n    while (pos < stop)\n    {\n        long long id, size;\n \n        long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n \n        if (status < 0)  \/\/error\n            return status;\n \n        if (id == 0x35)  \/\/Sample Rate\n        {\n            status = UnserializeFloat(pReader, pos, size, rate);\n \n            if (status < 0)\n                return status;\n \n            if (rate <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x1F)  \/\/Channel Count\n        {\n            channels = UnserializeUInt(pReader, pos, size);\n \n            if (channels <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x2264)  \/\/Bit Depth\n        {\n            bit_depth = UnserializeUInt(pReader, pos, size);\n \n            if (bit_depth <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n \n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n \n    AudioTrack* const pTrack = new (std::nothrow) AudioTrack(pSegment,\n                                                             element_start,\n                                                             element_size);\n \n    if (pTrack == NULL)\n        return -1;  \/\/generic error\n \n    const int status = info.Copy(pTrack->m_info);\n \n     if (status)\n    {\n        delete pTrack;\n        return status;\n    }\n    pTrack->m_rate = rate;\n    pTrack->m_channels = channels;\n    pTrack->m_bitDepth = bit_depth;\n \n     pResult = pTrack;\n    return 0;  \/\/success\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"static unsigned int subpel_variance_ref(const uint8_t *ref, const uint8_t *src,\n                                        int l2w, int l2h, int xoff, int yoff,\n                                        unsigned int *sse_ptr) {\n  int se = 0;\n  unsigned int sse = 0;\n  const int w = 1 << l2w, h = 1 << l2h;\n   for (int y = 0; y < h; y++) {\n     for (int x = 0; x < w; x++) {\n      const int a1 = ref[(w + 1) * (y + 0) + x + 0];\n      const int a2 = ref[(w + 1) * (y + 0) + x + 1];\n      const int b1 = ref[(w + 1) * (y + 1) + x + 0];\n      const int b2 = ref[(w + 1) * (y + 1) + x + 1];\n      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);\n      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);\n      const int r = a + (((b - a) * yoff + 8) >> 4);\n      int diff = r - src[w * y + x];\n      se += diff;\n      sse += diff * diff;\n     }\n   }\n  *sse_ptr = sse;\n  return sse - (((int64_t) se * se) >> (l2w + l2h));\n }\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_first_step(struct samldb_ctx *ac)\n{\n\tif (ac->steps == NULL) {\n\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t}\n\n\tac->curstep = ac->steps;\n\treturn ac->curstep->fn(ac);\n}\n","project":"samba","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"int Track::Info::Copy(Info& dst) const\n{\n    if (&dst == this)\n        return 0;\n \n    dst.type = type;\n    dst.number = number;\n    dst.defaultDuration = defaultDuration;\n    dst.codecDelay = codecDelay;\n    dst.seekPreRoll = seekPreRoll;\n    dst.uid = uid;\n    dst.lacing = lacing;\n    dst.settings = settings;\n \n \n    if (int status = CopyStr(&Info::nameAsUTF8, dst))\n        return status;\n \n    if (int status = CopyStr(&Info::language, dst))\n        return status;\n \n    if (int status = CopyStr(&Info::codecId, dst))\n        return status;\n \n    if (int status = CopyStr(&Info::codecNameAsUTF8, dst))\n        return status;\n \n    if (codecPrivateSize > 0)\n    {\n        if (codecPrivate == NULL)\n            return -1;\n \n        if (dst.codecPrivate)\n            return -1;\n \n        if (dst.codecPrivateSize != 0)\n            return -1;\n \n        dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];\n \n        if (dst.codecPrivate == NULL)\n            return -1;\n \n        memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);\n        dst.codecPrivateSize = codecPrivateSize;\n     }\n \n    return 0;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_MSHUTDOWN_FUNCTION(openssl)\n{\n\tEVP_cleanup();\n\n\tphp_unregister_url_stream_wrapper(\"https\" TSRMLS_CC);\n\tphp_unregister_url_stream_wrapper(\"ftps\" TSRMLS_CC);\n\n\tphp_stream_xport_unregister(\"ssl\" TSRMLS_CC);\n#ifndef OPENSSL_NO_SSL2\n\tphp_stream_xport_unregister(\"sslv2\" TSRMLS_CC);\n#endif\n\tphp_stream_xport_unregister(\"sslv3\" TSRMLS_CC);\n\tphp_stream_xport_unregister(\"tls\" TSRMLS_CC);\n\n\t\/* reinstate the default tcp handler *\/\n\tphp_stream_xport_register(\"tcp\", php_stream_generic_socket_factory TSRMLS_CC);\n\n\treturn SUCCESS;\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_icc_data_from_icc_colorspace(fz_context *ctx, const fz_colorspace *cs)\n{\n\tfz_iccprofile *profile;\n\n\tif (cs == NULL || !fz_colorspace_is_icc(ctx, cs))\n\t\treturn NULL;\n\tprofile = cs->data;\n\tif (!profile)\n\t\treturn NULL;\n\treturn profile->buffer;\n}\n","project":"ghostscript","target":0},{"commit_id":"918eeaa29d99d257282fafec931b4bda0e3bae12","func":"void SoftMPEG2::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n \/* If input EOS is seen and decoder is not in flush mode,\n     * set the decoder in flush mode.\n     * There can be a case where EOS is sent along with last picture data\n     * In that case, only after decoding that input data, decoder has to be\n     * put in flush. This case is handled here  *\/\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL && (inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n            mReceivedEOS = true;\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n                setFlushMode();\n }\n }\n\n if (mInitNeeded && !mIsInFlush) {\n bool portWillReset = false;\n            handlePortSettingsChange(&portWillReset, mNewWidth, mNewHeight);\n\n            CHECK_EQ(reInitDecoder(), (status_t)OK);\n return;\n }\n\n \/* Get a free slot in timestamp array to hold input timestamp *\/\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n\n             WORD32 timeDelay, timeTaken;\n             size_t sizeY, sizeUV;\n \n            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n             DUMP_TO_FILE(mInFile, s_dec_ip.pv_stream_buffer, s_dec_ip.u4_num_Bytes);\n \n if (s_dec_ip.u4_num_Bytes > 0) {\n char *ptr = (char *)s_dec_ip.pv_stream_buffer;\n }\n\n            GETTIME(&mTimeStart, NULL);\n \/* Compute time elapsed between end of previous decode()\n             * to start of current decode() *\/\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n            IV_API_CALL_STATUS_T status;\n            status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n\n bool unsupportedDimensions = (IMPEG2D_UNSUPPORTED_DIMENSIONS == s_dec_op.u4_error_code);\n bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n\n            GETTIME(&mTimeEnd, NULL);\n \/* Compute time taken for decode() *\/\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            ALOGV(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n \/* If the input did not contain picture data, then ignore\n                 * the associated timestamp *\/\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (unsupportedDimensions && !mFlushNeeded) {\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, s_dec_op.u4_pic_wd, s_dec_op.u4_pic_ht);\n\n \n                 CHECK_EQ(reInitDecoder(), (status_t)OK);\n \n                setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n                ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n                 return;\n             }\n \n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (unsupportedDimensions || resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n\n if (unsupportedDimensions) {\n                    mNewWidth = s_dec_op.u4_pic_wd;\n                    mNewHeight = s_dec_op.u4_pic_ht;\n                    mInitNeeded = true;\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n size_t timeStampIdx;\n                outHeader->nFilledLen = (mWidth * mHeight * 3) \/ 2;\n\n                timeStampIdx = getMinTimestampIdx(mTimeStamps, mTimeStampsValid);\n                outHeader->nTimeStamp = mTimeStamps[timeStampIdx];\n                mTimeStampsValid[timeStampIdx] = false;\n\n \/* mWaitForI waits for the first I picture. Once made FALSE, it\n                   has to remain false till explicitly set to TRUE. *\/\n                mWaitForI = mWaitForI && !(IV_I_FRAME == s_dec_op.e_pic_type);\n\n if (mWaitForI) {\n                    s_dec_op.u4_output_present = false;\n } else {\n                    ALOGV(\"Output timestamp: %lld, res: %ux%u\",\n (long long)outHeader->nTimeStamp, mWidth, mHeight);\n                    DUMP_TO_FILE(mOutFile, outHeader->pBuffer, outHeader->nFilledLen);\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n }\n } else {\n \/* If in flush mode and no output is returned by the codec,\n                 * then come out of flush mode *\/\n                mIsInFlush = false;\n\n \/* If EOS was recieved on input port and there is no output\n                 * from the codec, then signal EOS on output port *\/\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"phar_entry_info *phar_get_link_source(phar_entry_info *entry TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_entry_info *link_entry;\n\tchar *link;\n\n\tif (!entry->link) {\n\t\treturn entry;\n\t}\n\n\tlink = phar_get_link_location(entry TSRMLS_CC);\n\tif (SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->link, strlen(entry->link), (void **)&link_entry) ||\n\t\tSUCCESS == zend_hash_find(&(entry->phar->manifest), link, strlen(link), (void **)&link_entry)) {\n\t\tif (link != entry->link) {\n\t\t\tefree(link);\n\t\t}\n\t\treturn phar_get_link_source(link_entry TSRMLS_CC);\n\t} else {\n\t\tif (link != entry->link) {\n\t\t\tefree(link);\n\t\t}\n\t\treturn NULL;\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void fdct4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n  vp9_fdct4x4_c(in, out, stride);\n }\n","project":"Android","target":1},{"commit_id":"268068f25673242d1d5130d96202d3288c91b700","func":" void install_local_socket(asocket* s) {\n    adb_mutex_lock(&socket_list_lock);\n \n     s->id = local_socket_next_id++;\n \n     if (local_socket_next_id == 0) {\n        local_socket_next_id = 1;\n     }\n \n     insert_local_socket(s, &local_socket_list);\n    adb_mutex_unlock(&socket_list_lock);\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void gray_to_rgb(fz_context *ctx, const fz_colorspace *cs, const float *gray, float *rgb)\n{\n\trgb[0] = gray[0];\n\trgb[1] = gray[0];\n\trgb[2] = gray[0];\n}\n","project":"ghostscript","target":0},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b\/25884056\");\n return BAD_VALUE;\n\n     }\n \n     Mutex::Autolock autoLock(mLock);\n    if (allottedSize > params->size()) {\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params, portIndex, true);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n\n     }\n \n     CHECK_EQ(header->pAppPrivate, buffer_meta);\n \n     *buffer = makeBufferID(header);\n \n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n\n return OK;\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"PHPAPI void php_pcre_split_impl(pcre_cache_entry *pce, char *subject, int subject_len, zval *return_value,\n\tlong limit_val, long flags TSRMLS_DC)\n{\n\tpcre_extra\t\t*extra = NULL;\t\t\/* Holds results of studying *\/\n\tpcre\t\t\t*re_bump = NULL;\t\/* Regex instance for empty matches *\/\n\tpcre_extra\t\t*extra_bump = NULL;\t\/* Almost dummy *\/\n\tpcre_extra\t\t extra_data;\t\t\/* Used locally for exec options *\/\n\tint\t\t\t\t*offsets;\t\t\t\/* Array of subpattern offsets *\/\n\tint\t\t\t\t size_offsets;\t\t\/* Size of the offsets array *\/\n\tint\t\t\t\t exoptions = 0;\t\t\/* Execution options *\/\n\tint\t\t\t\t count = 0;\t\t\t\/* Count of matched subpatterns *\/\n\tint\t\t\t\t start_offset;\t\t\/* Where the new search starts *\/\n\tint\t\t\t\t next_offset;\t\t\/* End of the last delimiter match + 1 *\/\n\tint\t\t\t\t g_notempty = 0;\t\/* If the match should not be empty *\/\n\tchar\t\t\t*last_match;\t\t\/* Location of last match *\/\n\tint\t\t\t\t rc;\n\tint\t\t\t\t no_empty;\t\t\t\/* If NO_EMPTY flag is set *\/\n\tint\t\t\t\t delim_capture; \t\/* If delimiters should be captured *\/\n\tint\t\t\t\t offset_capture;\t\/* If offsets should be captured *\/\n\n\tno_empty = flags & PREG_SPLIT_NO_EMPTY;\n\tdelim_capture = flags & PREG_SPLIT_DELIM_CAPTURE;\n\toffset_capture = flags & PREG_SPLIT_OFFSET_CAPTURE;\n\t\n\tif (limit_val == 0) {\n\t\tlimit_val = -1;\n\t}\n\n\tif (extra == NULL) {\n\t\textra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;\n\t\textra = &extra_data;\n\t}\n\textra->match_limit = PCRE_G(backtrack_limit);\n\textra->match_limit_recursion = PCRE_G(recursion_limit);\n\t\n\t\/* Initialize return value *\/\n\tarray_init(return_value);\n\n\t\/* Calculate the size of the offsets array, and allocate memory for it. *\/\n\trc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &size_offsets);\n\tif (rc < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Internal pcre_fullinfo() error %d\", rc);\n\t\tRETURN_FALSE;\n\t}\n\tsize_offsets = (size_offsets + 1) * 3;\n\toffsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);\n\t\n\t\/* Start at the beginning of the string *\/\n\tstart_offset = 0;\n\tnext_offset = 0;\n\tlast_match = subject;\n\tPCRE_G(error_code) = PHP_PCRE_NO_ERROR;\n\t\n\t\/* Get next piece if no limit or limit not yet reached and something matched*\/\n\twhile ((limit_val == -1 || limit_val > 1)) {\n\t\tcount = pcre_exec(pce->re, extra, subject,\n\t\t\t\t\t\t  subject_len, start_offset,\n\t\t\t\t\t\t  exoptions|g_notempty, offsets, size_offsets);\n\n\t\t\/* the string was already proved to be valid UTF-8 *\/\n\t\texoptions |= PCRE_NO_UTF8_CHECK;\n\n\t\t\/* Check for too many substrings condition. *\/\n\t\tif (count == 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC,E_NOTICE, \"Matched, but too many substrings\");\n\t\t\tcount = size_offsets\/3;\n\t\t}\n\t\t\t\t\n\t\t\/* If something matched *\/\n\t\tif (count > 0) {\n\t\t\tif (!no_empty || &subject[offsets[0]] != last_match) {\n\n\t\t\t\tif (offset_capture) {\n\t\t\t\t\t\/* Add (match, offset) pair to the return value *\/\n\t\t\t\t\tadd_offset_pair(return_value, last_match, &subject[offsets[0]]-last_match, next_offset, NULL);\n\t\t\t\t} else {\n\t\t\t\t\t\/* Add the piece to the return value *\/\n\t\t\t\t\tadd_next_index_stringl(return_value, last_match,\n\t\t\t\t\t\t\t\t   \t   &subject[offsets[0]]-last_match, 1);\n\t\t\t\t}\n\n\t\t\t\t\/* One less left to do *\/\n\t\t\t\tif (limit_val != -1)\n\t\t\t\t\tlimit_val--;\n\t\t\t}\n\t\t\t\n\t\t\tlast_match = &subject[offsets[1]];\n\t\t\tnext_offset = offsets[1];\n\n\t\t\tif (delim_capture) {\n\t\t\t\tint i, match_len;\n\t\t\t\tfor (i = 1; i < count; i++) {\n\t\t\t\t\tmatch_len = offsets[(i<<1)+1] - offsets[i<<1];\n\t\t\t\t\t\/* If we have matched a delimiter *\/\n\t\t\t\t\tif (!no_empty || match_len > 0) {\n\t\t\t\t\t\tif (offset_capture) {\n\t\t\t\t\t\t\tadd_offset_pair(return_value, &subject[offsets[i<<1]], match_len, offsets[i<<1], NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadd_next_index_stringl(return_value,\n\t\t\t\t\t\t\t\t\t\t\t\t   &subject[offsets[i<<1]],\n\t\t\t\t\t\t\t\t\t\t\t\t   match_len, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (count == PCRE_ERROR_NOMATCH) {\n\t\t\t\/* If we previously set PCRE_NOTEMPTY after a null match,\n\t\t\t   this is not necessarily the end. We need to advance\n\t\t\t   the start offset, and continue. Fudge the offset values\n\t\t\t   to achieve this, unless we're already at the end of the string. *\/\n\t\t\tif (g_notempty != 0 && start_offset < subject_len) {\n\t\t\t\tif (pce->compile_options & PCRE_UTF8) {\n\t\t\t\t\tif (re_bump == NULL) {\n\t\t\t\t\t\tint dummy;\n\n\t\t\t\t\t\tif ((re_bump = pcre_get_compiled_regex(\"\/.\/us\", &extra_bump, &dummy TSRMLS_CC)) == NULL) {\n\t\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount = pcre_exec(re_bump, extra_bump, subject,\n\t\t\t\t\t\t\t  subject_len, start_offset,\n\t\t\t\t\t\t\t  exoptions, offsets, size_offsets);\n\t\t\t\t\tif (count < 1) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown error\");\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toffsets[0] = start_offset;\n\t\t\t\t\toffsets[1] = start_offset + 1;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tpcre_handle_exec_error(count TSRMLS_CC);\n\t\t\tbreak;\n\t\t}\n\n\t\t\/* If we have matched an empty string, mimic what Perl's \/g options does.\n\t\t   This turns out to be rather cunning. First we set PCRE_NOTEMPTY and try\n\t\t   the match again at the same point. If this fails (picked up above) we\n\t\t   advance to the next character. *\/\n\t\tg_notempty = (offsets[1] == offsets[0])? PCRE_NOTEMPTY | PCRE_ANCHORED : 0;\n\t\t\n\t\t\/* Advance to the position right after the last full match *\/\n\t\tstart_offset = offsets[1];\n\t}\n\n\n\tstart_offset = last_match - subject; \/* the offset might have been incremented, but without further successful matches *\/\n\n\tif (!no_empty || start_offset < subject_len)\n\t{\n\t\tif (offset_capture) {\n\t\t\t\/* Add the last (match, offset) pair to the return value *\/\n\t\t\tadd_offset_pair(return_value, &subject[start_offset], subject_len - start_offset, start_offset, NULL);\n\t\t} else {\n\t\t\t\/* Add the last piece to the return value *\/\n\t\t\tadd_next_index_stringl(return_value, last_match, subject + subject_len - last_match, 1);\n\t\t}\n\t}\n\n\t\n\t\/* Clean up *\/\n\tefree(offsets);\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_drop_colorspace_imp(fz_context *ctx, fz_storable *cs_)\n{\n\tfz_colorspace *cs = (fz_colorspace *)cs_;\n\tint i;\n\n\tif (cs->free_data && cs->data)\n\t\tcs->free_data(ctx, cs);\n\tfor (i = 0; i < FZ_MAX_COLORS; i++)\n\t\tfz_free(ctx, cs->colorant[i]);\n\tfz_free(ctx, cs);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void SetUp() {\n    svc_.encoding_mode = INTER_LAYER_PREDICTION_IP;\n     svc_.log_level = SVC_LOG_DEBUG;\n     svc_.log_print = 0;\n \n    codec_iface_ = vpx_codec_vp9_cx();\n const vpx_codec_err_t res =\n        vpx_codec_enc_config_default(codec_iface_, &codec_enc_, 0);\n    EXPECT_EQ(VPX_CODEC_OK, res);\n\n    codec_enc_.g_w = kWidth;\n    codec_enc_.g_h = kHeight;\n    codec_enc_.g_timebase.num = 1;\n    codec_enc_.g_timebase.den = 60;\n\n     codec_enc_.kf_min_dist = 100;\n     codec_enc_.kf_max_dist = 100;\n \n    vpx_codec_dec_cfg_t dec_cfg = {0};\n     VP9CodecFactory codec_factory;\n     decoder_ = codec_factory.CreateDecoder(dec_cfg, 0);\n   }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void RunSignBiasCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_output_block, 64);\n     int count_sign_block[64][2];\n     const int count_test_block = 100000;\n \n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n\n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = rnd.Rand8() - rnd.Rand8();\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 1125;\n      EXPECT_LT(diff, max_diff)\n           << \"Error: 8x8 FDCT\/FHT has a sign bias > \"\n           << 1. * max_diff \/ count_test_block * 100 << \"%\"\n           << \" for input range [-255, 255] at index \" << j\n << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n\n\n     memset(count_sign_block, 0, sizeof(count_sign_block));\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = (rnd.Rand8() >> 4) - (rnd.Rand8() >> 4);\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 10000;\n      EXPECT_LT(diff, max_diff)\n          << \"Error: 4x4 FDCT\/FHT has a sign bias > \"\n           << 1. * max_diff \/ count_test_block * 100 << \"%\"\n           << \" for input range [-15, 15] at index \" << j\n           << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Segment::Segment(\n    IMkvReader* pReader,\n    long long elem_start,\n    long long start,\n    long long size) :\n    m_pReader(pReader),\n    m_element_start(elem_start),\n    m_start(start),\n    m_size(size),\n    m_pos(start),\n    m_pUnknownSize(0),\n    m_pSeekHead(NULL),\n    m_pInfo(NULL),\n    m_pTracks(NULL),\n    m_pCues(NULL),\n    m_pChapters(NULL),\n    m_clusters(NULL),\n    m_clusterCount(0),\n    m_clusterPreloadCount(0),\n    m_clusterSize(0)\n{\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Cluster* BlockEntry::GetCluster() const\n{\n    return m_pCluster;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Cluster::GetEntry(\n    const CuePoint& cp,\n    const CuePoint::TrackPosition& tp) const\n{\n    assert(m_pSegment);\n \n #if 0\n \n LoadBlockEntries();\n\n if (m_entries == NULL)\n return NULL;\n\n const long long count = m_entries_count;\n\n if (count <= 0)\n return NULL;\n\n const long long tc = cp.GetTimeCode();\n\n if ((tp.m_block > 0) && (tp.m_block <= count))\n {\n const size_t block = static_cast<size_t>(tp.m_block);\n const size_t index = block - 1;\n\n const BlockEntry* const pEntry = m_entries[index];\n        assert(pEntry);\n        assert(!pEntry->EOS());\n\n const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n\n if ((pBlock->GetTrackNumber() == tp.m_track) &&\n (pBlock->GetTimeCode(this) == tc))\n {\n return pEntry;\n }\n }\n\n const BlockEntry* const* i = m_entries;\n const BlockEntry* const* const j = i + count;\n\n while (i != j)\n {\n#ifdef _DEBUG\n const ptrdiff_t idx = i - m_entries;\n        idx;\n#endif\n\n const BlockEntry* const pEntry = *i++;\n        assert(pEntry);\n        assert(!pEntry->EOS());\n\n const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n\n if (pBlock->GetTrackNumber() != tp.m_track)\n continue;\n\n const long long tc_ = pBlock->GetTimeCode(this);\n        assert(tc_ >= 0);\n\n if (tc_ < tc)\n continue;\n\n if (tc_ > tc)\n return NULL;\n\n const Tracks* const pTracks = m_pSegment->GetTracks();\n        assert(pTracks);\n\n const long tn = static_cast<long>(tp.m_track);\n const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n\n if (pTrack == NULL)\n return NULL;\n\n const long long type = pTrack->GetType();\n\n if (type == 2) \/\/audio\n return pEntry;\n\n if (type != 1) \/\/not video\n return NULL;\n\n if (!pBlock->IsKey())\n return NULL;\n\n return pEntry;\n }\n\n return NULL;\n\n \n #else\n \n    const long long tc = cp.GetTimeCode();\n \n    if (tp.m_block > 0)\n    {\n        const long block = static_cast<long>(tp.m_block);\n        const long index = block - 1;\n \n        while (index >= m_entries_count)\n        {\n            long long pos;\n            long len;\n \n            const long status = Parse(pos, len);\n \n            if (status < 0)  \/\/TODO: can this happen?\n                return NULL;\n \n            if (status > 0)  \/\/nothing remains to be parsed\n                return NULL;\n        }\n        const BlockEntry* const pEntry = m_entries[index];\n        assert(pEntry);\n        assert(!pEntry->EOS());\n        const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n        if ((pBlock->GetTrackNumber() == tp.m_track) &&\n            (pBlock->GetTimeCode(this) == tc))\n        {\n            return pEntry;\n        }\n     }\n \n    long index = 0;\n \n    for (;;)\n    {\n        if (index >= m_entries_count)\n        {\n            long long pos;\n            long len;\n \n            const long status = Parse(pos, len);\n            if (status < 0)  \/\/TODO: can this happen?\n                return NULL;\n            if (status > 0)  \/\/nothing remains to be parsed\n                return NULL;\n            assert(m_entries);\n            assert(index < m_entries_count);\n        }\n        const BlockEntry* const pEntry = m_entries[index];\n        assert(pEntry);\n        assert(!pEntry->EOS());\n        const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n        if (pBlock->GetTrackNumber() != tp.m_track)\n        {\n            ++index;\n            continue;\n        }\n        const long long tc_ = pBlock->GetTimeCode(this);\n        if (tc_ < tc)\n        {\n            ++index;\n            continue;\n        }\n        if (tc_ > tc)\n            return NULL;\n        const Tracks* const pTracks = m_pSegment->GetTracks();\n        assert(pTracks);\n        const long tn = static_cast<long>(tp.m_track);\n        const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n        if (pTrack == NULL)\n            return NULL;\n        const long long type = pTrack->GetType();\n        if (type == 2)  \/\/audio\n            return pEntry;\n        if (type != 1)  \/\/not video\n            return NULL;\n        if (!pBlock->IsKey())\n            return NULL;\n        return pEntry;\n     }\n \n #endif\n }\n","project":"Android","target":1},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"long ssl3_callback_ctrl(SSL *s, int cmd, void (*fp)(void))\n\t{\n\tint ret=0;\n\n#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_RSA)\n\tif (\n#ifndef OPENSSL_NO_RSA\n\t    cmd == SSL_CTRL_SET_TMP_RSA_CB ||\n#endif\n#ifndef OPENSSL_NO_DSA\n\t    cmd == SSL_CTRL_SET_TMP_DH_CB ||\n#endif\n\t\t0)\n\t\t{\n\t\tif (!ssl_cert_inst(&s->cert))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CALLBACK_CTRL, ERR_R_MALLOC_FAILURE);\n\t\t\treturn(0);\n\t\t\t}\n\t\t}\n#endif\n\n\tswitch (cmd)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\tcase SSL_CTRL_SET_TMP_RSA_CB:\n\t\t{\n\t\ts->cert->rsa_tmp_cb = (RSA *(*)(SSL *, int, int))fp;\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DH\n\tcase SSL_CTRL_SET_TMP_DH_CB:\n\t\t{\n\t\ts->cert->dh_tmp_cb = (DH *(*)(SSL *, int, int))fp;\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tcase SSL_CTRL_SET_TMP_ECDH_CB:\n\t\t{\n\t\ts->cert->ecdh_tmp_cb = (EC_KEY *(*)(SSL *, int, int))fp;\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_TLSEXT\n\tcase SSL_CTRL_SET_TLSEXT_DEBUG_CB:\n\t\ts->tlsext_debug_cb=(void (*)(SSL *,int ,int,\n\t\t\t\t\tunsigned char *, int, void *))fp;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t\t}\n\treturn(ret);\n\t}\n","project":"openssl","target":0},{"commit_id":"2b9fb0c2074d370a254b35e2489de2d94943578d","func":"IHEVCD_ERROR_T ihevcd_parse_slice_data(codec_t *ps_codec)\n{\n\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 end_of_slice_flag = 0;\n sps_t *ps_sps;\n pps_t *ps_pps;\n slice_header_t *ps_slice_hdr;\n    WORD32 end_of_pic;\n tile_t *ps_tile, *ps_tile_prev;\n    WORD32 i;\n    WORD32 ctb_addr;\n    WORD32 tile_idx;\n    WORD32 cabac_init_idc;\n    WORD32 ctb_size;\n    WORD32 num_ctb_in_row;\n    WORD32 num_min4x4_in_ctb;\n    WORD32 slice_qp;\n    WORD32 slice_start_ctb_idx;\n    WORD32 tile_start_ctb_idx;\n\n\n    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base;\n    ps_pps = ps_codec->s_parse.ps_pps_base;\n    ps_sps = ps_codec->s_parse.ps_sps_base;\n\n \/* Get current slice header, pps and sps *\/\n    ps_slice_hdr += (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n    ps_pps  += ps_slice_hdr->i1_pps_id;\n    ps_sps  += ps_pps->i1_sps_id;\n\n if(0 != ps_codec->s_parse.i4_cur_slice_idx)\n {\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_codec->s_parse.i4_cur_independent_slice_idx++;\n if(MAX_SLICE_HDR_CNT == ps_codec->s_parse.i4_cur_independent_slice_idx)\n                ps_codec->s_parse.i4_cur_independent_slice_idx = 0;\n }\n }\n\n\n    ctb_size = 1 << ps_sps->i1_log2_ctb_size;\n    num_min4x4_in_ctb = (ctb_size \/ 4) * (ctb_size \/ 4);\n    num_ctb_in_row = ps_sps->i2_pic_wd_in_ctb;\n\n \/* Update the parse context *\/\n if(0 == ps_codec->i4_slice_error)\n {\n        ps_codec->s_parse.i4_ctb_x = ps_slice_hdr->i2_ctb_x;\n        ps_codec->s_parse.i4_ctb_y = ps_slice_hdr->i2_ctb_y;\n }\n    ps_codec->s_parse.ps_pps = ps_pps;\n    ps_codec->s_parse.ps_sps = ps_sps;\n    ps_codec->s_parse.ps_slice_hdr = ps_slice_hdr;\n\n \/* Derive Tile positions for the current CTB *\/\n \/* Change this to lookup if required *\/\n    ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,\n                        ps_codec->s_parse.i4_ctb_y,\n &ps_codec->s_parse.i4_ctb_tile_x,\n &ps_codec->s_parse.i4_ctb_tile_y,\n &tile_idx);\n    ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;\n    ps_codec->s_parse.i4_cur_tile_idx = tile_idx;\n    ps_tile = ps_codec->s_parse.ps_tile;\n if(tile_idx)\n        ps_tile_prev = ps_tile - 1;\n else\n        ps_tile_prev = ps_tile;\n\n \/* If the present slice is dependent, then store the previous\n     * independent slices' ctb x and y values for decoding process *\/\n if(0 == ps_codec->i4_slice_error)\n {\n if(1 == ps_slice_hdr->i1_dependent_slice_flag)\n {\n \/*If slice is present at the start of a new tile*\/\n if((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                ps_codec->s_parse.i4_ctb_slice_x = 0;\n                ps_codec->s_parse.i4_ctb_slice_y = 0;\n }\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_codec->s_parse.i4_ctb_slice_x = 0;\n            ps_codec->s_parse.i4_ctb_slice_y = 0;\n }\n }\n\n \/* Frame level initializations *\/\n if((0 == ps_codec->s_parse.i4_ctb_y) &&\n (0 == ps_codec->s_parse.i4_ctb_x))\n {\n        ret = ihevcd_parse_pic_init(ps_codec);\n        RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);\n\n        ps_codec->s_parse.pu4_pic_tu_idx[0] = 0;\n        ps_codec->s_parse.pu4_pic_pu_idx[0] = 0;\n        ps_codec->s_parse.i4_cur_independent_slice_idx = 0;\n        ps_codec->s_parse.i4_ctb_tile_x = 0;\n        ps_codec->s_parse.i4_ctb_tile_y = 0;\n }\n\n {\n \/* Updating the poc list of current slice to ps_mv_buf *\/\n mv_buf_t *ps_mv_buf = ps_codec->s_parse.ps_cur_mv_buf;\n\n if(ps_slice_hdr->i1_num_ref_idx_l1_active != 0)\n {\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)\n {\n                ps_mv_buf->l1_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->i4_abs_poc;\n                ps_mv_buf->u1_l1_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->u1_used_as_ref;\n }\n }\n\n if(ps_slice_hdr->i1_num_ref_idx_l0_active != 0)\n {\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)\n {\n                ps_mv_buf->l0_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->i4_abs_poc;\n                ps_mv_buf->u1_l0_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->u1_used_as_ref;\n }\n }\n }\n\n \/*Initialize the low delay flag at the beginning of every slice*\/\n if((0 == ps_codec->s_parse.i4_ctb_slice_x) || (0 == ps_codec->s_parse.i4_ctb_slice_y))\n {\n \/* Lowdelay flag *\/\n        WORD32 cur_poc, ref_list_poc, flag = 1;\n        cur_poc = ps_slice_hdr->i4_abs_pic_order_cnt;\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)\n {\n            ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_mv_buf)->i4_abs_poc;\n if(ref_list_poc > cur_poc)\n {\n                flag = 0;\n break;\n }\n }\n if(flag && (ps_slice_hdr->i1_slice_type == BSLICE))\n {\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)\n {\n                ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_mv_buf)->i4_abs_poc;\n if(ref_list_poc > cur_poc)\n {\n                    flag = 0;\n break;\n }\n }\n }\n        ps_slice_hdr->i1_low_delay_flag = flag;\n }\n\n \/* initialize the cabac init idc based on slice type *\/\n if(ps_slice_hdr->i1_slice_type == ISLICE)\n {\n        cabac_init_idc = 0;\n }\n else if(ps_slice_hdr->i1_slice_type == PSLICE)\n {\n        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 2 : 1;\n }\n else\n {\n        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 1 : 2;\n }\n\n    slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;\n    slice_qp = CLIP3(slice_qp, 0, 51);\n\n \/*Update QP value for every indepndent slice or for every dependent slice that begins at the start of a new tile*\/\n if((0 == ps_slice_hdr->i1_dependent_slice_flag) ||\n ((1 == ps_slice_hdr->i1_dependent_slice_flag) && ((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))))\n {\n        ps_codec->s_parse.u4_qp = slice_qp;\n }\n\n \/*Cabac init at the beginning of a slice*\/\n if((1 == ps_slice_hdr->i1_dependent_slice_flag) && (!((ps_codec->s_parse.i4_ctb_tile_x == 0) && (ps_codec->s_parse.i4_ctb_tile_y == 0))))\n {\n if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))\n {\n            ihevcd_cabac_reset(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm);\n }\n }\n else if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))\n {\n        ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                slice_qp,\n                                cabac_init_idc,\n &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n            ps_codec->i4_slice_error = 1;\n            end_of_slice_flag = 1;\n            ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n }\n\n\n do\n {\n\n {\n            WORD32 cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n if(1 == ps_codec->i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB)\n {\n                ps_codec->s_parse.ps_tu = ps_codec->s_parse.ps_pic_tu;\n                ps_codec->s_parse.i4_pic_tu_idx = 0;\n }\n }\n\n        end_of_pic = 0;\n \/* Section:7.3.7 Coding tree unit syntax *\/\n \/* coding_tree_unit() inlined here *\/\n \/* If number of cores is greater than 1, then add job to the queue *\/\n \/* At the start of ctb row parsing in a tile, queue a job for processing the current tile row *\/\n        ps_codec->s_parse.i4_ctb_num_pcm_blks = 0;\n\n\n \/*At the beginning of each tile-which is not the beginning of a slice, cabac context must be initialized.\n         * Hence, check for the tile beginning here *\/\n if(((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))\n && (!((ps_tile->u1_pos_x == 0) && (ps_tile->u1_pos_y == 0)))\n && (!((0 == ps_codec->s_parse.i4_ctb_slice_x) && (0 == ps_codec->s_parse.i4_ctb_slice_y))))\n {\n            slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;\n            slice_qp = CLIP3(slice_qp, 0, 51);\n            ps_codec->s_parse.u4_qp = slice_qp;\n\n            ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,\n                                ps_codec->s_parse.i4_ctb_y,\n &ps_codec->s_parse.i4_ctb_tile_x,\n &ps_codec->s_parse.i4_ctb_tile_y,\n &tile_idx);\n\n            ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;\n            ps_codec->s_parse.i4_cur_tile_idx = tile_idx;\n            ps_tile_prev = ps_tile - 1;\n\n            tile_start_ctb_idx = ps_tile->u1_pos_x\n + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);\n\n            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x\n + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n \/*For slices that span across multiple tiles*\/\n if(slice_start_ctb_idx < tile_start_ctb_idx)\n { \/* 2 Cases\n             * 1 - slice spans across frame-width- but does not start from 1st column\n             * 2 - Slice spans across multiple tiles anywhere is a frame\n             *\/\n                ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;\n if(!(((ps_slice_hdr->i2_ctb_x + ps_tile_prev->u2_wd) % ps_sps->i2_pic_wd_in_ctb) == ps_tile->u1_pos_x)) \/\/Case 2\n {\n if(ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)\n {\n if(ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x)\n {\n                            ps_codec->s_parse.i4_ctb_slice_y -= 1;\n }\n }\n }\n \/*ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;\n                if (ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)\n                {\n                    if (ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x )\n                    {\n                        ps_codec->s_parse.i4_ctb_slice_y -= 1 ;\n                    }\n                }*\/\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n                ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                        slice_qp,\n                                        cabac_init_idc,\n &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n                    ps_codec->i4_slice_error = 1;\n                    end_of_slice_flag = 1;\n                    ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n\n }\n }\n \/* If number of cores is greater than 1, then add job to the queue *\/\n \/* At the start of ctb row parsing in a tile, queue a job for processing the current tile row *\/\n\n if(0 == ps_codec->s_parse.i4_ctb_tile_x)\n {\n\n if(1 < ps_codec->i4_num_cores)\n {\n proc_job_t s_job;\n                IHEVCD_ERROR_T ret;\n                s_job.i4_cmd    = CMD_PROCESS;\n                s_job.i2_ctb_cnt = (WORD16)ps_tile->u2_wd;\n                s_job.i2_ctb_x = (WORD16)ps_codec->s_parse.i4_ctb_x;\n                s_job.i2_ctb_y = (WORD16)ps_codec->s_parse.i4_ctb_y;\n                s_job.i2_slice_idx = (WORD16)ps_codec->s_parse.i4_cur_slice_idx;\n                s_job.i4_tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -\n (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;\n                ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq, &s_job, sizeof(proc_job_t), 1);\n\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n return ret;\n }\n else\n {\n process_ctxt_t *ps_proc = &ps_codec->as_process[0];\n                WORD32 tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -\n (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;\n\n \/* If the codec is running in single core mode,\n                 * initialize zeroth process context\n                 * TODO: Dual core mode might need a different implementation instead of jobq\n                 *\/\n\n                ps_proc->i4_ctb_cnt = ps_tile->u2_wd;\n                ps_proc->i4_ctb_x   = ps_codec->s_parse.i4_ctb_x;\n                ps_proc->i4_ctb_y   = ps_codec->s_parse.i4_ctb_y;\n                ps_proc->i4_cur_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;\n\n                ihevcd_init_proc_ctxt(ps_proc, tu_coeff_data_ofst);\n }\n }\n\n\n \/* Restore cabac context model from top right CTB if entropy sync is enabled *\/\n if(ps_pps->i1_entropy_coding_sync_enabled_flag)\n {\n \/*TODO Handle single CTB and top-right belonging to a different slice *\/\n if(0 == ps_codec->s_parse.i4_ctb_x)\n {\n                WORD32 default_ctxt = 0;\n\n if((0 == ps_codec->s_parse.i4_ctb_slice_y) && (!ps_slice_hdr->i1_dependent_slice_flag))\n                    default_ctxt = 1;\n if(1 == ps_sps->i2_pic_wd_in_ctb)\n                    default_ctxt = 1;\n\n                ps_codec->s_parse.u4_qp = slice_qp;\n if(default_ctxt)\n {\n                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                            slice_qp,\n                                            cabac_init_idc,\n &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);\n\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n                        ps_codec->i4_slice_error = 1;\n                        end_of_slice_flag = 1;\n                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n }\n else\n {\n                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                            slice_qp,\n                                            cabac_init_idc,\n (const UWORD8 *)&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync);\n\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n                        ps_codec->i4_slice_error = 1;\n                        end_of_slice_flag = 1;\n                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n }\n }\n }\n\n\n\n if(0 == ps_codec->i4_slice_error)\n {\n if(ps_slice_hdr->i1_slice_sao_luma_flag || ps_slice_hdr->i1_slice_sao_chroma_flag)\n                ihevcd_parse_sao(ps_codec);\n }\n else\n {\n sao_t *ps_sao = ps_codec->s_parse.ps_pic_sao +\n                            ps_codec->s_parse.i4_ctb_x +\n                            ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;\n\n \/* Default values *\/\n            ps_sao->b3_y_type_idx = 0;\n            ps_sao->b3_cb_type_idx = 0;\n            ps_sao->b3_cr_type_idx = 0;\n }\n\n\n {\n            WORD32 ctb_indx;\n            ctb_indx = ps_codec->s_parse.i4_ctb_x + ps_sps->i2_pic_wd_in_ctb * ps_codec->s_parse.i4_ctb_y;\n            ps_codec->s_parse.s_bs_ctxt.pu1_pic_qp_const_in_ctb[ctb_indx >> 3] |= (1 << (ctb_indx & 7));\n {\n                UWORD16 *pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;\n                pu1_slice_idx[ctb_indx] = ps_codec->s_parse.i4_cur_independent_slice_idx;\n }\n }\n\n if(0 == ps_codec->i4_slice_error)\n {\n tu_t *ps_tu = ps_codec->s_parse.ps_tu;\n            WORD32 i4_tu_cnt = ps_codec->s_parse.s_cu.i4_tu_cnt;\n            WORD32 i4_pic_tu_idx = ps_codec->s_parse.i4_pic_tu_idx;\n\n pu_t *ps_pu = ps_codec->s_parse.ps_pu;\n            WORD32 i4_pic_pu_idx = ps_codec->s_parse.i4_pic_pu_idx;\n\n            UWORD8 *pu1_tu_coeff_data = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data;\n\n            ret = ihevcd_parse_coding_quadtree(ps_codec,\n (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size),\n (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size),\n                                               ps_sps->i1_log2_ctb_size,\n 0);\n \/* Check for error *\/\n\n             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n             {\n                 \/* Reset tu and pu parameters, and signal current ctb as skip *\/\n                WORD32 pu_skip_wd, pu_skip_ht;\n                WORD32 rows_remaining, cols_remaining;\n                 WORD32 tu_coeff_data_reset_size;\n \n                \/* Set pu wd and ht based on whether the ctb is complete or not *\/\n                rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n                                - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n                pu_skip_ht = MIN(ctb_size, rows_remaining);\n                cols_remaining = ps_sps->i2_pic_width_in_luma_samples\n                                - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);\n                pu_skip_wd = MIN(ctb_size, cols_remaining);\n                 ps_codec->s_parse.ps_tu = ps_tu;\n                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;\n                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;\n\n\n                 ps_codec->s_parse.ps_pu = ps_pu;\n                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;\n \n                ps_tu->b1_cb_cbf = 0;\n                ps_tu->b1_cr_cbf = 0;\n                ps_tu->b1_y_cbf = 0;\n                ps_tu->b4_pos_x = 0;\n                ps_tu->b4_pos_y = 0;\n                ps_tu->b1_transquant_bypass = 0;\n                ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);\n                ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n                ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n                ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;\n                ps_tu->b1_first_tu_in_cu = 1;\n                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;\n                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);\n                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;\n \n                ps_codec->s_parse.ps_tu++;\n                ps_codec->s_parse.s_cu.i4_tu_cnt++;\n                ps_codec->s_parse.i4_pic_tu_idx++;\n                ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;\n                ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;\n                ps_pu->b2_part_idx = 0;\n                ps_pu->b4_pos_x = 0;\n                ps_pu->b4_pos_y = 0;\n                ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;\n                ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;\n                ps_pu->b1_intra_flag = 0;\n                ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;\n                ps_pu->b1_merge_flag = 1;\n                ps_pu->b3_merge_idx = 0;\n                ps_codec->s_parse.ps_pu++;\n                ps_codec->s_parse.i4_pic_pu_idx++;\n \n                 \/* Set slice error to suppress further parsing and\n                  * signal end of slice.\n                 *\/\n                ps_codec->i4_slice_error = 1;\n                end_of_slice_flag = 1;\n                ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n\n         }\n         else\n         {\n            tu_t *ps_tu = ps_codec->s_parse.ps_tu;\n            pu_t *ps_pu = ps_codec->s_parse.ps_pu;\n            WORD32 pu_skip_wd, pu_skip_ht;\n            WORD32 rows_remaining, cols_remaining;\n            \/* Set pu wd and ht based on whether the ctb is complete or not *\/\n            rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n                            - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n            pu_skip_ht = MIN(ctb_size, rows_remaining);\n            cols_remaining = ps_sps->i2_pic_width_in_luma_samples\n                            - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);\n            pu_skip_wd = MIN(ctb_size, cols_remaining);\n            ps_tu->b1_cb_cbf = 0;\n            ps_tu->b1_cr_cbf = 0;\n            ps_tu->b1_y_cbf = 0;\n            ps_tu->b4_pos_x = 0;\n            ps_tu->b4_pos_y = 0;\n            ps_tu->b1_transquant_bypass = 0;\n            ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);\n            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;\n            ps_tu->b1_first_tu_in_cu = 1;\n            ps_codec->s_parse.ps_tu++;\n            ps_codec->s_parse.s_cu.i4_tu_cnt++;\n            ps_codec->s_parse.i4_pic_tu_idx++;\n            ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;\n            ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;\n            ps_pu->b2_part_idx = 0;\n            ps_pu->b4_pos_x = 0;\n            ps_pu->b4_pos_y = 0;\n            ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;\n            ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;\n            ps_pu->b1_intra_flag = 0;\n            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;\n            ps_pu->b1_merge_flag = 1;\n            ps_pu->b3_merge_idx = 0;\n            ps_codec->s_parse.ps_pu++;\n            ps_codec->s_parse.i4_pic_pu_idx++;\n         }\n \n         if(0 == ps_codec->i4_slice_error)\n            end_of_slice_flag = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);\n\n        AEV_TRACE(\"end_of_slice_flag\", end_of_slice_flag, ps_codec->s_parse.s_cabac.u4_range);\n\n\n \/* In case of tiles or entropy sync, terminate cabac and copy cabac context backed up at the end of top-right CTB *\/\n if(ps_pps->i1_tiles_enabled_flag || ps_pps->i1_entropy_coding_sync_enabled_flag)\n {\n            WORD32 end_of_tile = 0;\n            WORD32 end_of_tile_row = 0;\n\n \/* Take a back up of cabac context models if entropy sync is enabled *\/\n if(ps_pps->i1_entropy_coding_sync_enabled_flag || ps_pps->i1_tiles_enabled_flag)\n {\n if(1 == ps_codec->s_parse.i4_ctb_x)\n {\n                    WORD32 size = sizeof(ps_codec->s_parse.s_cabac.au1_ctxt_models);\n                    memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync, &ps_codec->s_parse.s_cabac.au1_ctxt_models, size);\n }\n }\n\n \/* Since tiles and entropy sync are not enabled simultaneously, the following will not result in any problems *\/\n if((ps_codec->s_parse.i4_ctb_tile_x + 1) == (ps_tile->u2_wd))\n {\n                end_of_tile_row = 1;\n if((ps_codec->s_parse.i4_ctb_tile_y + 1) == ps_tile->u2_ht)\n                    end_of_tile = 1;\n }\n if((0 == end_of_slice_flag) &&\n ((ps_pps->i1_tiles_enabled_flag && end_of_tile) ||\n (ps_pps->i1_entropy_coding_sync_enabled_flag && end_of_tile_row)))\n {\n                WORD32 end_of_sub_stream_one_bit;\n                end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);\n                AEV_TRACE(\"end_of_sub_stream_one_bit\", end_of_sub_stream_one_bit, ps_codec->s_parse.s_cabac.u4_range);\n\n \/* TODO: Remove the check for offset when HM is updated to include a byte unconditionally even for aligned location *\/\n \/* For Ittiam streams this check should not be there, for HM9.1 streams this should be there *\/\n if(ps_codec->s_parse.s_bitstrm.u4_bit_ofst % 8)\n                    ihevcd_bits_flush_to_byte_boundary(&ps_codec->s_parse.s_bitstrm);\n\n                UNUSED(end_of_sub_stream_one_bit);\n }\n }\n {\n            WORD32 ctb_indx;\n\n            ctb_addr = ps_codec->s_parse.i4_ctb_y * num_ctb_in_row + ps_codec->s_parse.i4_ctb_x;\n\n            ctb_indx = ++ctb_addr;\n\n \/* Store pu_idx for next CTB in frame level pu_idx array *\/\n\n if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))\n {\n                ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; \/\/idx is the beginning of next row in current tile.\n if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))\n {\n if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))\n {\n                        ctb_indx = ctb_addr; \/\/Next continuous ctb address\n }\n else \/\/Not last tile's end , but a tile end\n {\n tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;\n                        ctb_indx = ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); \/\/idx is the beginning of first row in next tile.\n }\n }\n }\n\n            ps_codec->s_parse.pu4_pic_pu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_pu_idx;\n            ps_codec->s_parse.i4_next_pu_ctb_cnt = ctb_indx;\n\n            ps_codec->s_parse.pu1_pu_map += num_min4x4_in_ctb;\n\n \/* Store tu_idx for next CTB in frame level tu_idx array *\/\n if(1 == ps_codec->i4_num_cores)\n {\n                ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?\n                                RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;\n\n if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))\n {\n                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; \/\/idx is the beginning of next row in current tile.\n if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))\n {\n if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))\n {\n                            ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?\n                                            RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;\n }\n else \/\/Not last tile's end , but a tile end\n {\n tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;\n                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); \/\/idx is the beginning of first row in next tile.\n }\n }\n }\n                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;\n                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;\n }\n else\n {\n                ctb_indx = ctb_addr;\n if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))\n {\n                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; \/\/idx is the beginning of next row in current tile.\n if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))\n {\n if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))\n {\n                            ctb_indx = ctb_addr;\n }\n else \/\/Not last tile's end , but a tile end\n {\n tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;\n                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); \/\/idx is the beginning of first row in next tile.\n }\n }\n }\n                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;\n                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;\n }\n            ps_codec->s_parse.pu1_tu_map += num_min4x4_in_ctb;\n }\n\n\n if(ps_codec->i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD)\n {\n \/*************************************************\/\n \/****************   MV pred **********************\/\n \/*************************************************\/\n            WORD8 u1_top_ctb_avail = 1;\n            WORD8 u1_left_ctb_avail = 1;\n            WORD8 u1_top_lt_ctb_avail = 1;\n            WORD8 u1_top_rt_ctb_avail = 1;\n            WORD16 i2_wd_in_ctb;\n\n            tile_start_ctb_idx = ps_tile->u1_pos_x\n + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);\n\n            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x\n + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n if((slice_start_ctb_idx < tile_start_ctb_idx))\n {\n                i2_wd_in_ctb = ps_sps->i2_pic_wd_in_ctb;\n }\n else\n {\n                i2_wd_in_ctb = ps_tile->u2_wd;\n }\n \/* slice and tile boundaries *\/\n if((0 == ps_codec->s_parse.i4_ctb_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                u1_top_ctb_avail = 0;\n                u1_top_lt_ctb_avail = 0;\n                u1_top_rt_ctb_avail = 0;\n }\n\n if((0 == ps_codec->s_parse.i4_ctb_x) || (0 == ps_codec->s_parse.i4_ctb_tile_x))\n {\n                u1_left_ctb_avail = 0;\n                u1_top_lt_ctb_avail = 0;\n if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                    u1_top_ctb_avail = 0;\n if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x) \/\/TODO: For tile, not implemented\n {\n                        u1_top_rt_ctb_avail = 0;\n }\n }\n }\n \/*For slices not beginning at start of a ctb row*\/\n else if(ps_codec->s_parse.i4_ctb_x > 0)\n {\n if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                    u1_top_ctb_avail = 0;\n                    u1_top_lt_ctb_avail = 0;\n if(0 == ps_codec->s_parse.i4_ctb_slice_x)\n {\n                        u1_left_ctb_avail = 0;\n }\n if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x)\n {\n                        u1_top_rt_ctb_avail = 0;\n }\n }\n else if((1 == ps_codec->s_parse.i4_ctb_slice_y) && (0 == ps_codec->s_parse.i4_ctb_slice_x))\n {\n                    u1_top_lt_ctb_avail = 0;\n }\n }\n\n if(((ps_sps->i2_pic_wd_in_ctb - 1) == ps_codec->s_parse.i4_ctb_x) || ((ps_tile->u2_wd - 1) == ps_codec->s_parse.i4_ctb_tile_x))\n {\n                u1_top_rt_ctb_avail = 0;\n }\n\n if(PSLICE == ps_slice_hdr->i1_slice_type\n || BSLICE == ps_slice_hdr->i1_slice_type)\n {\n mv_ctxt_t s_mv_ctxt;\n process_ctxt_t *ps_proc;\n                UWORD32 *pu4_ctb_top_pu_idx;\n                UWORD32 *pu4_ctb_left_pu_idx;\n                UWORD32 *pu4_ctb_top_left_pu_idx;\n                WORD32 i4_ctb_pu_cnt;\n                WORD32 cur_ctb_idx;\n                WORD32 next_ctb_idx;\n                WORD32 cur_pu_idx;\n                ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];\n                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;\n                i4_ctb_pu_cnt = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]\n - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n\n                cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n\n                pu4_ctb_top_pu_idx = ps_proc->pu4_pic_pu_idx_top\n + (ps_codec->s_parse.i4_ctb_x * ctb_size \/ MIN_PU_SIZE);\n                pu4_ctb_left_pu_idx = ps_proc->pu4_pic_pu_idx_left;\n                pu4_ctb_top_left_pu_idx = &ps_proc->u4_ctb_top_left_pu_idx;\n\n \/* Initializing s_mv_ctxt *\/\n {\n                    s_mv_ctxt.ps_pps = ps_pps;\n                    s_mv_ctxt.ps_sps = ps_sps;\n                    s_mv_ctxt.ps_slice_hdr = ps_slice_hdr;\n                    s_mv_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;\n                    s_mv_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;\n                    s_mv_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];\n                    s_mv_ctxt.ps_pic_pu = ps_codec->s_parse.ps_pic_pu;\n                    s_mv_ctxt.ps_tile = ps_tile;\n                    s_mv_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;\n                    s_mv_ctxt.pu4_pic_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx;\n                    s_mv_ctxt.pu1_pic_pu_map = ps_codec->s_parse.pu1_pic_pu_map;\n                    s_mv_ctxt.i4_ctb_pu_cnt = i4_ctb_pu_cnt;\n                    s_mv_ctxt.i4_ctb_start_pu_idx = cur_pu_idx;\n                    s_mv_ctxt.u1_top_ctb_avail = u1_top_ctb_avail;\n                    s_mv_ctxt.u1_top_rt_ctb_avail = u1_top_rt_ctb_avail;\n                    s_mv_ctxt.u1_top_lt_ctb_avail = u1_top_lt_ctb_avail;\n                    s_mv_ctxt.u1_left_ctb_avail = u1_left_ctb_avail;\n }\n\n                ihevcd_get_mv_ctb(&s_mv_ctxt, pu4_ctb_top_pu_idx,\n                                  pu4_ctb_left_pu_idx, pu4_ctb_top_left_pu_idx);\n\n }\n else\n {\n                WORD32 num_minpu_in_ctb = (ctb_size \/ MIN_PU_SIZE) * (ctb_size \/ MIN_PU_SIZE);\n                UWORD8 *pu1_pic_pu_map_ctb = ps_codec->s_parse.pu1_pic_pu_map +\n (ps_codec->s_parse.i4_ctb_x + ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb) * num_minpu_in_ctb;\n process_ctxt_t *ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];\n                WORD32 row, col;\n                WORD32 pu_cnt;\n                WORD32 num_pu_per_ctb;\n                WORD32 cur_ctb_idx;\n                WORD32 next_ctb_idx;\n                WORD32 ctb_start_pu_idx;\n                UWORD32 *pu4_nbr_pu_idx = ps_proc->pu4_pic_pu_idx_map;\n                WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE \/ MIN_PU_SIZE + 2;\n pu_t *ps_pu;\n\n for(row = 0; row < ctb_size \/ MIN_PU_SIZE; row++)\n {\n for(col = 0; col < ctb_size \/ MIN_PU_SIZE; col++)\n {\n                        pu1_pic_pu_map_ctb[row * ctb_size \/ MIN_PU_SIZE + col] = 0;\n }\n }\n\n\n \/* Neighbor PU idx update inside CTB *\/\n \/* 1byte per 4x4. Indicates the PU idx that 4x4 block belongs to *\/\n\n                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;\n                num_pu_per_ctb = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]\n - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n                ctb_start_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n                ps_pu = &ps_codec->s_parse.ps_pic_pu[ctb_start_pu_idx];\n\n for(pu_cnt = 0; pu_cnt < num_pu_per_ctb; pu_cnt++, ps_pu++)\n {\n                    UWORD32 cur_pu_idx;\n                    WORD32 pu_ht = (ps_pu->b4_ht + 1) << 2;\n                    WORD32 pu_wd = (ps_pu->b4_wd + 1) << 2;\n\n                    cur_pu_idx = ctb_start_pu_idx + pu_cnt;\n\n for(row = 0; row < pu_ht \/ MIN_PU_SIZE; row++)\n for(col = 0; col < pu_wd \/ MIN_PU_SIZE; col++)\n                            pu4_nbr_pu_idx[(1 + ps_pu->b4_pos_x + col)\n + (1 + ps_pu->b4_pos_y + row)\n * nbr_pu_idx_strd] =\n                                            cur_pu_idx;\n }\n\n \/* Updating Top and Left pointers *\/\n {\n                    WORD32 rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n                    WORD32 ctb_size_left = MIN(ctb_size, rows_remaining);\n\n \/* Top Left *\/\n \/* saving top left before updating top ptr, as updating top ptr will overwrite the top left for the next ctb *\/\n                    ps_proc->u4_ctb_top_left_pu_idx = ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size \/ MIN_PU_SIZE) + ctb_size \/ MIN_PU_SIZE - 1];\n for(i = 0; i < ctb_size \/ MIN_PU_SIZE; i++)\n {\n \/* Left *\/\n \/* Last column of au4_nbr_pu_idx *\/\n                        ps_proc->pu4_pic_pu_idx_left[i] = pu4_nbr_pu_idx[(ctb_size \/ MIN_PU_SIZE)\n + (i + 1) * nbr_pu_idx_strd];\n \/* Top *\/\n \/* Last row of au4_nbr_pu_idx *\/\n                        ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size \/ MIN_PU_SIZE) + i] =\n                                        pu4_nbr_pu_idx[(ctb_size_left \/ MIN_PU_SIZE) * nbr_pu_idx_strd + i + 1];\n\n }\n }\n }\n\n \/*************************************************\/\n \/******************  BS, QP  *********************\/\n \/*************************************************\/\n \/* Check if deblock is disabled for the current slice or if it is disabled for the current picture\n             * because of disable deblock api\n             *\/\n if(0 == ps_codec->i4_disable_deblk_pic)\n {\n if((0 == ps_slice_hdr->i1_slice_disable_deblocking_filter_flag) &&\n (0 == ps_codec->i4_slice_error))\n {\n                    WORD32 i4_ctb_tu_cnt;\n                    WORD32 cur_ctb_idx, next_ctb_idx;\n                    WORD32 cur_pu_idx;\n                    WORD32 cur_tu_idx;\n process_ctxt_t *ps_proc;\n\n                    ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];\n                    cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n                    cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n                    next_ctb_idx = ps_codec->s_parse.i4_next_tu_ctb_cnt;\n if(1 == ps_codec->i4_num_cores)\n {\n                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -\n                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];\n\n                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];\n }\n else\n {\n                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -\n                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];\n\n                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];\n }\n\n                    ps_codec->s_parse.s_bs_ctxt.ps_pps = ps_codec->s_parse.ps_pps;\n                    ps_codec->s_parse.s_bs_ctxt.ps_sps = ps_codec->s_parse.ps_sps;\n                    ps_codec->s_parse.s_bs_ctxt.ps_codec = ps_codec;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tu_cnt = i4_ctb_tu_cnt;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_x = ps_codec->s_parse.i4_ctb_tile_x;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_y = ps_codec->s_parse.i4_ctb_tile_y;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_x = ps_codec->s_parse.i4_ctb_slice_x;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_y = ps_codec->s_parse.i4_ctb_slice_y;\n                    ps_codec->s_parse.s_bs_ctxt.ps_tu = &ps_codec->s_parse.ps_pic_tu[cur_tu_idx];\n                    ps_codec->s_parse.s_bs_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];\n                    ps_codec->s_parse.s_bs_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;\n                    ps_codec->s_parse.s_bs_ctxt.i4_next_pu_ctb_cnt = ps_codec->s_parse.i4_next_pu_ctb_cnt;\n                    ps_codec->s_parse.s_bs_ctxt.i4_next_tu_ctb_cnt = ps_codec->s_parse.i4_next_tu_ctb_cnt;\n                    ps_codec->s_parse.s_bs_ctxt.pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;\n                    ps_codec->s_parse.s_bs_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;\n                    ps_codec->s_parse.s_bs_ctxt.ps_tile = ps_codec->s_parse.ps_tile;\n\n if(ISLICE == ps_slice_hdr->i1_slice_type)\n {\n                        ihevcd_ctb_boundary_strength_islice(&ps_codec->s_parse.s_bs_ctxt);\n }\n else\n {\n                        ihevcd_ctb_boundary_strength_pbslice(&ps_codec->s_parse.s_bs_ctxt);\n }\n }\n else\n {\n                    WORD32 bs_strd = (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size \/ 8 \/ 16);\n\n                    UWORD32 *pu4_vert_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_vert_bs +\n                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size \/ 8 \/ 16) +\n                                    ps_codec->s_parse.i4_ctb_y * bs_strd);\n                    UWORD32 *pu4_horz_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_horz_bs +\n                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size \/ 8 \/ 16) +\n                                    ps_codec->s_parse.i4_ctb_y * bs_strd);\n\n                    memset(pu4_vert_bs, 0, (ctb_size \/ 8 + 1) * (ctb_size \/ 4) \/ 8 * 2);\n                    memset(pu4_horz_bs, 0, (ctb_size \/ 8) * (ctb_size \/ 4) \/ 8 * 2);\n\n }\n }\n\n }\n\n\n \/* Update the parse status map *\/\n {\n sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n            UWORD8 *pu1_buf;\n            WORD32 idx;\n            idx = (ps_codec->s_parse.i4_ctb_x);\n            idx += ((ps_codec->s_parse.i4_ctb_y) * ps_sps->i2_pic_wd_in_ctb);\n            pu1_buf = (ps_codec->pu1_parse_map + idx);\n *pu1_buf = 1;\n }\n\n \/* Increment CTB x and y positions *\/\n        ps_codec->s_parse.i4_ctb_tile_x++;\n        ps_codec->s_parse.i4_ctb_x++;\n        ps_codec->s_parse.i4_ctb_slice_x++;\n\n \/*If tiles are enabled, handle the slice counters differently*\/\n if(ps_pps->i1_tiles_enabled_flag)\n {\n            tile_start_ctb_idx = ps_tile->u1_pos_x\n + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);\n\n            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x\n + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n if((slice_start_ctb_idx < tile_start_ctb_idx))\n {\n if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u1_pos_x + ps_tile->u2_wd))\n {\n \/* Reached end of slice row within a tile \/frame *\/\n                    ps_codec->s_parse.i4_ctb_slice_y++;\n                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x; \/\/todo:Check\n }\n }\n else if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u2_wd))\n {\n                ps_codec->s_parse.i4_ctb_slice_y++;\n                ps_codec->s_parse.i4_ctb_slice_x = 0;\n }\n }\n else\n {\n if(ps_codec->s_parse.i4_ctb_slice_x == ps_tile->u2_wd)\n {\n \/* Reached end of slice row within a tile \/frame *\/\n                ps_codec->s_parse.i4_ctb_slice_y++;\n                ps_codec->s_parse.i4_ctb_slice_x = 0;\n }\n }\n\n\n if(ps_codec->s_parse.i4_ctb_tile_x == (ps_tile->u2_wd))\n {\n \/* Reached end of tile row *\/\n            ps_codec->s_parse.i4_ctb_tile_x = 0;\n            ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;\n\n            ps_codec->s_parse.i4_ctb_tile_y++;\n            ps_codec->s_parse.i4_ctb_y++;\n\n if(ps_codec->s_parse.i4_ctb_tile_y == (ps_tile->u2_ht))\n {\n \/* Reached End of Tile *\/\n                ps_codec->s_parse.i4_ctb_tile_y = 0;\n                ps_codec->s_parse.i4_ctb_tile_x = 0;\n                ps_codec->s_parse.ps_tile++;\n\n if((ps_tile->u2_ht + ps_tile->u1_pos_y  ==  ps_sps->i2_pic_ht_in_ctb) && (ps_tile->u2_wd + ps_tile->u1_pos_x  ==  ps_sps->i2_pic_wd_in_ctb))\n {\n \/* Reached end of frame *\/\n                    end_of_pic = 1;\n                    ps_codec->s_parse.i4_ctb_x = 0;\n                    ps_codec->s_parse.i4_ctb_y = ps_sps->i2_pic_ht_in_ctb;\n }\n else\n {\n \/* Initialize ctb_x and ctb_y to start of next tile *\/\n                    ps_tile = ps_codec->s_parse.ps_tile;\n                    ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;\n                    ps_codec->s_parse.i4_ctb_y = ps_tile->u1_pos_y;\n                    ps_codec->s_parse.i4_ctb_tile_y = 0;\n                    ps_codec->s_parse.i4_ctb_tile_x = 0;\n                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x;\n                    ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y;\n\n }\n }\n\n }\n\n        ps_codec->s_parse.i4_next_ctb_indx = ps_codec->s_parse.i4_ctb_x +\n                        ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;\n\n \/* If the current slice is in error, check if the next slice's address\n         * is reached and mark the end_of_slice flag *\/\n if(ps_codec->i4_slice_error)\n {\n slice_header_t *ps_slice_hdr_next = ps_slice_hdr + 1;\n            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +\n                            ps_slice_hdr_next->i2_ctb_y * ps_sps->i2_pic_wd_in_ctb;\n\n if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)\n                end_of_slice_flag = 1;\n }\n\n \/* If the codec is running in single core mode\n         * then call process function for current CTB\n         *\/\n if((1 == ps_codec->i4_num_cores) && (ps_codec->s_parse.i4_ctb_tile_x == 0))\n {\n process_ctxt_t *ps_proc = &ps_codec->as_process[0];\n            ps_proc->i4_ctb_cnt = ps_proc->ps_tile->u2_wd;\n            ihevcd_process(ps_proc);\n }\n\n \/* If the bytes for the current slice are exhausted\n         * set end_of_slice flag to 1\n         * This slice will be treated as incomplete *\/\n if((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu1_buf_max + BITSTRM_OFF_THRS <\n ((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu4_buf + (ps_codec->s_parse.s_bitstrm.u4_bit_ofst \/ 8)))\n {\n\n if(0 == ps_codec->i4_slice_error)\n                end_of_slice_flag = 1;\n }\n\n\n if(end_of_pic)\n break;\n } while(!end_of_slice_flag);\n\n \/* Reset slice error *\/\n    ps_codec->i4_slice_error = 0;\n\n \/* Increment the slice index for parsing next slice *\/\n if(0 == end_of_pic)\n {\n while(1)\n {\n\n            WORD32 parse_slice_idx;\n            parse_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;\n            parse_slice_idx++;\n\n {\n \/* If the next slice header is not initialized, update cur_slice_idx and break *\/\n if((1 == ps_codec->i4_num_cores) || (0 != (parse_slice_idx & (MAX_SLICE_HDR_CNT - 1))))\n {\n                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;\n break;\n }\n\n \/* If the next slice header is initialised, wait for the parsed slices to be processed *\/\n else\n {\n                    WORD32 ctb_indx = 0;\n\n while(ctb_indx != ps_sps->i4_pic_size_in_ctb)\n {\n                        WORD32 parse_status = *(ps_codec->pu1_parse_map + ctb_indx);\n volatile WORD32 proc_status = *(ps_codec->pu1_proc_map + ctb_indx) & 1;\n\n if(parse_status == proc_status)\n                            ctb_indx++;\n }\n                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;\n break;\n }\n\n }\n }\n\n }\n else\n {\n#if FRAME_ILF_PAD\n if(FRAME_ILF_PAD && 1 == ps_codec->i4_num_cores)\n {\n if(ps_slice_hdr->i4_abs_pic_order_cnt == 0)\n {\n                DUMP_PRE_ILF(ps_codec->as_process[0].pu1_cur_pic_luma,\n                             ps_codec->as_process[0].pu1_cur_pic_chroma,\n                             ps_sps->i2_pic_width_in_luma_samples,\n                             ps_sps->i2_pic_height_in_luma_samples,\n                             ps_codec->i4_strd);\n\n                DUMP_BS(ps_codec->as_process[0].s_bs_ctxt.pu4_pic_vert_bs,\n                        ps_codec->as_process[0].s_bs_ctxt.pu4_pic_horz_bs,\n                        ps_sps->i2_pic_wd_in_ctb * (ctb_size * ctb_size \/ 8 \/ 16) * ps_sps->i2_pic_ht_in_ctb,\n (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size \/ 8 \/ 16) * ps_sps->i2_pic_ht_in_ctb);\n\n                DUMP_QP(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp,\n (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) \/ (MIN_CU_SIZE * MIN_CU_SIZE));\n\n                DUMP_QP_CONST_IN_CTB(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp_const_in_ctb,\n (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) \/ (MIN_CTB_SIZE * MIN_CTB_SIZE) \/ 8);\n\n                DUMP_NO_LOOP_FILTER(ps_codec->as_process[0].pu1_pic_no_loop_filter_flag,\n (ps_sps->i2_pic_width_in_luma_samples \/ MIN_CU_SIZE) * (ps_sps->i2_pic_height_in_luma_samples \/ MIN_CU_SIZE) \/ 8);\n\n                DUMP_OFFSETS(ps_slice_hdr->i1_beta_offset_div2,\n                             ps_slice_hdr->i1_tc_offset_div2,\n                             ps_pps->i1_pic_cb_qp_offset,\n                             ps_pps->i1_pic_cr_qp_offset);\n }\n            ps_codec->s_parse.s_deblk_ctxt.ps_pps = ps_codec->s_parse.ps_pps;\n            ps_codec->s_parse.s_deblk_ctxt.ps_sps = ps_codec->s_parse.ps_sps;\n            ps_codec->s_parse.s_deblk_ctxt.ps_codec = ps_codec;\n            ps_codec->s_parse.s_deblk_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;\n            ps_codec->s_parse.s_deblk_ctxt.is_chroma_yuv420sp_vu = (ps_codec->e_ref_chroma_fmt == IV_YUV_420SP_VU);\n\n            ps_codec->s_parse.s_sao_ctxt.ps_pps = ps_codec->s_parse.ps_pps;\n            ps_codec->s_parse.s_sao_ctxt.ps_sps = ps_codec->s_parse.ps_sps;\n            ps_codec->s_parse.s_sao_ctxt.ps_codec = ps_codec;\n            ps_codec->s_parse.s_sao_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;\n\n            ihevcd_ilf_pad_frame(&ps_codec->s_parse.s_deblk_ctxt, &ps_codec->s_parse.s_sao_ctxt);\n\n }\n#endif\n        ps_codec->s_parse.i4_end_of_frame = 1;\n }\n return ret;\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"static int phar_dir_seek(php_stream *stream, off_t offset, int whence, off_t *newoffset TSRMLS_DC) \/* {{{ *\/\n{\n\tHashTable *data = (HashTable *)stream->abstract;\n\n\tif (!data) {\n\t\treturn -1;\n\t}\n\n\tif (whence == SEEK_END) {\n\t\twhence = SEEK_SET;\n\t\toffset = zend_hash_num_elements(data) + offset;\n\t}\n\n\tif (whence == SEEK_SET) {\n\t\tzend_hash_internal_pointer_reset(data);\n\t}\n\n\tif (offset < 0) {\n\t\treturn -1;\n\t} else {\n\t\t*newoffset = 0;\n\t\twhile (*newoffset < offset && zend_hash_move_forward(data) == SUCCESS) {\n\t\t\t++(*newoffset);\n\t\t}\n\t\treturn 0;\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void SetUp() {\n    vp9_worker_init(&worker_);\n   }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_subtractive(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->type == FZ_COLORSPACE_CMYK || cs->type == FZ_COLORSPACE_SEPARATION);\n}\n","project":"ghostscript","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"PHPAPI void  php_pcre_grep_impl(pcre_cache_entry *pce, zval *input, zval *return_value, long flags TSRMLS_DC) \/* {{{ *\/\n{\n\tzval\t\t   **entry;\t\t\t\t\/* An entry in the input array *\/\n\tpcre_extra\t\t*extra = pce->extra;\/* Holds results of studying *\/\n\tpcre_extra\t\t extra_data;\t\t\/* Used locally for exec options *\/\n\tint\t\t\t\t*offsets;\t\t\t\/* Array of subpattern offsets *\/\n\tint\t\t\t\t size_offsets;\t\t\/* Size of the offsets array *\/\n\tint\t\t\t\t count = 0;\t\t\t\/* Count of matched subpatterns *\/\n\tchar\t\t\t*string_key;\n\tulong\t\t\t num_key;\n\tzend_bool\t\t invert;\t\t\t\/* Whether to return non-matching\n\t\t\t\t\t\t\t\t\t\t   entries *\/\n\tint\t\t\t\t rc;\n\t\n\tinvert = flags & PREG_GREP_INVERT ? 1 : 0;\n\t\n\tif (extra == NULL) {\n\t\textra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;\n\t\textra = &extra_data;\n\t}\n\textra->match_limit = PCRE_G(backtrack_limit);\n\textra->match_limit_recursion = PCRE_G(recursion_limit);\n\n\t\/* Calculate the size of the offsets array, and allocate memory for it. *\/\n\trc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &size_offsets);\n\tif (rc < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Internal pcre_fullinfo() error %d\", rc);\n\t\tRETURN_FALSE;\n\t}\n\tsize_offsets = (size_offsets + 1) * 3;\n\toffsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);\n\t\n\t\/* Initialize return array *\/\n\tarray_init(return_value);\n\n\tPCRE_G(error_code) = PHP_PCRE_NO_ERROR;\n\n\t\/* Go through the input array *\/\n\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(input));\n\twhile (zend_hash_get_current_data(Z_ARRVAL_P(input), (void **)&entry) == SUCCESS) {\n\t\tzval subject = **entry;\n\n\t\tif (Z_TYPE_PP(entry) != IS_STRING) {\n\t\t\tzval_copy_ctor(&subject);\n\t\t\tconvert_to_string(&subject);\n\t\t}\n\n\t\t\/* Perform the match *\/\n\t\tcount = pcre_exec(pce->re, extra, Z_STRVAL(subject),\n\t\t\t\t\t\t  Z_STRLEN(subject), 0,\n\t\t\t\t\t\t  0, offsets, size_offsets);\n\n\t\t\/* Check for too many substrings condition. *\/\n\t\tif (count == 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Matched, but too many substrings\");\n\t\t\tcount = size_offsets\/3;\n\t\t} else if (count < 0 && count != PCRE_ERROR_NOMATCH) {\n\t\t\tpcre_handle_exec_error(count TSRMLS_CC);\n\t\t\tbreak;\n\t\t}\n\n\t\t\/* If the entry fits our requirements *\/\n\t\tif ((count > 0 && !invert) || (count == PCRE_ERROR_NOMATCH && invert)) {\n\n\t\t\tZ_ADDREF_PP(entry);\n\n\t\t\t\/* Add to return array *\/\n\t\t\tswitch (zend_hash_get_current_key(Z_ARRVAL_P(input), &string_key, &num_key, 0))\n\t\t\t{\n\t\t\t\tcase HASH_KEY_IS_STRING:\n\t\t\t\t\tzend_hash_update(Z_ARRVAL_P(return_value), string_key,\n\t\t\t\t\t\t\t\t\t strlen(string_key)+1, entry, sizeof(zval *), NULL);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HASH_KEY_IS_LONG:\n\t\t\t\t\tzend_hash_index_update(Z_ARRVAL_P(return_value), num_key, entry,\n\t\t\t\t\t\t\t\t\t\t   sizeof(zval *), NULL);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (Z_TYPE_PP(entry) != IS_STRING) {\n\t\t\tzval_dtor(&subject);\n\t\t}\n\n\t\tzend_hash_move_forward(Z_ARRVAL_P(input));\n\t}\n\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(input));\n\t\/* Clean up *\/\n\tefree(offsets);\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Chapters::Atom::Parse(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    const long long stop = pos + size;\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  \/\/ error\n            return status;\n        if (size == 0)  \/\/ weird\n            continue;\n        if (id == 0x00)  \/\/ Display ID\n        {\n            status = ParseDisplay(pReader, pos, size);\n            if (status < 0)  \/\/ error\n                return status;\n        }\n        else if (id == 0x1654)  \/\/ StringUID ID\n        {\n            status = UnserializeString(pReader, pos, size, m_string_uid);\n            if (status < 0)  \/\/ error\n                return status;\n        }\n        else if (id == 0x33C4)  \/\/ UID ID\n        {\n            long long val;\n            status = UnserializeInt(pReader, pos, size, val);\n            if (status < 0)  \/\/ error\n                return status;\n            m_uid = val;\n        }\n        else if (id == 0x11)  \/\/ TimeStart ID\n        {\n            const long long val = UnserializeUInt(pReader, pos, size);\n            if (val < 0)  \/\/ error\n                return static_cast<long>(val);\n            m_start_timecode = val;\n        }\n        else if (id == 0x12)  \/\/ TimeEnd ID\n        {\n            const long long val = UnserializeUInt(pReader, pos, size);\n            if (val < 0)  \/\/ error\n                return static_cast<long>(val);\n            m_stop_timecode = val;\n        }\n        pos += size;\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    return 0;\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static void php_free_pcre_cache(void *data) \/* {{{ *\/\n{\n\tpcre_cache_entry *pce = (pcre_cache_entry *) data;\n\tif (!pce) return;\n\tpefree(pce->re, 1);\n\tif (pce->extra) pefree(pce->extra, 1);\n#if HAVE_SETLOCALE\n\tif ((void*)pce->tables) pefree((void*)pce->tables, 1);\n\tpefree(pce->locale, 1);\n#endif\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"d2f47191538837e796e2b10c1ff7e1ee35f6e0ab","func":" void SoftAVC::drainAllOutputBuffers(bool eos) {\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n    H264SwDecPicture decodedPicture;\n\n if (mHeadersDecoded) {\n while (!outQueue.empty()\n && H264SWDEC_PIC_RDY == H264SwDecNextPicture(\n\n                     mHandle, &decodedPicture, eos \/* flush *\/)) {\n             int32_t picId = decodedPicture.picId;\n             uint8_t *data = (uint8_t *) decodedPicture.pOutputPicture;\n            drainOneOutputBuffer(picId, data);\n         }\n     }\n \n if (!eos) {\n return;\n }\n\n while (!outQueue.empty()) {\n BufferInfo *outInfo = *outQueue.begin();\n        outQueue.erase(outQueue.begin());\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n        outHeader->nTimeStamp = 0;\n        outHeader->nFilledLen = 0;\n        outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n        outInfo->mOwnedByUs = false;\n        notifyFillBufferDone(outHeader);\n\n        mEOSStatus = OUTPUT_FRAMES_FLUSHED;\n }\n}\n","project":"Android","target":1},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"static timelib_sll timelib_get_nr(char **ptr, int max_length)\n{\n\tchar *begin, *end, *str;\n\ttimelib_sll tmp_nr = TIMELIB_UNSET;\n\tint len = 0;\n\n\twhile ((**ptr < '0') || (**ptr > '9')) {\n\t\tif (**ptr == '\\0') {\n\t\t\treturn TIMELIB_UNSET;\n\t\t}\n\t\t++*ptr;\n\t}\n\tbegin = *ptr;\n\twhile ((**ptr >= '0') && (**ptr <= '9') && len < max_length) {\n\t\t++*ptr;\n\t\t++len;\n\t}\n\tend = *ptr;\n\tstr = calloc(1, end - begin + 1);\n\tmemcpy(str, begin, end - begin);\n\ttmp_nr = strtoll(str, NULL, 10);\n\tfree(str);\n\treturn tmp_nr;\n}\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"attr_show_all (struct vty *vty)\n{\n  hash_iterate (attrhash, \n\t\t(void (*)(struct hash_backet *, void *))\n\t\tattr_show_all_iterator,\n\t\tvty);\n}\n","project":"savannah","target":0},{"commit_id":"24d7c408c52143bce7b49de82f3913fd8d1219cf","func":"EAS_BOOL WT_CheckSampleEnd (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame, EAS_BOOL update)\n{\n    EAS_U32 endPhaseAccum;\n    EAS_U32 endPhaseFrac;\n    EAS_I32 numSamples;\n    EAS_BOOL done = EAS_FALSE;\n\n \/* check to see if we hit the end of the waveform this time *\/\n \/*lint -e{703} use shift for performance *\/\n    endPhaseFrac = pWTVoice->phaseFrac + (pWTIntFrame->frame.phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS);\n    endPhaseAccum = pWTVoice->phaseAccum + GET_PHASE_INT_PART(endPhaseFrac);\n if (endPhaseAccum >= pWTVoice->loopEnd)\n {\n \/* calculate how far current ptr is from end *\/\n        numSamples = (EAS_I32) (pWTVoice->loopEnd - pWTVoice->phaseAccum);\n\n \/* now account for the fractional portion *\/\n \/*lint -e{703} use shift for performance *\/\n        numSamples = (EAS_I32) ((numSamples << NUM_PHASE_FRAC_BITS) - pWTVoice->phaseFrac);\n if (pWTIntFrame->frame.phaseIncrement) {\n            pWTIntFrame->numSamples = 1 + (numSamples \/ pWTIntFrame->frame.phaseIncrement);\n } else {\n            pWTIntFrame->numSamples = numSamples;\n\n         }\n         if (pWTIntFrame->numSamples < 0) {\n             ALOGE(\"b\/26366256\");\n             pWTIntFrame->numSamples = 0;\n         }\n \n \/* sound will be done this frame *\/\n        done = EAS_TRUE;\n }\n\n \/* update data for off-chip synth *\/\n if (update)\n {\n        pWTVoice->phaseFrac = endPhaseFrac;\n        pWTVoice->phaseAccum = endPhaseAccum;\n }\n\n return done;\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftVideoDecoderOMXComponent::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamVideoPortFormat:\n {\n\n             OMX_VIDEO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_VIDEO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > kMaxPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n if (formatParams->nIndex != 0) {\n return OMX_ErrorNoMore;\n }\n\n if (formatParams->nPortIndex == kInputPortIndex) {\n                formatParams->eCompressionFormat = mCodingType;\n                formatParams->eColorFormat = OMX_COLOR_FormatUnused;\n                formatParams->xFramerate = 0;\n } else {\n                CHECK_EQ(formatParams->nPortIndex, 1u);\n\n                formatParams->eCompressionFormat = OMX_VIDEO_CodingUnused;\n                formatParams->eColorFormat = OMX_COLOR_FormatYUV420Planar;\n                formatParams->xFramerate = 0;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoProfileLevelQuerySupported:\n {\n\n             OMX_VIDEO_PARAM_PROFILELEVELTYPE *profileLevel =\n                   (OMX_VIDEO_PARAM_PROFILELEVELTYPE *) params;\n \n             if (profileLevel->nPortIndex != kInputPortIndex) {\n                 ALOGE(\"Invalid port index: %\" PRIu32, profileLevel->nPortIndex);\n                 return OMX_ErrorUnsupportedIndex;\n }\n\n if (profileLevel->nProfileIndex >= mNumProfileLevels) {\n return OMX_ErrorNoMore;\n }\n\n            profileLevel->eProfile = mProfileLevels[profileLevel->nProfileIndex].mProfile;\n            profileLevel->eLevel   = mProfileLevels[profileLevel->nProfileIndex].mLevel;\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_cmm_transform_color(fz_context *ctx, fz_icclink *link, unsigned short *dst, const unsigned short *src)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->transform_color(ctx->cmm_instance, link, dst, src);\n}\n","project":"ghostscript","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"php_stream *phar_get_efp(phar_entry_info *entry, int follow_links TSRMLS_DC) \/* {{{ *\/\n{\n\tif (follow_links && entry->link) {\n\t\tphar_entry_info *link_entry = phar_get_link_source(entry TSRMLS_CC);\n\n\t\tif (link_entry && link_entry != entry) {\n\t\t\treturn phar_get_efp(link_entry, 1 TSRMLS_CC);\n\t\t}\n\t}\n\n\tif (phar_get_fp_type(entry TSRMLS_CC) == PHAR_FP) {\n\t\tif (!phar_get_entrypfp(entry TSRMLS_CC)) {\n\t\t\t\/* re-open just in time for cases where our refcount reached 0 on the phar archive *\/\n\t\t\tphar_open_archive_fp(entry->phar TSRMLS_CC);\n\t\t}\n\t\treturn phar_get_entrypfp(entry TSRMLS_CC);\n\t} else if (phar_get_fp_type(entry TSRMLS_CC) == PHAR_UFP) {\n\t\treturn phar_get_entrypufp(entry TSRMLS_CC);\n\t} else if (entry->fp_type == PHAR_MOD) {\n\t\treturn entry->fp;\n\t} else {\n\t\t\/* temporary manifest entry *\/\n\t\tif (!entry->fp) {\n\t\t\tentry->fp = php_stream_open_wrapper(entry->tmp, \"rb\", STREAM_MUST_SEEK|0, NULL);\n\t\t}\n\t\treturn entry->fp;\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_csr_export)\n{\n\tX509_REQ * csr;\n\tzval * zcsr = NULL, *zout=NULL;\n\tzend_bool notext = 1;\n\tBIO * bio_out;\n\n\tlong csr_resource;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rz|b\", &zcsr, &zout, &notext) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tcsr = php_openssl_csr_from_zval(&zcsr, 0, &csr_resource TSRMLS_CC);\n\tif (csr == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get CSR from parameter 1\");\n\t\treturn;\n\t}\n\n\t\/* export to a var *\/\n\n\tbio_out = BIO_new(BIO_s_mem());\n\tif (!notext) {\n\t\tX509_REQ_print(bio_out, csr);\n\t}\n\n\tif (PEM_write_bio_X509_REQ(bio_out, csr)) {\n\t\tBUF_MEM *bio_buf;\n\n\t\tBIO_get_mem_ptr(bio_out, &bio_buf);\n\t\tzval_dtor(zout);\n\t\tZVAL_STRINGL(zout, bio_buf->data, bio_buf->length, 1);\n\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (csr_resource == -1 && csr) {\n\t\tX509_REQ_free(csr);\n\t}\n\tBIO_free(bio_out);\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_indexed_colorspace_palette(fz_context *ctx, fz_colorspace *cs, int *high)\n{\n\tstruct indexed *idx = cs->data;\n\tif (!fz_colorspace_is_indexed(ctx, cs))\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"colorspace not indexed\");\n\t*high = idx->high;\n\treturn idx->lookup;\n}\n","project":"ghostscript","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_rodc_add(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t krbtgt_number, i_start, i;\n\tint ret;\n\tchar *newpass;\n\tstruct ldb_val newpass_utf16;\n\n\t\/* find a unused msDC-SecondaryKrbTgtNumber *\/\n\ti_start = generate_random() & 0xFFFF;\n\tif (i_start == 0) {\n\t\ti_start = 1;\n\t}\n\n\tfor (i=i_start; i<=0xFFFF; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\tfor (i=1; i<i_start; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tldb_asprintf_errstring(ldb,\n\t\t\t       \"%08X: Unable to find available msDS-SecondaryKrbTgtNumber\",\n\t\t\t       W_ERROR_V(WERR_NO_SYSTEM_RESOURCES));\n\treturn LDB_ERR_OTHER;\n\nfound:\n\tret = ldb_msg_add_empty(ac->msg, \"msDS-SecondaryKrbTgtNumber\",\n\t\t\t\tLDB_FLAG_INTERNAL_DISABLE_VALIDATION, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t \"msDS-SecondaryKrbTgtNumber\", krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = ldb_msg_add_fmt(ac->msg, \"sAMAccountName\", \"krbtgt_%u\",\n\t\t\t      krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tnewpass = generate_random_password(ac->msg, 128, 255);\n\tif (newpass == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tif (!convert_string_talloc(ac,\n\t\t\t\t   CH_UNIX, CH_UTF16,\n\t\t\t\t   newpass, strlen(newpass),\n\t\t\t\t   (void *)&newpass_utf16.data,\n\t\t\t\t   &newpass_utf16.length)) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb_rodc_add: \"\n\t\t\t\t       \"failed to generate UTF16 password from random password\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tret = ldb_msg_add_steal_value(ac->msg, \"clearTextPassword\", &newpass_utf16);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n","project":"samba","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_GINIT_FUNCTION(pcre) \/* {{{ *\/\n{\n\tzend_hash_init(&pcre_globals->pcre_cache, 0, NULL, php_free_pcre_cache, 1);\n\tpcre_globals->backtrack_limit = 0;\n\tpcre_globals->recursion_limit = 0;\n\tpcre_globals->error_code      = PHP_PCRE_NO_ERROR;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void cmyk_to_rgb(fz_context *ctx, const fz_colorspace *cs, const float *cmyk, float *rgb)\n{\n#ifdef SLOWCMYK \/* from poppler *\/\n\tfloat c = cmyk[0], m = cmyk[1], y = cmyk[2], k = cmyk[3];\n\tfloat r, g, b, x;\n\tfloat cm = c * m;\n\tfloat c1m = m - cm;\n\tfloat cm1 = c - cm;\n\tfloat c1m1 = 1 - m - cm1;\n\tfloat c1m1y = c1m1 * y;\n\tfloat c1m1y1 = c1m1 - c1m1y;\n\tfloat c1my = c1m * y;\n\tfloat c1my1 = c1m - c1my;\n\tfloat cm1y = cm1 * y;\n\tfloat cm1y1 = cm1 - cm1y;\n\tfloat cmy = cm * y;\n\tfloat cmy1 = cm - cmy;\n\n\t\/* this is a matrix multiplication, unrolled for performance *\/\n\tx = c1m1y1 * k;\t\t\/* 0 0 0 1 *\/\n\tr = g = b = c1m1y1 - x;\t\/* 0 0 0 0 *\/\n\tr += 0.1373f * x;\n\tg += 0.1216f * x;\n\tb += 0.1255f * x;\n\n\tx = c1m1y * k;\t\t\/* 0 0 1 1 *\/\n\tr += 0.1098f * x;\n\tg += 0.1020f * x;\n\tx = c1m1y - x;\t\t\/* 0 0 1 0 *\/\n\tr += x;\n\tg += 0.9490f * x;\n\n\tx = c1my1 * k;\t\t\/* 0 1 0 1 *\/\n\tr += 0.1412f * x;\n\tx = c1my1 - x;\t\t\/* 0 1 0 0 *\/\n\tr += 0.9255f * x;\n\tb += 0.5490f * x;\n\n\tx = c1my * k;\t\t\/* 0 1 1 1 *\/\n\tr += 0.1333f * x;\n\tx = c1my - x;\t\t\/* 0 1 1 0 *\/\n\tr += 0.9294f * x;\n\tg += 0.1098f * x;\n\tb += 0.1412f * x;\n\n\tx = cm1y1 * k;\t\t\/* 1 0 0 1 *\/\n\tg += 0.0588f * x;\n\tb += 0.1412f * x;\n\tx = cm1y1 - x;\t\t\/* 1 0 0 0 *\/\n\tg += 0.6784f * x;\n\tb += 0.9373f * x;\n\n\tx = cm1y * k;\t\t\/* 1 0 1 1 *\/\n\tg += 0.0745f * x;\n\tx = cm1y - x;\t\t\/* 1 0 1 0 *\/\n\tg += 0.6510f * x;\n\tb += 0.3137f * x;\n\n\tx = cmy1 * k;\t\t\/* 1 1 0 1 *\/\n\tb += 0.0078f * x;\n\tx = cmy1 - x;\t\t\/* 1 1 0 0 *\/\n\tr += 0.1804f * x;\n\tg += 0.1922f * x;\n\tb += 0.5725f * x;\n\n\tx = cmy * (1-k);\t\/* 1 1 1 0 *\/\n\tr += 0.2118f * x;\n\tg += 0.2119f * x;\n\tb += 0.2235f * x;\n\trgb[0] = fz_clamp(r, 0, 1);\n\trgb[1] = fz_clamp(g, 0, 1);\n\trgb[2] = fz_clamp(b, 0, 1);\n#else\n\trgb[0] = 1 - fz_min(1, cmyk[0] + cmyk[3]);\n\trgb[1] = 1 - fz_min(1, cmyk[1] + cmyk[3]);\n\trgb[2] = 1 - fz_min(1, cmyk[2] + cmyk[3]);\n#endif\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void filter_block2d_8_c(const uint8_t *src_ptr,\n const unsigned int src_stride,\n const int16_t *HFilter,\n const int16_t *VFilter,\n uint8_t *dst_ptr,\n unsigned int dst_stride,\n unsigned int output_width,\n unsigned int output_height) {\n\n   const int kInterp_Extend = 4;\n   const unsigned int intermediate_height =\n       (kInterp_Extend - 1) + output_height + kInterp_Extend;\n \n  \/* Size of intermediate_buffer is max_intermediate_height * filter_max_width,\n   * where max_intermediate_height = (kInterp_Extend - 1) + filter_max_height\n   *                                 + kInterp_Extend\n   *                               = 3 + 16 + 4\n   *                               = 23\n   * and filter_max_width = 16\n   *\/\n  uint8_t intermediate_buffer[71 * 64];\n   const int intermediate_next_stride = 1 - intermediate_height * output_width;\n \n  {\n    uint8_t *output_ptr = intermediate_buffer;\n    const int src_next_row_stride = src_stride - output_width;\n    unsigned int i, j;\n    src_ptr -= (kInterp_Extend - 1) * src_stride + (kInterp_Extend - 1);\n    for (i = 0; i < intermediate_height; ++i) {\n      for (j = 0; j < output_width; ++j) {\n        const int temp = (src_ptr[0] * HFilter[0]) +\n                         (src_ptr[1] * HFilter[1]) +\n                         (src_ptr[2] * HFilter[2]) +\n                         (src_ptr[3] * HFilter[3]) +\n                         (src_ptr[4] * HFilter[4]) +\n                         (src_ptr[5] * HFilter[5]) +\n                         (src_ptr[6] * HFilter[6]) +\n                         (src_ptr[7] * HFilter[7]) +\n                         (VP9_FILTER_WEIGHT >> 1);  \/\/ Rounding\n \n        *output_ptr = clip_pixel(temp >> VP9_FILTER_SHIFT);\n        ++src_ptr;\n        output_ptr += intermediate_height;\n      }\n      src_ptr += src_next_row_stride;\n      output_ptr += intermediate_next_stride;\n     }\n   }\n \n  {\n    uint8_t *src_ptr = intermediate_buffer;\n    const int dst_next_row_stride = dst_stride - output_width;\n    unsigned int i, j;\n    for (i = 0; i < output_height; ++i) {\n      for (j = 0; j < output_width; ++j) {\n        const int temp = (src_ptr[0] * VFilter[0]) +\n                         (src_ptr[1] * VFilter[1]) +\n                         (src_ptr[2] * VFilter[2]) +\n                         (src_ptr[3] * VFilter[3]) +\n                         (src_ptr[4] * VFilter[4]) +\n                         (src_ptr[5] * VFilter[5]) +\n                         (src_ptr[6] * VFilter[6]) +\n                         (src_ptr[7] * VFilter[7]) +\n                         (VP9_FILTER_WEIGHT >> 1);  \/\/ Rounding\n \n        *dst_ptr++ = clip_pixel(temp >> VP9_FILTER_SHIFT);\n        src_ptr += intermediate_height;\n      }\n      src_ptr += intermediate_next_stride;\n      dst_ptr += dst_next_row_stride;\n     }\n   }\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_cal(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->flags & FZ_COLORSPACE_IS_CAL);\n}\n","project":"ghostscript","target":0},{"commit_id":"e629194c62a9a129ce378e08cb1059a8a53f1795","func":"WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n \/* ! *\/\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n \n     ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n     ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n     ps_dec->pv_dec_out = ps_dec_op;\n     if(ps_dec->init_done != 1)\n     {\n return IV_FAIL;\n }\n\n \/*Data memory barries instruction,so that bitstream write by the application is complete*\/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if(ps_dec->ps_out_buffer->u4_num_bufs == 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n \/* ! *\/\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n \/*\n     * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n     *\/\n {\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n            ps_dec->u1_top_bottom_decoded = 0;\n }\n }\n    ps_dec->u4_slice_start_code_found = 0;\n\n \/* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases *\/\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n \/* Check if at least one buffer is available with the codec *\/\n \/* If not then return to application with error *\/\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n \/* If something is queued for display wait for that buffer to be returned *\/\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n \/* check if any buffer was given for display which is not returned yet *\/\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n \/* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding *\/\n\n if(1 == display_queued)\n {\n \/* If something is queued for display wait for that buffer to be returned *\/\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n \/* If the buffer is with display, then mark it as in use and then look for a buffer again *\/\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n \/**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     *\/\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)\n {\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n \/*In the case of flush ,since no frame is decoded set pic type as invalid*\/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n \/*if resolution has changed and all buffers have been flushed, reset decoder*\/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 2;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n\n \/* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         *\/\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n (ps_dec->i4_header_decoded & 1))\n {\n            WORD32 size;\n\n void *pv_buf;\n void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 \/ 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\n            RETURN_IF((NULL == pv_buf), IV_FAIL);\n            ps_dec->pu1_bits_buf_dynamic = pv_buf;\n            ps_dec->u4_dynamic_bits_buf_size = size;\n }\n\n if(ps_dec->pu1_bits_buf_dynamic)\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n }\n else\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n \/* Ignore bytes beyond the allocated size of intermediate buffer *\/\n        buflen = MIN(buflen, buf_size);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n \/*skip non reference frames*\/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n \/*We have encountered a referenced frame,return to app*\/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n \/*signal the decode thread*\/\n                        ih264d_signal_decode_thread(ps_dec);\n \/* close deblock thread if it is not closed yet*\/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n \/* Decoder may read extra 8 bytes near end of the frame *\/\n if((buflen + 8) < buf_size)\n {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n }\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n \/*start code not found*\/\n\n if(u4_first_start_code_found == 0)\n {\n \/*no start codes found in current process call*\/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n \/* a start code has already been found earlier in the same process call*\/\n                frame_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T))\n {\n break;\n }\n\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n \/*We have encountered a referenced frame,return to app*\/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n \/*signal the decode thread*\/\n            ih264d_signal_decode_thread(ps_dec);\n \/* close deblock thread if it is not closed yet*\/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ret != IVD_MEM_ALLOC_FAILED)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n\n        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))\n {\n return IV_FAIL;\n }\n }\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T))\n {\n\n \/* signal the decode thread *\/\n        ih264d_signal_decode_thread(ps_dec);\n \/* close deblock thread if it is not closed yet *\/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n \/* dont consume bitstream for change in resolution case *\/\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n \/* If Format conversion is not complete,\n         complete it here *\/\n if(ps_dec->u4_num_cores == 2)\n {\n\n \/*do deblocking of all mbs*\/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n \/*BS is done for all mbs while parsing*\/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n \/*signal the decode thread*\/\n        ih264d_signal_decode_thread(ps_dec);\n \/* close deblock thread if it is not closed yet*\/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n \/*We have encountered a referenced frame,return to app*\/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n \/* close deblock thread if it is not closed yet*\/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n \/*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         *\/\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n\n \/* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference \/display\n         *\/\n if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n {\n \/* Calling Function to deblock Picture and Display *\/\n            ret = ih264d_deblock_display(ps_dec);\n if(ret != 0)\n {\n return IV_FAIL;\n }\n }\n\n\n \/*set to complete ,as we dont support partial frame decode*\/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n \/*Update the i4_frametype at the end of picture*\/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n \/* close deblock thread if it is not closed yet*\/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n \/* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         *\/\n\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n \/* If Format conversion is not complete,\n         complete it here *\/\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n \/*Data memory barrier instruction,so that yuv write by the library is complete*\/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long SegmentInfo::GetTimeCodeScale() const\n{\n    return m_timecodeScale;\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_FUNCTION(preg_match_all)\n{\n\tphp_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n","project":"php","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_generate_sAMAccountName(struct ldb_context *ldb,\n\t\t\t\t\t  struct ldb_message *msg)\n{\n\tchar *name;\n\n\t\/* Format: $000000-000000000000 *\/\n\n\tname = talloc_asprintf(msg, \"$%.6X-%.6X%.6X\",\n\t\t\t\t(unsigned int)generate_random(),\n\t\t\t\t(unsigned int)generate_random(),\n\t\t\t\t(unsigned int)generate_random());\n\tif (name == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\treturn ldb_msg_add_steal_string(msg, \"sAMAccountName\", name);\n}\n","project":"samba","target":0},{"commit_id":"7c9be319a279654e55a6d757265f88c61a16a4d5","func":"IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,\n nal_header_t *ps_nal)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 value;\n    WORD32 i, j;\n    WORD32 sps_id;\n\n pps_t *ps_pps;\n sps_t *ps_sps;\n slice_header_t *ps_slice_hdr;\n    WORD32 disable_deblocking_filter_flag;\n bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n    WORD32 idr_pic_flag;\n    WORD32 pps_id;\n    WORD32 first_slice_in_pic_flag;\n    WORD32 no_output_of_prior_pics_flag = 0;\n\n     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;\n     WORD32 num_poc_total_curr = 0;\n     WORD32 slice_address;\n \n     if(ps_codec->i4_slice_error == 1)\n         return ret;\n\n    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||\n (NAL_IDR_N_LP == i1_nal_unit_type);\n\n\n    BITS_PARSE(\"first_slice_in_pic_flag\", first_slice_in_pic_flag, ps_bitstrm, 1);\n if((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n {\n        BITS_PARSE(\"no_output_of_prior_pics_flag\", no_output_of_prior_pics_flag, ps_bitstrm, 1);\n }\n    UEV_PARSE(\"pic_parameter_set_id\", pps_id, ps_bitstrm);\n    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);\n\n \/* Get the current PPS structure *\/\n    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;\n if(0 == ps_pps->i1_pps_valid)\n {\n pps_t *ps_pps_ref = ps_codec->ps_pps_base;\n while(0 == ps_pps_ref->i1_pps_valid)\n {\n            ps_pps_ref++;\n if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))\n return IHEVCD_INVALID_HEADER;\n }\n\n        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);\n }\n\n \/* Get SPS id for the current PPS *\/\n    sps_id = ps_pps->i1_sps_id;\n\n \/* Get the current SPS structure *\/\n    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;\n\n \/* When the current slice is the first in a pic,\n     *  check whether the previous frame is complete\n     *  If the previous frame is incomplete -\n     *  treat the remaining CTBs as skip *\/\n if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&\n                    first_slice_in_pic_flag)\n {\n if(ps_codec->i4_pic_present)\n {\n slice_header_t *ps_slice_hdr_next;\n            ps_codec->i4_slice_error = 1;\n            ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n            ps_slice_hdr_next->i2_ctb_x = 0;\n            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n return ret;\n }\n else\n {\n            ps_codec->i4_slice_error = 0;\n }\n }\n\n if(first_slice_in_pic_flag)\n {\n        ps_codec->s_parse.i4_cur_slice_idx = 0;\n }\n else\n {\n \/* If the current slice is not the first slice in the pic,\n         * but the first one to be parsed, set the current slice indx to 1\n         * Treat the first slice to be missing and copy the current slice header\n         * to the first one *\/\n if(0 == ps_codec->i4_pic_present)\n            ps_codec->s_parse.i4_cur_slice_idx = 1;\n }\n\n    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n\n\n if((ps_pps->i1_dependent_slice_enabled_flag) &&\n (!first_slice_in_pic_flag))\n {\n        BITS_PARSE(\"dependent_slice_flag\", value, ps_bitstrm, 1);\n\n \/* If dependendent slice, copy slice header from previous slice *\/\n if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))\n {\n            ihevcd_copy_slice_hdr(ps_codec,\n (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),\n ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));\n }\n        ps_slice_hdr->i1_dependent_slice_flag = value;\n }\n else\n {\n        ps_slice_hdr->i1_dependent_slice_flag = 0;\n }\n    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;\n    ps_slice_hdr->i1_pps_id = pps_id;\n    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;\n\n    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;\n if((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n {\n        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;\n }\n    ps_slice_hdr->i1_pps_id = pps_id;\n\n if(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n {\n        WORD32 num_bits;\n\n \/* Use CLZ to compute Ceil( Log2( PicSizeInCtbsY ) ) *\/\n        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);\n        BITS_PARSE(\"slice_address\", value, ps_bitstrm, num_bits);\n\n        slice_address = value;\n \/* If slice address is greater than the number of CTBs in a picture,\n         * ignore the slice *\/\n if(value >= ps_sps->i4_pic_size_in_ctb)\n return IHEVCD_IGNORE_SLICE;\n }\n else\n {\n        slice_address = 0;\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n        ps_slice_hdr->i1_pic_output_flag = 1;\n        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;\n        ps_slice_hdr->i1_num_long_term_sps = 0;\n        ps_slice_hdr->i1_num_long_term_pics = 0;\n\n for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)\n {\n            BITS_PARSE(\"slice_reserved_undetermined_flag[ i ]\", value, ps_bitstrm, 1);\n }\n        UEV_PARSE(\"slice_type\", value, ps_bitstrm);\n        ps_slice_hdr->i1_slice_type = value;\n\n \/* If the picture is IRAP, slice type must be equal to ISLICE *\/\n if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&\n (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))\n            ps_slice_hdr->i1_slice_type = ISLICE;\n\n if((ps_slice_hdr->i1_slice_type < 0) ||\n (ps_slice_hdr->i1_slice_type > 2))\n return IHEVCD_IGNORE_SLICE;\n\n if(ps_pps->i1_output_flag_present_flag)\n {\n            BITS_PARSE(\"pic_output_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_pic_output_flag = value;\n }\n        ps_slice_hdr->i1_colour_plane_id = 0;\n if(1 == ps_sps->i1_separate_colour_plane_flag)\n {\n            BITS_PARSE(\"colour_plane_id\", value, ps_bitstrm, 2);\n            ps_slice_hdr->i1_colour_plane_id = value;\n }\n        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;\n\n if(!idr_pic_flag)\n {\n\n            WORD32 st_rps_idx;\n            WORD32 num_neg_pics;\n            WORD32 num_pos_pics;\n            WORD8 *pi1_used;\n\n            BITS_PARSE(\"pic_order_cnt_lsb\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n            ps_slice_hdr->i4_pic_order_cnt_lsb = value;\n\n            BITS_PARSE(\"short_term_ref_pic_set_sps_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;\n\n if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)\n {\n                WORD32 numbits;\n\n                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;\n if(ps_sps->i1_num_short_term_ref_pic_sets > 1)\n {\n                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);\n                    BITS_PARSE(\"short_term_ref_pic_set_idx\", value, ps_bitstrm, numbits);\n                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;\n }\n\n                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;\n                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;\n                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;\n                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;\n }\n else\n {\n                ihevcd_short_term_ref_pic_set(ps_bitstrm,\n &ps_sps->as_stref_picset[0],\n                                              ps_sps->i1_num_short_term_ref_pic_sets,\n                                              ps_sps->i1_num_short_term_ref_pic_sets,\n &ps_slice_hdr->s_stref_picset);\n\n                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;\n                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;\n                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;\n                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;\n }\n\n if(ps_sps->i1_long_term_ref_pics_present_flag)\n {\n if(ps_sps->i1_num_long_term_ref_pics_sps > 0)\n {\n                    UEV_PARSE(\"num_long_term_sps\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_num_long_term_sps = value;\n\n                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,\n 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);\n }\n                UEV_PARSE(\"num_long_term_pics\", value, ps_bitstrm);\n                ps_slice_hdr->i1_num_long_term_pics = value;\n                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,\n 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -\n                                                            ps_slice_hdr->i1_num_long_term_sps);\n\n for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +\n                                ps_slice_hdr->i1_num_long_term_pics); i++)\n {\n if(i < ps_slice_hdr->i1_num_long_term_sps)\n {\n \/* Use CLZ to compute Ceil( Log2( num_long_term_ref_pics_sps ) ) *\/\n if (ps_sps->i1_num_long_term_ref_pics_sps > 1)\n {\n                            WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);\n                            BITS_PARSE(\"lt_idx_sps[ i ]\", value, ps_bitstrm, num_bits);\n }\n else\n {\n                            value = 0;\n }\n                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];\n                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];\n\n }\n else\n {\n                        BITS_PARSE(\"poc_lsb_lt[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;\n\n                        BITS_PARSE(\"used_by_curr_pic_lt_flag[ i ]\", value, ps_bitstrm, 1);\n                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;\n\n }\n                    BITS_PARSE(\"delta_poc_msb_present_flag[ i ]\", value, ps_bitstrm, 1);\n                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;\n\n\n                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;\n if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])\n {\n\n                        UEV_PARSE(\"delata_poc_msb_cycle_lt[ i ]\", value, ps_bitstrm);\n                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;\n }\n\n if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))\n {\n                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];\n }\n\n }\n }\n\n for(i = 0; i < num_neg_pics + num_pos_pics; i++)\n {\n if(pi1_used[i])\n {\n                    num_poc_total_curr++;\n }\n }\n for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)\n {\n if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])\n {\n                    num_poc_total_curr++;\n }\n }\n\n\n if(ps_sps->i1_sps_temporal_mvp_enable_flag)\n {\n                BITS_PARSE(\"enable_temporal_mvp_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;\n }\n\n }\n        ps_slice_hdr->i1_slice_sao_luma_flag = 0;\n        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;\n if(ps_sps->i1_sample_adaptive_offset_enabled_flag)\n {\n            BITS_PARSE(\"slice_sao_luma_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_sao_luma_flag = value;\n\n            BITS_PARSE(\"slice_sao_chroma_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_sao_chroma_flag = value;\n\n }\n\n        ps_slice_hdr->i1_max_num_merge_cand = 1;\n        ps_slice_hdr->i1_cabac_init_flag = 0;\n\n        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;\n        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;\n        ps_slice_hdr->i1_slice_cb_qp_offset = 0;\n        ps_slice_hdr->i1_slice_cr_qp_offset = 0;\n if((PSLICE == ps_slice_hdr->i1_slice_type) ||\n (BSLICE == ps_slice_hdr->i1_slice_type))\n {\n            BITS_PARSE(\"num_ref_idx_active_override_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;\n\n if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)\n {\n                UEV_PARSE(\"num_ref_idx_l0_active_minus1\", value, ps_bitstrm);\n                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    UEV_PARSE(\"num_ref_idx_l1_active_minus1\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;\n }\n\n }\n else\n {\n                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;\n }\n }\n\n            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);\n            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);\n\n if(0 == num_poc_total_curr)\n return IHEVCD_IGNORE_SLICE;\n if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))\n {\n                ihevcd_ref_pic_list_modification(ps_bitstrm,\n                                                 ps_slice_hdr, num_poc_total_curr);\n }\n else\n {\n                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;\n                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;\n }\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                BITS_PARSE(\"mvd_l1_zero_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_mvd_l1_zero_flag = value;\n }\n\n            ps_slice_hdr->i1_cabac_init_flag = 0;\n if(ps_pps->i1_cabac_init_present_flag)\n {\n                BITS_PARSE(\"cabac_init_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_cabac_init_flag = value;\n\n }\n            ps_slice_hdr->i1_collocated_from_l0_flag = 1;\n            ps_slice_hdr->i1_collocated_ref_idx = 0;\n if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)\n {\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    BITS_PARSE(\"collocated_from_l0_flag\", value, ps_bitstrm, 1);\n                    ps_slice_hdr->i1_collocated_from_l0_flag = value;\n }\n\n if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||\n (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))\n {\n                    UEV_PARSE(\"collocated_ref_idx\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_collocated_ref_idx = value;\n }\n\n }\n            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);\n\n if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||\n (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))\n {\n                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);\n }\n            UEV_PARSE(\"five_minus_max_num_merge_cand\", value, ps_bitstrm);\n            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;\n\n }\n        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);\n        SEV_PARSE(\"slice_qp_delta\", value, ps_bitstrm);\n        ps_slice_hdr->i1_slice_qp_delta = value;\n\n if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)\n {\n            SEV_PARSE(\"slice_cb_qp_offset\", value, ps_bitstrm);\n            ps_slice_hdr->i1_slice_cb_qp_offset = value;\n\n            SEV_PARSE(\"slice_cr_qp_offset\", value, ps_bitstrm);\n            ps_slice_hdr->i1_slice_cr_qp_offset = value;\n\n }\n        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;\n        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;\n        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;\n        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;\n\n        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;\n\n if(ps_pps->i1_deblocking_filter_control_present_flag)\n {\n\n if(ps_pps->i1_deblocking_filter_override_enabled_flag)\n {\n                BITS_PARSE(\"deblocking_filter_override_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_deblocking_filter_override_flag = value;\n }\n\n if(ps_slice_hdr->i1_deblocking_filter_override_flag)\n {\n                BITS_PARSE(\"slice_disable_deblocking_filter_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;\n                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;\n\n if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)\n {\n                    SEV_PARSE(\"beta_offset_div2\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_beta_offset_div2 = value;\n\n                    SEV_PARSE(\"tc_offset_div2\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_tc_offset_div2 = value;\n\n }\n }\n }\n\n        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;\n if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&\n (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))\n {\n            BITS_PARSE(\"slice_loop_filter_across_slices_enabled_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;\n }\n\n }\n\n \/* Check sanity of slice *\/\n if((!first_slice_in_pic_flag) &&\n (ps_codec->i4_pic_present))\n {\n slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;\n\n\n \/* According to the standard, the above conditions must be satisfied - But for error resilience,\n         * only the following conditions are checked *\/\n if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||\n (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))\n {\n return IHEVCD_IGNORE_SLICE;\n }\n\n }\n\n\n if(0 == ps_codec->i4_pic_present)\n {\n        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);\n }\n else\n {\n        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;\n }\n\n\n if(!first_slice_in_pic_flag)\n {\n \/* Check if the current slice belongs to the same pic (Pic being parsed) *\/\n if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n {\n\n \/* If the Next CTB's index is less than the slice address,\n             * the previous slice is incomplete.\n             * Indicate slice error, and treat the remaining CTBs as skip *\/\n if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)\n\n             {\n                 if(ps_codec->i4_pic_present)\n                 {\n                    slice_header_t *ps_slice_hdr_next;\n                    ps_codec->i4_slice_error = 1;\n                    ps_codec->s_parse.i4_cur_slice_idx--;\n                    if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                        ps_codec->s_parse.i4_cur_slice_idx = 0;\n                    ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                    ps_slice_hdr_next->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\n                    ps_slice_hdr_next->i2_ctb_y = slice_address \/ ps_sps->i2_pic_wd_in_ctb;\n                    return ret;\n                 }\n                 else\n                 {\n return IHEVCD_IGNORE_SLICE;\n }\n }\n \/* If the slice address is less than the next CTB's index,\n             * extra CTBs have been decoded in the previous slice.\n             * Ignore the current slice. Treat it as incomplete *\/\n else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)\n {\n return IHEVCD_IGNORE_SLICE;\n }\n else\n {\n                ps_codec->i4_slice_error = 0;\n }\n }\n\n \/* The current slice does not belong to the pic that is being parsed *\/\n else\n {\n \/* The previous pic is incomplete.\n             * Treat the remaining CTBs as skip *\/\n if(ps_codec->i4_pic_present)\n {\n slice_header_t *ps_slice_hdr_next;\n                ps_codec->i4_slice_error = 1;\n                ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                    ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                ps_slice_hdr_next->i2_ctb_x = 0;\n                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n return ret;\n }\n\n \/* If the previous pic is complete,\n             * return if the current slice is dependant\n             * otherwise, update the parse context's POC *\/\n else\n {\n if(ps_slice_hdr->i1_dependent_slice_flag)\n return IHEVCD_IGNORE_SLICE;\n\n                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n }\n }\n }\n\n \/* If the slice is the first slice in the pic, update the parse context's POC *\/\n else\n {\n \/* If the first slice is repeated, ignore the second occurrence\n         * If any other slice is repeated, the CTB addr will be greater than the slice addr,\n         * and hence the second occurrence is ignored *\/\n if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n return IHEVCD_IGNORE_SLICE;\n\n        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n }\n\n    ps_slice_hdr->i4_num_entry_point_offsets = 0;\n if((ps_pps->i1_tiles_enabled_flag) ||\n (ps_pps->i1_entropy_coding_sync_enabled_flag))\n {\n        UEV_PARSE(\"num_entry_point_offsets\", value, ps_bitstrm);\n        ps_slice_hdr->i4_num_entry_point_offsets = value;\n\n {\n            WORD32 max_num_entry_point_offsets;\n if((ps_pps->i1_tiles_enabled_flag) &&\n (ps_pps->i1_entropy_coding_sync_enabled_flag))\n {\n                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);\n }\n else if(ps_pps->i1_tiles_enabled_flag)\n {\n                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;\n }\n else\n {\n                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);\n }\n\n            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,\n 0, max_num_entry_point_offsets);\n }\n\n if(ps_slice_hdr->i4_num_entry_point_offsets > 0)\n {\n            UEV_PARSE(\"offset_len_minus1\", value, ps_bitstrm);\n            ps_slice_hdr->i1_offset_len = value + 1;\n\n for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)\n {\n                BITS_PARSE(\"entry_point_offset\", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);\n\n \/* TODO: pu4_entry_point_offset needs to be initialized *\/\n }\n\n }\n }\n\n if(ps_pps->i1_slice_header_extension_present_flag)\n {\n        UEV_PARSE(\"slice_header_extension_length\", value, ps_bitstrm);\n        ps_slice_hdr->i2_slice_header_extension_length = value;\n\n\n for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)\n {\n            BITS_PARSE(\"slice_header_extension_data_byte\", value, ps_bitstrm, 8);\n }\n\n }\n\n    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);\n\n if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)\n return IHEVCD_INVALID_PARAMETER;\n\n {\n dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\n        WORD32 r_idx;\n\n if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (0 == ps_codec->u4_pic_cnt))\n {\n for(i = 0; i < MAX_DPB_BUFS; i++)\n {\n if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)\n {\n pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;\n mv_buf_t *ps_mv_buf;\n\n \/* Long term index is set to MAX_DPB_BUFS to ensure it is not added as LT *\/\n                    ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);\n \/* Find buffer id of the MV bank corresponding to the buffer being freed (Buffer with POC of u4_abs_poc) *\/\n                    ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;\n for(j = 0; j < ps_codec->i4_max_dpb_size; j++)\n {\n if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)\n {\n                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);\n break;\n }\n                        ps_mv_buf++;\n }\n\n }\n\n }\n\n \/* Initialize the reference lists to NULL\n             * This is done to take care of the cases where the first pic is not IDR\n             * but the reference list is not created for the first pic because\n             * pic count is zero leaving the reference list uninitialised  *\/\n for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;\n\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;\n }\n\n }\n else\n {\n            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);\n if ((WORD32)IHEVCD_SUCCESS != ret)\n {\n return ret;\n }\n\n }\n\n }\n\n \/* Fill the remaining entries of the reference lists with the nearest POC\n     * This is done to handle cases where there is a corruption in the reference index *\/\n if(ps_codec->i4_pic_present)\n {\n pic_buf_t *ps_pic_buf_ref;\n mv_buf_t *ps_mv_buf_ref;\n        WORD32 r_idx;\n dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\n buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;\n\n        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);\n if(NULL == ps_pic_buf_ref)\n {\n            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;\n            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;\n }\n else\n {\n            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);\n }\n\n for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)\n {\n if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)\n {\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n\n for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)\n {\n if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)\n {\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n \/* Update slice address in the header *\/\n if(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n {\n        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\n        ps_slice_hdr->i2_ctb_y = slice_address \/ ps_sps->i2_pic_wd_in_ctb;\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;\n            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;\n }\n }\n else\n {\n        ps_slice_hdr->i2_ctb_x = 0;\n        ps_slice_hdr->i2_ctb_y = 0;\n\n        ps_slice_hdr->i2_independent_ctb_x = 0;\n        ps_slice_hdr->i2_independent_ctb_y = 0;\n }\n\n \/* If the first slice in the pic is missing, copy the current slice header to\n     * the first slice's header *\/\n if((!first_slice_in_pic_flag) &&\n (0 == ps_codec->i4_pic_present))\n {\n\n         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;\n         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));\n \n        ps_codec->i4_slice_error = 1;\n \n         ps_slice_hdr_prev->i2_ctb_x = 0;\n         ps_slice_hdr_prev->i2_ctb_y = 0;\n\n        ps_codec->s_parse.i4_ctb_x = 0;\n        ps_codec->s_parse.i4_ctb_y = 0;\n\n        ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n if((ps_slice_hdr->i2_ctb_x == 0) &&\n (ps_slice_hdr->i2_ctb_y == 0))\n {\n            ps_slice_hdr->i2_ctb_x++;\n }\n }\n\n {\n \/* If skip B is enabled,\n         * ignore pictures that are non-reference\n         * TODO: (i1_nal_unit_type < NAL_BLA_W_LP) && (i1_nal_unit_type % 2 == 0) only says it is\n         * sub-layer non-reference slice. May need to find a way to detect actual non-reference pictures*\/\n\n if((i1_nal_unit_type < NAL_BLA_W_LP) &&\n (i1_nal_unit_type % 2 == 0))\n {\n if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)\n return IHEVCD_IGNORE_SLICE;\n }\n\n \/* If skip PB is enabled,\n         * decode only I slices *\/\n if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&\n (ISLICE != ps_slice_hdr->i1_slice_type))\n {\n return IHEVCD_IGNORE_SLICE;\n\n         }\n     }\n \n     return ret;\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int add_oid_section(struct php_x509_request * req TSRMLS_DC) \/* {{{ *\/\n{\n\tchar * str;\n\tSTACK_OF(CONF_VALUE) * sktmp;\n\tCONF_VALUE * cnf;\n\tint i;\n\n\tstr = CONF_get_string(req->req_config, NULL, \"oid_section\");\n\tif (str == NULL) {\n\t\treturn SUCCESS;\n\t}\n\tsktmp = CONF_get_section(req->req_config, str);\n\tif (sktmp == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"problem loading oid section %s\", str);\n\t\treturn FAILURE;\n\t}\n\tfor (i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {\n\t\tcnf = sk_CONF_VALUE_value(sktmp, i);\n\t\tif (OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"problem creating object %s=%s\", cnf->name, cnf->value);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static inline int php_openssl_config_check_syntax(const char * section_label, const char * config_filename, const char * section, LHASH_OF(CONF_VALUE) * config TSRMLS_DC) \/* {{{ *\/\n#else\nstatic inline int php_openssl_config_check_syntax(const char * section_label, const char * config_filename, const char * section, LHASH * config TSRMLS_DC)\n#endif\n{\n\tX509V3_CTX ctx;\n\t\n\tX509V3_set_ctx_test(&ctx);\n\tX509V3_set_conf_lhash(&ctx, config);\n\tif (!X509V3_EXT_add_conf(config, &ctx, (char *)section, NULL)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error loading %s section %s of %s\",\n\t\t\t\tsection_label,\n\t\t\t\tsection,\n\t\t\t\tconfig_filename);\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Block* BlockGroup::GetBlock() const\n{\n    return &m_block;\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_get_archive(phar_archive_data **archive, char *fname, int fname_len, char *alias, int alias_len, char **error TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_archive_data *fd, **fd_ptr;\n\tchar *my_realpath, *save;\n\tint save_len;\n\tulong fhash, ahash = 0;\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t*archive = NULL;\n\n\tif (PHAR_G(last_phar) && fname_len == PHAR_G(last_phar_name_len) && !memcmp(fname, PHAR_G(last_phar_name), fname_len)) {\n\t\t*archive = PHAR_G(last_phar);\n\t\tif (alias && alias_len) {\n\n\t\t\tif (!PHAR_G(last_phar)->is_temporary_alias && (alias_len != PHAR_G(last_phar)->alias_len || memcmp(PHAR_G(last_phar)->alias, alias, alias_len))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, PHAR_G(last_phar)->fname, fname);\n\t\t\t\t}\n\t\t\t\t*archive = NULL;\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_G(last_phar)->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len, (void**)&fd_ptr)) {\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len);\n\t\t\t}\n\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&(*archive), sizeof(phar_archive_data*), NULL);\n\t\t\tPHAR_G(last_alias) = alias;\n\t\t\tPHAR_G(last_alias_len) = alias_len;\n\t\t}\n\n\t\treturn SUCCESS;\n\t}\n\n\tif (alias && alias_len && PHAR_G(last_phar) && alias_len == PHAR_G(last_alias_len) && !memcmp(alias, PHAR_G(last_alias), alias_len)) {\n\t\tfd = PHAR_G(last_phar);\n\t\tfd_ptr = &fd;\n\t\tgoto alias_success;\n\t}\n\n\tif (alias && alias_len) {\n\t\tahash = zend_inline_hash_func(alias, alias_len);\n\t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void**)&fd_ptr)) {\nalias_success:\n\t\t\tif (fname && (fname_len != (*fd_ptr)->fname_len || strncmp(fname, (*fd_ptr)->fname, fname_len))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, (*fd_ptr)->fname, fname);\n\t\t\t\t}\n\t\t\t\tif (SUCCESS == phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tefree(*error);\n\t\t\t\t\t\t*error = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*archive = *fd_ptr;\n\t\t\tfd = *fd_ptr;\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = alias;\n\t\t\tPHAR_G(last_alias_len) = alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, alias, alias_len, ahash, (void **)&fd_ptr)) {\n\t\t\tgoto alias_success;\n\t\t}\n\t}\n\n\tfhash = zend_inline_hash_func(fname, fname_len);\n\tmy_realpath = NULL;\n\tsave = fname;\n\tsave_len = fname_len;\n\n\tif (fname && fname_len) {\n\t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {\n\t\t\t*archive = *fd_ptr;\n\t\t\tfd = *fd_ptr;\n\n\t\t\tif (alias && alias_len) {\n\t\t\t\tif (!fd->is_temporary_alias && (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len))) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, (*fd_ptr)->fname, fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (fd->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len, (void**)&fd_ptr)) {\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len);\n\t\t\t\t}\n\n\t\t\t\tzend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);\n\t\t\t}\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {\n\t\t\t*archive = *fd_ptr;\n\t\t\tfd = *fd_ptr;\n\n\t\t\t\/* this could be problematic - alias should never be different from manifest alias\n\t\t\t   for cached phars *\/\n\t\t\tif (!fd->is_temporary_alias && alias && alias_len) {\n\t\t\t\tif (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, (*fd_ptr)->fname, fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), save, save_len, fhash, (void**)&fd_ptr)) {\n\t\t\tfd = *archive = *fd_ptr;\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, save, save_len, fhash, (void**)&fd_ptr)) {\n\t\t\tfd = *archive = *fd_ptr;\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\t\/* not found, try converting \\ to \/ *\/\n\t\tmy_realpath = expand_filepath(fname, my_realpath TSRMLS_CC);\n\n\t\tif (my_realpath) {\n\t\t\tfname_len = strlen(my_realpath);\n\t\t\tfname = my_realpath;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(fname, fname_len);\n#endif\n\t\tfhash = zend_inline_hash_func(fname, fname_len);\n\n\t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {\nrealpath_success:\n\t\t\t*archive = *fd_ptr;\n\t\t\tfd = *fd_ptr;\n\n\t\t\tif (alias && alias_len) {\n\t\t\t\tzend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);\n\t\t\t}\n\n\t\t\tefree(my_realpath);\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {\n\t\t\tgoto realpath_success;\n\t\t}\n\n\t\tefree(my_realpath);\n\t}\n\n\treturn FAILURE;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"clamp_default_icc(const fz_colorspace *cs, const float *src, float *dst)\n{\n\tint i;\n\tfz_iccprofile *profile = cs->data;\n\n\tfor (i = 0; i < profile->num_devcomp; i++)\n\t\tdst[i] = fz_clamp(src[i], 0, 1);\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_open)\n{\n\tzval **privkey, *opendata;\n\tEVP_PKEY *pkey;\n\tint len1, len2;\n\tunsigned char *buf;\n\tlong keyresource = -1;\n\tEVP_CIPHER_CTX ctx;\n\tchar * data;\tint data_len;\n\tchar * ekey;\tint ekey_len;\n\tchar *method =NULL;\n\tint method_len = 0;\n\tconst EVP_CIPHER *cipher;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"szsZ|s\", &data, &data_len, &opendata, &ekey, &ekey_len, &privkey, &method, &method_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpkey = php_openssl_evp_from_zval(privkey, 0, \"\", 0, &keyresource TSRMLS_CC);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"unable to coerce parameter 4 into a private key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (method) {\n\t\tcipher = EVP_get_cipherbyname(method);\n\t\tif (!cipher) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm.\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tcipher = EVP_rc4();\n\t}\n\t\n\tbuf = emalloc(data_len + 1);\n\n\tif (EVP_OpenInit(&ctx, cipher, (unsigned char *)ekey, ekey_len, NULL, pkey) && EVP_OpenUpdate(&ctx, buf, &len1, (unsigned char *)data, data_len)) {\n\t\tif (!EVP_OpenFinal(&ctx, buf + len1, &len2) || (len1 + len2 == 0)) {\n\t\t\tefree(buf);\n\t\t\tif (keyresource == -1) { \n\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t}\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tefree(buf);\n\t\tif (keyresource == -1) {\n\t\t\tEVP_PKEY_free(pkey);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\tif (keyresource == -1) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tzval_dtor(opendata);\n\tbuf[len1 + len2] = '\\0';\n\tZVAL_STRINGL(opendata, erealloc(buf, len1 + len2 + 1), len1 + len2, 0);\n\tRETURN_TRUE;\n}\n","project":"php","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftFlacEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamAudioPcm)\");\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams = (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 ALOGE(\"SoftFlacEncoder::internalSetParameter() Error #1\");\n                 return OMX_ErrorUndefined;\n }\n\n if (pcmParams->nChannels < 1 || pcmParams->nChannels > 2) {\n return OMX_ErrorUndefined;\n }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n            ALOGV(\"will encode %d channels at %dHz\", mNumChannels, mSampleRate);\n\n return configureEncoder();\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\");\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                     \"audio_encoder.flac\",\n                     OMX_MAX_STRINGNAME_SIZE - 1)) {\n                ALOGE(\"SoftFlacEncoder::internalSetParameter(OMX_IndexParamStandardComponentRole)\"\n \"error\");\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioFlac:\n\n         {\n             OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;\n             mCompressionLevel = flacParams->nCompressionLevel; \/\/ range clamping done inside encoder\n             return OMX_ErrorNone;\n         }\n\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex == 0) {\n                 if (defParams->nBufferSize > kMaxInputBufferSize) {\n                     ALOGE(\"Input buffer size must be at most %d bytes\",\n                        kMaxInputBufferSize);\n return OMX_ErrorUnsupportedSetting;\n }\n }\n\n }\n\n default:\n            ALOGV(\"SoftFlacEncoder::internalSetParameter(default)\");\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_new_cmap(fz_context *ctx)\n{\n\tpdf_cmap *cmap = fz_malloc_struct(ctx, pdf_cmap);\n\tFZ_INIT_STORABLE(cmap, 1, pdf_drop_cmap_imp);\n\treturn cmap;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n\n     first_drop_ = 0;\n     bits_total_ = 0;\n     duration_ = 0.0;\n   }\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::configureVideoTunnelMode(\n\n         OMX_U32 portIndex, OMX_BOOL tunneled, OMX_U32 audioHwSync,\n         native_handle_t **sidebandHandle) {\n     Mutex::Autolock autolock(mLock);\n     CLOG_CONFIG(configureVideoTunnelMode, \"%s:%u tun=%d sync=%u\",\n             portString(portIndex), portIndex, tunneled, audioHwSync);\n \n    OMX_INDEXTYPE index;\n    OMX_STRING name = const_cast<OMX_STRING>(\n \"OMX.google.android.index.configureVideoTunnelMode\");\n\n    OMX_ERRORTYPE err = OMX_GetExtensionIndex(mHandle, name, &index);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR_IF(tunneled, getExtensionIndex, err, \"%s\", name);\n return StatusFromOMXError(err);\n }\n\n ConfigureVideoTunnelModeParams tunnelParams;\n InitOMXParams(&tunnelParams);\n    tunnelParams.nPortIndex = portIndex;\n    tunnelParams.bTunneled = tunneled;\n    tunnelParams.nAudioHwSync = audioHwSync;\n    err = OMX_SetParameter(mHandle, index, &tunnelParams);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(setParameter, err, \"%s(%#x): %s:%u tun=%d sync=%u\", name, index,\n                portString(portIndex), portIndex, tunneled, audioHwSync);\n return StatusFromOMXError(err);\n }\n\n    err = OMX_GetParameter(mHandle, index, &tunnelParams);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(getParameter, err, \"%s(%#x): %s:%u tun=%d sync=%u\", name, index,\n                portString(portIndex), portIndex, tunneled, audioHwSync);\n return StatusFromOMXError(err);\n }\n if (sidebandHandle) {\n *sidebandHandle = (native_handle_t*)tunnelParams.pSidebandWindow;\n }\n\n return OK;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Chapters::Atom::ParseDisplay(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    if (!ExpandDisplaysArray())\n        return -1;\n    Display& d = m_displays[m_displays_count++];\n    d.Init();\n    return d.Parse(pReader, pos, size);\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"bgr2g(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tdv[0] = sv[0] * 0.11f + sv[1] * 0.59f + sv[2] * 0.3f;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void Reset() {\n     error_nframes_ = 0;\n     droppable_nframes_ = 0;\n   }\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_MINFO_FUNCTION(pcre)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"PCRE (Perl Compatible Regular Expressions) Support\", \"enabled\" );\n\tphp_info_print_table_row(2, \"PCRE Library Version\", pcre_version() );\n\tphp_info_print_table_end();\n\n\tDISPLAY_INI_ENTRIES();\n}\n","project":"php","target":0},{"commit_id":"db829699d3293f254a7387894303451a91278986","func":"status_t BnOMX::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case LIVES_LOCALLY:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n            node_id node = (node_id)data.readInt32();\n pid_t pid = (pid_t)data.readInt32();\n            reply->writeInt32(livesLocally(node, pid));\n\n return OK;\n }\n\n case LIST_NODES:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n List<ComponentInfo> list;\n            listNodes(&list);\n\n            reply->writeInt32(list.size());\n for (List<ComponentInfo>::iterator it = list.begin();\n                 it != list.end(); ++it) {\n ComponentInfo &cur = *it;\n\n                reply->writeString8(cur.mName);\n                reply->writeInt32(cur.mRoles.size());\n for (List<String8>::iterator role_it = cur.mRoles.begin();\n                     role_it != cur.mRoles.end(); ++role_it) {\n                    reply->writeString8(*role_it);\n }\n }\n\n return NO_ERROR;\n }\n\n case ALLOCATE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n const char *name = data.readCString();\n\n            sp<IOMXObserver> observer =\n                interface_cast<IOMXObserver>(data.readStrongBinder());\n\n            node_id node;\n\n status_t err = allocateNode(name, observer, &node);\n            reply->writeInt32(err);\n if (err == OK) {\n                reply->writeInt32((int32_t)node);\n }\n\n return NO_ERROR;\n }\n\n case FREE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            reply->writeInt32(freeNode(node));\n\n return NO_ERROR;\n }\n\n case SEND_COMMAND:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            OMX_COMMANDTYPE cmd =\n static_cast<OMX_COMMANDTYPE>(data.readInt32());\n\n            OMX_S32 param = data.readInt32();\n            reply->writeInt32(sendCommand(node, cmd, param));\n\n return NO_ERROR;\n }\n\n case GET_PARAMETER:\n case SET_PARAMETER:\n case GET_CONFIG:\n case SET_CONFIG:\n case SET_INTERNAL_OPTION:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());\n\n size_t size = data.readInt64();\n\n status_t err = NOT_ENOUGH_DATA;\n\n             void *params = NULL;\n             size_t pageSize = 0;\n             size_t allocSize = 0;\n            if ((index == (OMX_INDEXTYPE) OMX_IndexParamConsumerUsageBits && size < 4) ||\n                    (code != SET_INTERNAL_OPTION && size < 8)) {\n                ALOGE(\"b\/27207275 (%zu)\", size);\n                 android_errorWriteLog(0x534e4554, \"27207275\");\n             } else {\n                 err = NO_MEMORY;\n                pageSize = (size_t) sysconf(_SC_PAGE_SIZE);\n if (size > SIZE_MAX - (pageSize * 2)) {\n                    ALOGE(\"requested param size too big\");\n } else {\n                    allocSize = (size + pageSize * 2) & ~(pageSize - 1);\n                    params = mmap(NULL, allocSize, PROT_READ | PROT_WRITE,\n                            MAP_PRIVATE | MAP_ANONYMOUS, -1 \/* fd *\/, 0 \/* offset *\/);\n }\n if (params != MAP_FAILED) {\n                    err = data.read(params, size);\n if (err != OK) {\n                        android_errorWriteLog(0x534e4554, \"26914474\");\n } else {\n                        err = NOT_ENOUGH_DATA;\n                        OMX_U32 declaredSize = *(OMX_U32*)params;\n if (code != SET_INTERNAL_OPTION &&\n                                index != (OMX_INDEXTYPE) OMX_IndexParamConsumerUsageBits &&\n                                declaredSize > size) {\n                            ALOGE(\"b\/27207275 (%u\/%zu)\", declaredSize, size);\n                            android_errorWriteLog(0x534e4554, \"27207275\");\n } else {\n                            mprotect((char*)params + allocSize - pageSize, pageSize, PROT_NONE);\n switch (code) {\n case GET_PARAMETER:\n                                    err = getParameter(node, index, params, size);\n break;\n case SET_PARAMETER:\n                                    err = setParameter(node, index, params, size);\n break;\n case GET_CONFIG:\n                                    err = getConfig(node, index, params, size);\n break;\n case SET_CONFIG:\n                                    err = setConfig(node, index, params, size);\n break;\n case SET_INTERNAL_OPTION:\n {\n InternalOptionType type =\n (InternalOptionType)data.readInt32();\n\n                                    err = setInternalOption(node, index, type, params, size);\n break;\n }\n\n default:\n                                    TRESPASS();\n }\n }\n }\n } else {\n                    ALOGE(\"couldn't map: %s\", strerror(errno));\n }\n }\n\n            reply->writeInt32(err);\n\n if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {\n                reply->write(params, size);\n }\n\n if (params) {\n                munmap(params, allocSize);\n }\n            params = NULL;\n\n return NO_ERROR;\n }\n\n case GET_STATE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_STATETYPE state = OMX_StateInvalid;\n\n status_t err = getState(node, &state);\n            reply->writeInt32(state);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case ENABLE_GRAPHIC_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n status_t err = enableGraphicBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case GET_GRAPHIC_BUFFER_USAGE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            OMX_U32 usage = 0;\n status_t err = getGraphicBufferUsage(node, port_index, &usage);\n            reply->writeInt32(err);\n            reply->writeInt32(usage);\n\n return NO_ERROR;\n }\n\n case USE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = useBuffer(node, port_index, params, &buffer, allottedSize);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case USE_GRAPHIC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n\n            buffer_id buffer;\n status_t err = useGraphicBuffer(\n                    node, port_index, graphicBuffer, &buffer);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case UPDATE_GRAPHIC_BUFFER_IN_META:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            buffer_id buffer = (buffer_id)data.readInt32();\n\n status_t err = updateGraphicBufferInMeta(\n                    node, port_index, graphicBuffer, buffer);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CREATE_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferProducer> bufferProducer;\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = createInputSurface(node, port_index, &bufferProducer, &type);\n\n if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {\n                android_errorWriteLog(0x534e4554, \"26324358\");\n }\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n }\n\n return NO_ERROR;\n }\n\n case CREATE_PERSISTENT_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            sp<IGraphicBufferProducer> bufferProducer;\n            sp<IGraphicBufferConsumer> bufferConsumer;\n status_t err = createPersistentInputSurface(\n &bufferProducer, &bufferConsumer);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n                reply->writeStrongBinder(IInterface::asBinder(bufferConsumer));\n }\n\n return NO_ERROR;\n }\n\n case SET_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferConsumer> bufferConsumer =\n                    interface_cast<IGraphicBufferConsumer>(data.readStrongBinder());\n\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = setInputSurface(node, port_index, bufferConsumer, &type);\n\n if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {\n                android_errorWriteLog(0x534e4554, \"26324358\");\n }\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n return NO_ERROR;\n }\n\n case SIGNAL_END_OF_INPUT_STREAM:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n status_t err = signalEndOfInputStream(node);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case STORE_META_DATA_IN_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = storeMetaDataInBuffers(node, port_index, enable, &type);\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case PREPARE_FOR_ADAPTIVE_PLAYBACK:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n            OMX_U32 max_width = data.readInt32();\n            OMX_U32 max_height = data.readInt32();\n\n status_t err = prepareForAdaptivePlayback(\n                    node, port_index, enable, max_width, max_height);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CONFIGURE_VIDEO_TUNNEL_MODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();\n            OMX_U32 audio_hw_sync = data.readInt32();\n\n native_handle_t *sideband_handle = NULL;\n status_t err = configureVideoTunnelMode(\n                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);\n            reply->writeInt32(err);\n if(err == OK){\n                reply->writeNativeHandle(sideband_handle);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n if (!isSecure(node) || port_index != 0 \/* kPortIndexInput *\/) {\n                ALOGE(\"b\/24310423\");\n                reply->writeInt32(INVALID_OPERATION);\n return NO_ERROR;\n }\n\n size_t size = data.readInt64();\n\n            buffer_id buffer;\n void *buffer_data;\n status_t err = allocateBuffer(\n                    node, port_index, size, &buffer, &buffer_data);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n                reply->writeInt64((uintptr_t)buffer_data);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER_WITH_BACKUP:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = allocateBufferWithBackup(\n                    node, port_index, params, &buffer, allottedSize);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case FREE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(freeBuffer(node, port_index, buffer));\n\n return NO_ERROR;\n }\n\n case FILL_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(fillBuffer(node, buffer, fenceFd));\n\n return NO_ERROR;\n }\n\n case EMPTY_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            OMX_U32 range_offset = data.readInt32();\n            OMX_U32 range_length = data.readInt32();\n            OMX_U32 flags = data.readInt32();\n            OMX_TICKS timestamp = data.readInt64();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(emptyBuffer(\n                    node, buffer, range_offset, range_length, flags, timestamp, fenceFd));\n\n return NO_ERROR;\n }\n\n case GET_EXTENSION_INDEX:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n const char *parameter_name = data.readCString();\n\n            OMX_INDEXTYPE index;\n status_t err = getExtensionIndex(node, parameter_name, &index);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32(index);\n }\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n","project":"Android","target":1},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"void ssl3_free(SSL *s)\n\t{\n\tif(s == NULL)\n\t    return;\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tif (s->s3->client_opaque_prf_input != NULL)\n\t\tOPENSSL_free(s->s3->client_opaque_prf_input);\n\tif (s->s3->server_opaque_prf_input != NULL)\n\t\tOPENSSL_free(s->s3->server_opaque_prf_input);\n#endif\n\n\tssl3_cleanup_key_block(s);\n\tif (s->s3->rbuf.buf != NULL)\n\t\tssl3_release_read_buffer(s);\n\tif (s->s3->wbuf.buf != NULL)\n\t\tssl3_release_write_buffer(s);\n\tif (s->s3->rrec.comp != NULL)\n\t\tOPENSSL_free(s->s3->rrec.comp);\n#ifndef OPENSSL_NO_DH\n\tif (s->s3->tmp.dh != NULL)\n\t\tDH_free(s->s3->tmp.dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tif (s->s3->tmp.ecdh != NULL)\n\t\tEC_KEY_free(s->s3->tmp.ecdh);\n#endif\n\n\tif (s->s3->tmp.ca_names != NULL)\n\t\tsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\n\tif (s->s3->handshake_buffer) {\n\t\tBIO_free(s->s3->handshake_buffer);\n\t}\n\tif (s->s3->handshake_dgst) ssl3_free_digest_list(s);\n#ifndef OPENSSL_NO_SRP\n\tSSL_SRP_CTX_free(s);\n#endif\n\tOPENSSL_cleanse(s->s3,sizeof *s->s3);\n\tOPENSSL_free(s->s3);\n\ts->s3=NULL;\n\t}\n","project":"openssl","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_cmm_drop_instance(fz_context *ctx)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->drop_instance(ctx->cmm_instance);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"clamp_lab(const fz_colorspace *cs, const float *src, float *dst)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tdst[i] = fz_clamp(src[i], i ? -128 : 0, i ? 127 : 100);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void fdct16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n  vp9_fdct16x16_c(in, out, stride);\n }\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static int preg_get_backref(char **str, int *backref)\n{\n\tregister char in_brace = 0;\n\tregister char *walk = *str;\n\n\tif (walk[1] == 0)\n\t\treturn 0;\n\n\tif (*walk == '$' && walk[1] == '{') {\n\t\tin_brace = 1;\n\t\twalk++;\n\t}\n\twalk++;\n\n\tif (*walk >= '0' && *walk <= '9') {\n\t\t*backref = *walk - '0';\n\t\twalk++;\n\t} else\n\t\treturn 0;\n\t\n\tif (*walk && *walk >= '0' && *walk <= '9') {\n\t\t*backref = *backref * 10 + *walk - '0';\n\t\twalk++;\n\t}\n\n\tif (in_brace) {\n\t\tif (*walk == 0 || *walk != '}')\n\t\t\treturn 0;\n\t\telse\n\t\t\twalk++;\n\t}\n\t\n\t*str = walk;\n\treturn 1;\t\n}\n","project":"php","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_BI(fz_context *ctx, pdf_processor *proc, fz_image *image)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_image(ctx, pr, image);\n}\n","project":"ghostscript","target":0},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::setConfig(\n        OMX_INDEXTYPE index, const void *params, size_t size) {\n Mutex::Autolock autoLock(mLock);\n\n     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;\n     CLOG_CONFIG(setConfig, \"%s(%#x), %zu@%p)\", asString(extIndex), index, size, params);\n \n     OMX_ERRORTYPE err = OMX_SetConfig(\n             mHandle, index, const_cast<void *>(params));\n     CLOG_IF_ERROR(setConfig, err, \"%s(%#x)\", asString(extIndex), index);\n return StatusFromOMXError(err);\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Chapters::Edition* Chapters::GetEdition(int idx) const\n{\n    if (idx < 0)\n        return NULL;\n \n    if (idx >= m_editions_count)\n        return NULL;\n \n    return m_editions + idx;\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_x509_export_to_file)\n{\n\tX509 * cert;\n\tzval ** zcert;\n\tzend_bool notext = 1;\n\tBIO * bio_out;\n\tlong certresource;\n\tchar * filename;\n\tint filename_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zs|b\", &zcert, &filename, &filename_len, &notext) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get cert from parameter 1\");\n\t\treturn;\n\t}\n\n\tif (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {\n\t\treturn;\n\t}\n\n\tbio_out = BIO_new_file(filename, \"w\");\n\tif (bio_out) {\n\t\tif (!notext) {\n\t\t\tX509_print(bio_out, cert);\n\t\t}\n\t\tPEM_write_bio_X509(bio_out, cert);\n\n\t\tRETVAL_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error opening file %s\", filename);\n\t}\n\tif (certresource == -1 && cert) {\n\t\tX509_free(cert);\n\t}\n\tBIO_free(bio_out);\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Cluster* Cluster::Create(\n    Segment* pSegment,\n    long idx,\n    long long off)\n{\n    assert(pSegment);\n    assert(off >= 0);\n    const long long element_start = pSegment->m_start + off;\n    Cluster* const pCluster = new Cluster(pSegment,\n                                          idx,\n                                          element_start);\n    assert(pCluster);\n    return pCluster;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int verify_callback(int preverify_ok, X509_STORE_CTX *ctx) \/* {{{ *\/\n{\n\tphp_stream *stream;\n\tSSL *ssl;\n\tX509 *err_cert;\n\tint err, depth, ret;\n\tzval **val;\n\n\tret = preverify_ok;\n\n\t\/* determine the status for the current cert *\/\n\terr_cert = X509_STORE_CTX_get_current_cert(ctx);\n\terr = X509_STORE_CTX_get_error(ctx);\n\tdepth = X509_STORE_CTX_get_error_depth(ctx);\n\n\t\/* conjure the stream & context to use *\/\n\tssl = X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());\n\tstream = (php_stream*)SSL_get_ex_data(ssl, ssl_stream_data_index);\n\n\t\/* if allow_self_signed is set, make sure that verification succeeds *\/\n\tif (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT && GET_VER_OPT(\"allow_self_signed\") && zval_is_true(*val)) {\n\t\tret = 1;\n\t}\n\n\t\/* check the depth *\/\n\tif (GET_VER_OPT(\"verify_depth\")) {\n\t\tconvert_to_long_ex(val);\n\n\t\tif (depth > Z_LVAL_PP(val)) {\n\t\t\tret = 0;\n\t\t\tX509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_CHAIN_TOO_LONG);\n\t\t}\n\t}\n\n\treturn ret;\n\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_cmyk_to_gray(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tint sn = src->n;\n\tint ss = src->s;\n\tint sa = src->alpha;\n\tint dn = dst->n;\n\tint ds = dst->s;\n\tint da = dst->alpha;\n\tptrdiff_t d_line_inc = dst->stride - w * dn;\n\tptrdiff_t s_line_inc = src->stride - w * sn;\n\n\t\/* Spots must match, and we can never drop alpha (but we can invent it) *\/\n\tif ((copy_spots && ss != ds) || (!da && sa))\n\t{\n\t\tassert(\"This should never happen\" == NULL);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Cannot convert between incompatible pixmaps\");\n\t}\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\tif (ss == 0 && ds == 0)\n\t{\n\t\t\/* Common, no spots case *\/\n\t\tif (da)\n\t\t{\n\t\t\tif (sa)\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char c = fz_mul255(s[0], 77);\n\t\t\t\t\t\tunsigned char m = fz_mul255(s[1], 150);\n\t\t\t\t\t\tunsigned char y = fz_mul255(s[2], 28);\n\t\t\t\t\t\td[0] = 255 - (unsigned char)fz_mini(c + m + y + s[3], 255);\n\t\t\t\t\t\td[1] = s[4];\n\t\t\t\t\t\ts += 5;\n\t\t\t\t\t\td += 2;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char c = fz_mul255(s[0], 77);\n\t\t\t\t\t\tunsigned char m = fz_mul255(s[1], 150);\n\t\t\t\t\t\tunsigned char y = fz_mul255(s[2], 28);\n\t\t\t\t\t\td[0] = 255 - (unsigned char)fz_mini(c + m + y + s[3], 255);\n\t\t\t\t\t\td[1] = 255;\n\t\t\t\t\t\ts += 3;\n\t\t\t\t\t\td += 2;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\tunsigned char c = fz_mul255(s[0], 77);\n\t\t\t\t\tunsigned char m = fz_mul255(s[1], 150);\n\t\t\t\t\tunsigned char y = fz_mul255(s[2], 28);\n\t\t\t\t\td[0] = 255 - (unsigned char)fz_mini(c + m + y + s[3], 255);\n\t\t\t\t\ts += 4;\n\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\td += d_line_inc;\n\t\t\t\ts += s_line_inc;\n\t\t\t}\n\t\t}\n\t}\n\telse if (copy_spots)\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\twhile (h--)\n\t\t{\n\t\t\tint i;\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tunsigned char c = fz_mul255(s[0], 77);\n\t\t\t\tunsigned char m = fz_mul255(s[1], 150);\n\t\t\t\tunsigned char y = fz_mul255(s[2], 28);\n\t\t\t\td[0] = 255 - (unsigned char)fz_mini(c + m + y + s[3], 255);\n\t\t\t\ts += 4;\n\t\t\t\td++;\n\t\t\t\tfor (i=ss; i > 0; i--)\n\t\t\t\t\t*d++ = *s++;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = sa ? *s++ : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tunsigned char c = fz_mul255(255 - s[0], 77);\n\t\t\t\tunsigned char m = fz_mul255(255 - s[1], 150);\n\t\t\t\tunsigned char y = fz_mul255(255 - s[2], 28);\n\t\t\t\td[0] = (unsigned char)fz_maxi(s[3] - c - m - y, 0);\n\t\t\t\ts += sn;\n\t\t\t\td += dn;\n\t\t\t\tif (da)\n\t\t\t\t\td[-1] = sa ? s[-1] : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_END(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_flush_text(ctx, pr);\n}\n","project":"ghostscript","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"static int phar_update_cached_entry(void *data, void *argument) \/* {{{ *\/\n{\n\tphar_entry_info *entry = (phar_entry_info *)data;\n\tTSRMLS_FETCH();\n\n\tentry->phar = (phar_archive_data *)argument;\n\n\tif (entry->link) {\n\t\tentry->link = estrdup(entry->link);\n\t}\n\n\tif (entry->tmp) {\n\t\tentry->tmp = estrdup(entry->tmp);\n\t}\n\n\tentry->metadata_str.c = 0;\n\tentry->filename = estrndup(entry->filename, entry->filename_len);\n\tentry->is_persistent = 0;\n\n\tif (entry->metadata) {\n\t\tif (entry->metadata_len) {\n\t\t\tchar *buf = estrndup((char *) entry->metadata, entry->metadata_len);\n\t\t\t\/* assume success, we would have failed before *\/\n\t\t\tphar_parse_metadata((char **) &buf, &entry->metadata, entry->metadata_len TSRMLS_CC);\n\t\t\tefree(buf);\n\t\t} else {\n\t\t\tzval *t;\n\n\t\t\tt = entry->metadata;\n\t\t\tALLOC_ZVAL(entry->metadata);\n\t\t\t*entry->metadata = *t;\n\t\t\tzval_copy_ctor(entry->metadata);\n\t\t\tZ_SET_REFCOUNT_P(entry->metadata, 1);\n\t\t\tentry->metadata_str.c = NULL;\n\t\t\tentry->metadata_str.len = 0;\n\t\t}\n\t}\n\treturn ZEND_HASH_APPLY_KEEP;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"58a6822d7140137ce957c6d2fc20bae1374186c1","func":"void impeg2d_dec_p_mb_params(dec_state_t *ps_dec)\n {\n     stream_t *ps_stream = &ps_dec->s_bit_stream;\n     UWORD16 u2_mb_addr_incr;\n    UWORD16 u2_total_len;\n    UWORD16 u2_len;\n    UWORD16 u2_mb_type;\n    UWORD32 u4_next_word;\n const dec_mb_params_t *ps_dec_mb_params;\n if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n {\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n }\n else\n {\n        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);\n if(0 == ps_dec->u2_first_mb)\n {\n \/****************************************************************\/\n \/* If the 2nd member of a field picture pair is a P picture and *\/\n \/* the first one was an I picture, there cannot be any skipped  *\/\n \/* MBs in the second field picture                              *\/\n \/****************************************************************\/\n \/*\n            if((dec->picture_structure != FRAME_PICTURE) &&\n                (dec->f->FieldFuncCall != 0) &&\n                (dec->las->u1_last_coded_vop_type == I))\n            {\n                core0_err_handler((void *)(VOLParams),\n                    ITTMPEG2_ERR_INVALID_MB_SKIP);\n            }\n            *\/\n \/****************************************************************\/\n \/* In MPEG-2, the last MB of the row cannot be skipped and the  *\/\n \/* MBAddrIncr cannot be such that it will take the current MB   *\/\n \/* beyond the current row                                       *\/\n \/* In MPEG-1, the slice could start and end anywhere and is not *\/\n \/* restricted to a row like in MPEG-2. Hence this check should  *\/\n \/* not be done for MPEG-1 streams.                              *\/\n \/****************************************************************\/\n if(ps_dec->u2_is_mpeg2 && ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb) )\n {\n                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;\n }\n\n            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));\n }\n\n }\n    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);\n \/*-----------------------------------------------------------------------*\/\n \/* MB type                                                               *\/\n \/*-----------------------------------------------------------------------*\/\n {\n        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];\n        u2_len      = BITS(u2_mb_type,15,8);\n        u2_total_len = u2_len;\n        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);\n }\n \/*-----------------------------------------------------------------------*\/\n \/* motion type                                                           *\/\n \/*-----------------------------------------------------------------------*\/\n {\n if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)\n {\n            WORD32 i4_motion_type;\n            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);\n            u2_total_len        += MB_MOTION_TYPE_LEN;\n            u4_next_word        = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);\n            i4_motion_type     = ps_dec->u2_motion_type;\n\n if((i4_motion_type == 0) ||\n (i4_motion_type == 4) ||\n (i4_motion_type > 7))\n {\n                i4_motion_type = 1;\n }\n\n }\n }\n \/*-----------------------------------------------------------------------*\/\n \/* dct type                                                              *\/\n \/*-----------------------------------------------------------------------*\/\n {\n if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)\n {\n            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);\n            u2_total_len += MB_DCT_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);\n }\n }\n \/*-----------------------------------------------------------------------*\/\n \/* Quant scale code                                                      *\/\n \/*-----------------------------------------------------------------------*\/\n if(u2_mb_type & MB_QUANT)\n {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);\n\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n        u2_total_len += MB_QUANT_SCALE_CODE_LEN;\n }\n    impeg2d_bit_stream_flush(ps_stream,u2_total_len);\n \/*-----------------------------------------------------------------------*\/\n \/* Set the function pointers                                             *\/\n \/*-----------------------------------------------------------------------*\/\n    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);\n\n if(u2_mb_type & MB_FORW_OR_BACK)\n {\n\n        UWORD16 refPic      = !(u2_mb_type & MB_MV_FORW);\n        UWORD16 index       = (ps_dec->u2_motion_type);\n        ps_dec->u2_prev_intra_mb    = 0;\n\n         ps_dec->e_mb_pred         = (e_pred_direction_t)refPic;\n         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];\n         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n         ps_dec_mb_params->pf_func_mb_params(ps_dec);\n \n     }\n else if(u2_mb_type & MB_TYPE_INTRA)\n {\n        ps_dec->u2_prev_intra_mb    = 1;\n        impeg2d_dec_intra_mb(ps_dec);\n\n }\n else\n {\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred = FORW;\n        ps_dec->u2_motion_type = 0;\n        impeg2d_dec_0mv_coded_mb(ps_dec);\n }\n\n \/*-----------------------------------------------------------------------*\/\n \/* decode cbp                                                            *\/\n \/*-----------------------------------------------------------------------*\/\n if((u2_mb_type & MB_TYPE_INTRA))\n {\n        ps_dec->u2_cbp  = 0x3f;\n        ps_dec->u2_prev_intra_mb    = 1;\n }\n else\n {\n        ps_dec->u2_prev_intra_mb  = 0;\n        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n if((ps_dec->u2_coded_mb))\n {\n            UWORD16 cbpValue;\n            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];\n            ps_dec->u2_cbp  = cbpValue & 0xFF;\n            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);\n }\n else\n {\n\n             ps_dec->u2_cbp  = 0;\n         }\n     }\n }\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_FUNCTION(preg_filter)\n{\n\tpreg_replace_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 1);\n}\n","project":"php","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"PHPAPI char *php_pcre_replace_impl(pcre_cache_entry *pce, char *subject, int subject_len, zval *replace_val, \n\tint is_callable_replace, int *result_len, int limit, int *replace_count TSRMLS_DC)\n{\n\tpcre_extra\t\t*extra = pce->extra;\/* Holds results of studying *\/\n\tpcre_extra\t\t extra_data;\t\t\/* Used locally for exec options *\/\n\tint\t\t\t\t exoptions = 0;\t\t\/* Execution options *\/\n\tint\t\t\t\t count = 0;\t\t\t\/* Count of matched subpatterns *\/\n\tint\t\t\t\t*offsets;\t\t\t\/* Array of subpattern offsets *\/\n\tchar \t\t\t**subpat_names;\t\t\/* Array for named subpatterns *\/\n\tint\t\t\t\t num_subpats;\t\t\/* Number of captured subpatterns *\/\n\tint\t\t\t\t size_offsets;\t\t\/* Size of the offsets array *\/\n\tint\t\t\t\t new_len;\t\t\t\/* Length of needed storage *\/\n\tint\t\t\t\t alloc_len;\t\t\t\/* Actual allocated length *\/\n\tint\t\t\t\t eval_result_len=0;\t\/* Length of the eval'ed or\n\t\t\t\t\t\t\t\t\t\t   function-returned string *\/\n\tint\t\t\t\t match_len;\t\t\t\/* Length of the current match *\/\n\tint\t\t\t\t backref;\t\t\t\/* Backreference number *\/\n\tint\t\t\t\t eval;\t\t\t\t\/* If the replacement string should be eval'ed *\/\n\tint\t\t\t\t start_offset;\t\t\/* Where the new search starts *\/\n\tint\t\t\t\t g_notempty=0;\t\t\/* If the match should not be empty *\/\n\tint\t\t\t\t replace_len=0;\t\t\/* Length of replacement string *\/\n\tchar\t\t\t*result,\t\t\t\/* Result of replacement *\/\n\t\t\t\t\t*replace=NULL,\t\t\/* Replacement string *\/\n\t\t\t\t\t*new_buf,\t\t\t\/* Temporary buffer for re-allocation *\/\n\t\t\t\t\t*walkbuf,\t\t\t\/* Location of current replacement in the result *\/\n\t\t\t\t\t*walk,\t\t\t\t\/* Used to walk the replacement string *\/\n\t\t\t\t\t*match,\t\t\t\t\/* The current match *\/\n\t\t\t\t\t*piece,\t\t\t\t\/* The current piece of subject *\/\n\t\t\t\t\t*replace_end=NULL,\t\/* End of replacement string *\/\n\t\t\t\t\t*eval_result,\t\t\/* Result of eval or custom function *\/\n\t\t\t\t\t walk_last;\t\t\t\/* Last walked character *\/\n\tint\t\t\t\t rc;\n\n\tif (extra == NULL) {\n\t\textra_data.flags = PCRE_EXTRA_MATCH_LIMIT | PCRE_EXTRA_MATCH_LIMIT_RECURSION;\n\t\textra = &extra_data;\n\t}\n\textra->match_limit = PCRE_G(backtrack_limit);\n\textra->match_limit_recursion = PCRE_G(recursion_limit);\n\n\teval = pce->preg_options & PREG_REPLACE_EVAL;\n\tif (is_callable_replace) {\n\t\tif (eval) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Modifier \/e cannot be used with replacement callback\");\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\treplace = Z_STRVAL_P(replace_val);\n\t\treplace_len = Z_STRLEN_P(replace_val);\n\t\treplace_end = replace + replace_len;\n\t}\n\n\t\/* Calculate the size of the offsets array, and allocate memory for it. *\/\n\trc = pcre_fullinfo(pce->re, extra, PCRE_INFO_CAPTURECOUNT, &num_subpats);\n\tif (rc < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Internal pcre_fullinfo() error %d\", rc);\n\t\treturn NULL;\n\t}\n\tnum_subpats++;\n\tsize_offsets = num_subpats * 3;\n\n\t\/*\n\t * Build a mapping from subpattern numbers to their names. We will always\n\t * allocate the table, even though there may be no named subpatterns. This\n\t * avoids somewhat more complicated logic in the inner loops.\n\t *\/\n\tsubpat_names = make_subpats_table(num_subpats, pce TSRMLS_CC);\n\tif (!subpat_names) {\n\t\treturn NULL;\n\t}\n\n\toffsets = (int *)safe_emalloc(size_offsets, sizeof(int), 0);\n\t\n\talloc_len = 2 * subject_len + 1;\n\tresult = safe_emalloc(alloc_len, sizeof(char), 0);\n\n\t\/* Initialize *\/\n\tmatch = NULL;\n\t*result_len = 0;\n\tstart_offset = 0;\n\tPCRE_G(error_code) = PHP_PCRE_NO_ERROR;\n\t\n\twhile (1) {\n\t\t\/* Execute the regular expression. *\/\n\t\tcount = pcre_exec(pce->re, extra, subject, subject_len, start_offset,\n\t\t\t\t\t\t  exoptions|g_notempty, offsets, size_offsets);\n\n\t\t\/* the string was already proved to be valid UTF-8 *\/\n\t\texoptions |= PCRE_NO_UTF8_CHECK;\n\n\t\t\/* Check for too many substrings condition. *\/\n\t\tif (count == 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC,E_NOTICE, \"Matched, but too many substrings\");\n\t\t\tcount = size_offsets\/3;\n\t\t}\n\n\t\tpiece = subject + start_offset;\n\n\t\tif (count > 0 && (limit == -1 || limit > 0)) {\n\t\t\tif (replace_count) {\n\t\t\t\t++*replace_count;\n\t\t\t}\n\t\t\t\/* Set the match location in subject *\/\n\t\t\tmatch = subject + offsets[0];\n\n\t\t\tnew_len = *result_len + offsets[0] - start_offset; \/* part before the match *\/\n\t\t\t\n\t\t\t\/* If evaluating, do it and add the return string's length *\/\n\t\t\tif (eval) {\n\t\t\t\teval_result_len = preg_do_eval(replace, replace_len, subject,\n\t\t\t\t\t\t\t\t\t\t\t   offsets, count, &eval_result TSRMLS_CC);\n\t\t\t\tnew_len += eval_result_len;\n\t\t\t} else if (is_callable_replace) {\n\t\t\t\t\/* Use custom function to get replacement string and its length. *\/\n\t\t\t\teval_result_len = preg_do_repl_func(replace_val, subject, offsets, subpat_names, count, &eval_result TSRMLS_CC);\n\t\t\t\tnew_len += eval_result_len;\n\t\t\t} else { \/* do regular substitution *\/\n\t\t\t\twalk = replace;\n\t\t\t\twalk_last = 0;\n\t\t\t\twhile (walk < replace_end) {\n\t\t\t\t\tif ('\\\\' == *walk || '$' == *walk) {\n\t\t\t\t\t\tif (walk_last == '\\\\') {\n\t\t\t\t\t\t\twalk++;\n\t\t\t\t\t\t\twalk_last = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preg_get_backref(&walk, &backref)) {\n\t\t\t\t\t\t\tif (backref < count)\n\t\t\t\t\t\t\t\tnew_len += offsets[(backref<<1)+1] - offsets[backref<<1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnew_len++;\n\t\t\t\t\twalk++;\n\t\t\t\t\twalk_last = walk[-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_len + 1 > alloc_len) {\n\t\t\t\talloc_len = 1 + alloc_len + 2 * new_len;\n\t\t\t\tnew_buf = emalloc(alloc_len);\n\t\t\t\tmemcpy(new_buf, result, *result_len);\n\t\t\t\tefree(result);\n\t\t\t\tresult = new_buf;\n\t\t\t}\n\t\t\t\/* copy the part of the string before the match *\/\n\t\t\tmemcpy(&result[*result_len], piece, match-piece);\n\t\t\t*result_len += match-piece;\n\n\t\t\t\/* copy replacement and backrefs *\/\n\t\t\twalkbuf = result + *result_len;\n\t\t\t\n\t\t\t\/* If evaluating or using custom function, copy result to the buffer\n\t\t\t * and clean up. *\/\n\t\t\tif (eval || is_callable_replace) {\n\t\t\t\tmemcpy(walkbuf, eval_result, eval_result_len);\n\t\t\t\t*result_len += eval_result_len;\n\t\t\t\tSTR_FREE(eval_result);\n\t\t\t} else { \/* do regular backreference copying *\/\n\t\t\t\twalk = replace;\n\t\t\t\twalk_last = 0;\n\t\t\t\twhile (walk < replace_end) {\n\t\t\t\t\tif ('\\\\' == *walk || '$' == *walk) {\n\t\t\t\t\t\tif (walk_last == '\\\\') {\n\t\t\t\t\t\t\t*(walkbuf-1) = *walk++;\n\t\t\t\t\t\t\twalk_last = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preg_get_backref(&walk, &backref)) {\n\t\t\t\t\t\t\tif (backref < count) {\n\t\t\t\t\t\t\t\tmatch_len = offsets[(backref<<1)+1] - offsets[backref<<1];\n\t\t\t\t\t\t\t\tmemcpy(walkbuf, subject + offsets[backref<<1], match_len);\n\t\t\t\t\t\t\t\twalkbuf += match_len;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*walkbuf++ = *walk++;\n\t\t\t\t\twalk_last = walk[-1];\n\t\t\t\t}\n\t\t\t\t*walkbuf = '\\0';\n\t\t\t\t\/* increment the result length by how much we've added to the string *\/\n\t\t\t\t*result_len += walkbuf - (result + *result_len);\n\t\t\t}\n\n\t\t\tif (limit != -1)\n\t\t\t\tlimit--;\n\n\t\t} else if (count == PCRE_ERROR_NOMATCH || limit == 0) {\n\t\t\t\/* If we previously set PCRE_NOTEMPTY after a null match,\n\t\t\t   this is not necessarily the end. We need to advance\n\t\t\t   the start offset, and continue. Fudge the offset values\n\t\t\t   to achieve this, unless we're already at the end of the string. *\/\n\t\t\tif (g_notempty != 0 && start_offset < subject_len) {\n\t\t\t\toffsets[0] = start_offset;\n\t\t\t\toffsets[1] = start_offset + 1;\n\t\t\t\tmemcpy(&result[*result_len], piece, 1);\n\t\t\t\t(*result_len)++;\n\t\t\t} else {\n\t\t\t\tnew_len = *result_len + subject_len - start_offset;\n\t\t\t\tif (new_len + 1 > alloc_len) {\n\t\t\t\t\talloc_len = new_len + 1; \/* now we know exactly how long it is *\/\n\t\t\t\t\tnew_buf = safe_emalloc(alloc_len, sizeof(char), 0);\n\t\t\t\t\tmemcpy(new_buf, result, *result_len);\n\t\t\t\t\tefree(result);\n\t\t\t\t\tresult = new_buf;\n\t\t\t\t}\n\t\t\t\t\/* stick that last bit of string on our output *\/\n\t\t\t\tmemcpy(&result[*result_len], piece, subject_len - start_offset);\n\t\t\t\t*result_len += subject_len - start_offset;\n\t\t\t\tresult[*result_len] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpcre_handle_exec_error(count TSRMLS_CC);\n\t\t\tefree(result);\n\t\t\tresult = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t\t\n\t\t\/* If we have matched an empty string, mimic what Perl's \/g options does.\n\t\t   This turns out to be rather cunning. First we set PCRE_NOTEMPTY and try\n\t\t   the match again at the same point. If this fails (picked up above) we\n\t\t   advance to the next character. *\/\n\t\tg_notempty = (offsets[1] == offsets[0])? PCRE_NOTEMPTY | PCRE_ANCHORED : 0;\n\t\t\n\t\t\/* Advance to the next piece. *\/\n\t\tstart_offset = offsets[1];\n\t}\n\n\tefree(offsets);\n\tefree(subpat_names);\n\n\treturn result;\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_device(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->flags & FZ_COLORSPACE_IS_DEVICE);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Block* SimpleBlock::GetBlock() const\n{\n    return &m_block;\n}\n","project":"Android","target":1},{"commit_id":"45737cb776625f17384540523674761e6313e6d4","func":"SampleTable::SampleTable(const sp<DataSource> &source)\n : mDataSource(source),\n      mChunkOffsetOffset(-1),\n      mChunkOffsetType(0),\n      mNumChunkOffsets(0),\n      mSampleToChunkOffset(-1),\n      mNumSampleToChunkOffsets(0),\n      mSampleSizeOffset(-1),\n      mSampleSizeFieldSize(0),\n\n       mDefaultSampleSize(0),\n       mNumSampleSizes(0),\n       mTimeToSampleCount(0),\n      mTimeToSample(NULL),\n       mSampleTimeEntries(NULL),\n       mCompositionTimeDeltaEntries(NULL),\n       mNumCompositionTimeDeltaEntries(0),\n      mCompositionDeltaLookup(new CompositionDeltaLookup),\n      mSyncSampleOffset(-1),\n      mNumSyncSamples(0),\n      mSyncSamples(NULL),\n      mLastSyncSampleIndex(0),\n      mSampleToChunkEntries(NULL) {\n    mSampleIterator = new SampleIterator(this);\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Chapters::Edition::Parse(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    const long long stop = pos + size;\n \n    while (pos < stop)\n    {\n        long long id, size;\n \n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n \n        if (status < 0)  \/\/ error\n            return status;\n \n        if (size == 0)  \/\/ weird\n            continue;\n \n        if (id == 0x36)  \/\/ Atom ID\n        {\n            status = ParseAtom(pReader, pos, size);\n \n            if (status < 0)  \/\/ error\n                return status;\n        }\n \n        pos += size;\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n    return 0;\n }\n","project":"Android","target":1},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"void help(void)\n{\n\tprintf(_(\"%s %s -- get file access control lists\\n\"),\n\t       progname, VERSION);\n\tprintf(_(\"Usage: %s [-%s] file ...\\n\"),\n\t         progname, cmd_line_options);\n#if !POSIXLY_CORRECT\n\tif (posixly_correct) {\n#endif\n\t\tprintf(_(\n\"  -d, --default           display the default access control list\\n\"));\n#if !POSIXLY_CORRECT\n\t} else {\n\t\tprintf(_(\n\"  -a,  --access           display the file access control list only\\n\"\n\"  -d, --default           display the default access control list only\\n\"\n\"  -c, --omit-header       do not display the comment header\\n\"\n\"  -e, --all-effective     print all effective rights\\n\"\n\"  -E, --no-effective      print no effective rights\\n\"\n\"  -s, --skip-base         skip files that only have the base entries\\n\"\n\"  -R, --recursive         recurse into subdirectories\\n\"\n\"  -L, --logical           logical walk, follow symbolic links\\n\"\n\"  -P, --physical          physical walk, do not follow symbolic links\\n\"\n\"  -t, --tabular           use tabular output format\\n\"\n\"  -n, --numeric           print numeric user\/group identifiers\\n\"\n\"  -p, --absolute-names    don't strip leading '\/' in pathnames\\n\"));\n\t}\n#endif\n\tprintf(_(\n\"  -v, --version           print version and exit\\n\"\n\"  -h, --help              this help text\\n\"));\n}\n","project":"savannah","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftOpus::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch ((int)index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.opus\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAndroidOpus:\n {\n\n             const OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *opusParams =\n                 (const OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *)params;\n \n             if (opusParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_cmm_transform_pixmap(fz_context *ctx, fz_icclink *link, fz_pixmap *dst, fz_pixmap *src)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tctx->colorspace->cmm->transform_pixmap(ctx->cmm_instance, link, dst, src);\n}\n","project":"ghostscript","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"static void phar_copy_cached_phar(phar_archive_data **pphar TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_archive_data *phar;\n\tHashTable newmanifest;\n\tchar *fname;\n\tphar_archive_object **objphar;\n\n\tphar = (phar_archive_data *) emalloc(sizeof(phar_archive_data));\n\t*phar = **pphar;\n\tphar->is_persistent = 0;\n\tfname = phar->fname;\n\tphar->fname = estrndup(phar->fname, phar->fname_len);\n\tphar->ext = phar->fname + (phar->ext - fname);\n\n\tif (phar->alias) {\n\t\tphar->alias = estrndup(phar->alias, phar->alias_len);\n\t}\n\n\tif (phar->signature) {\n\t\tphar->signature = estrdup(phar->signature);\n\t}\n\n\tif (phar->metadata) {\n\t\t\/* assume success, we would have failed before *\/\n\t\tif (phar->metadata_len) {\n\t\t\tchar *buf = estrndup((char *) phar->metadata, phar->metadata_len);\n\t\t\tphar_parse_metadata(&buf, &phar->metadata, phar->metadata_len TSRMLS_CC);\n\t\t\tefree(buf);\n\t\t} else {\n\t\t\tzval *t;\n\n\t\t\tt = phar->metadata;\n\t\t\tALLOC_ZVAL(phar->metadata);\n\t\t\t*phar->metadata = *t;\n\t\t\tzval_copy_ctor(phar->metadata);\n\t\t\tZ_SET_REFCOUNT_P(phar->metadata, 1);\n\t\t}\n\t}\n\n\tzend_hash_init(&newmanifest, sizeof(phar_entry_info),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, 0);\n\tzend_hash_copy(&newmanifest, &(*pphar)->manifest, NULL, NULL, sizeof(phar_entry_info));\n\tzend_hash_apply_with_argument(&newmanifest, (apply_func_arg_t) phar_update_cached_entry, (void *)phar TSRMLS_CC);\n\tphar->manifest = newmanifest;\n\tzend_hash_init(&phar->mounted_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_init(&phar->virtual_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_copy(&phar->virtual_dirs, &(*pphar)->virtual_dirs, NULL, NULL, sizeof(void *));\n\t*pphar = phar;\n\n\t\/* now, scan the list of persistent Phar objects referencing this phar and update the pointers *\/\n\tfor (zend_hash_internal_pointer_reset(&PHAR_GLOBALS->phar_persist_map);\n\tSUCCESS == zend_hash_get_current_data(&PHAR_GLOBALS->phar_persist_map, (void **) &objphar);\n\tzend_hash_move_forward(&PHAR_GLOBALS->phar_persist_map)) {\n\t\tif (objphar[0]->arc.archive->fname_len == phar->fname_len && !memcmp(objphar[0]->arc.archive->fname, phar->fname, phar->fname_len)) {\n\t\t\tobjphar[0]->arc.archive = phar;\n\t\t}\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_as4_path (struct bgp_attr_parser_args *args, struct aspath **as4_path)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  *as4_path = aspath_parse (peer->ibuf, length, 1);\n\n  \/* In case of IBGP, length will be zero. *\/\n  if (!*as4_path)\n    {\n      zlog (peer->log, LOG_ERR,\n            \"Malformed AS4 path from %s, length is %d\",\n            peer->host, length);\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_MAL_AS_PATH,\n                                 0);\n    }\n\n  \/* Set aspath attribute flag. *\/\n  if (as4_path)\n    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS4_PATH);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_ext_communities (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer;  \n  struct attr *const attr = args->attr;  \n  const bgp_size_t length = args->length;\n  \n  if (length == 0)\n    {\n      if (attr->extra)\n        attr->extra->ecommunity = NULL;\n      \/* Empty extcomm doesn't seem to be invalid per se *\/\n      return BGP_ATTR_PARSE_PROCEED;\n    }\n\n  (bgp_attr_extra_get (attr))->ecommunity =\n    ecommunity_parse ((u_int8_t *)stream_pnt (peer->ibuf), length);\n  \/* XXX: fix ecommunity_parse to use stream API *\/\n  stream_forward_getp (peer->ibuf, length);\n  \n  if (!attr->extra->ecommunity)\n    return bgp_attr_malformed (args,\n                               BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,\n                               args->total);\n  \n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_end_group(fz_context *ctx, pdf_run_processor *pr, softmask_save *softmask)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\n\tif (gstate->blendmode)\n\t\tfz_end_group(ctx, pr->dev);\n\n\tend_softmask(ctx, pr, softmask);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" void EncoderTest::RunLoop(VideoSource *video) {\n  vpx_codec_dec_cfg_t dec_cfg = {0};\n \n   stats_.Reset();\n \n  ASSERT_TRUE(passes_ == 1 || passes_ == 2);\n for (unsigned int pass = 0; pass < passes_; pass++) {\n    last_pts_ = 0;\n\n if (passes_ == 1)\n      cfg_.g_pass = VPX_RC_ONE_PASS;\n else if (pass == 0)\n      cfg_.g_pass = VPX_RC_FIRST_PASS;\n else\n      cfg_.g_pass = VPX_RC_LAST_PASS;\n\n BeginPassHook(pass);\n\n     Encoder* const encoder = codec_->CreateEncoder(cfg_, deadline_, init_flags_,\n                                                    &stats_);\n     ASSERT_TRUE(encoder != NULL);\n    Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);\n     bool again;\n    for (again = true, video->Begin(); again; video->Next()) {\n       again = (video->img() != NULL);\n \n       PreEncodeFrameHook(video);\n PreEncodeFrameHook(video, encoder);\n      encoder->EncodeFrame(video, frame_flags_);\n\n CxDataIterator iter = encoder->GetCxData();\n\n bool has_cxdata = false;\n bool has_dxdata = false;\n while (const vpx_codec_cx_pkt_t *pkt = iter.Next()) {\n        pkt = MutateEncoderOutputHook(pkt);\n        again = true;\n switch (pkt->kind) {\n case VPX_CODEC_CX_FRAME_PKT:\n            has_cxdata = true;\n\n             if (decoder && DoDecode()) {\n               vpx_codec_err_t res_dec = decoder->DecodeFrame(\n                   (const uint8_t*)pkt->data.frame.buf, pkt->data.frame.sz);\n              ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n               has_dxdata = true;\n             }\n             ASSERT_GE(pkt->data.frame.pts, last_pts_);\n            last_pts_ = pkt->data.frame.pts;\n FramePktHook(pkt);\n break;\n\n case VPX_CODEC_PSNR_PKT:\n PSNRPktHook(pkt);\n break;\n\n default:\n break;\n\n         }\n       }\n \n       if (has_dxdata && has_cxdata) {\n         const vpx_image_t *img_enc = encoder->GetPreviewFrame();\n         DxDataIterator dec_iter = decoder->GetDxData();\n const vpx_image_t *img_dec = dec_iter.Next();\n if (img_enc && img_dec) {\n const bool res = compare_img(img_enc, img_dec);\n if (!res) { \/\/ Mismatch\n MismatchHook(img_enc, img_dec);\n }\n }\n if (img_dec)\n DecompressedFrameHook(*img_dec, video->pts());\n }\n if (!Continue())\n break;\n }\n\n EndPassHook();\n\n if (decoder)\n delete decoder;\n delete encoder;\n\n if (!Continue())\n break;\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const unsigned char* Track::GetCodecPrivate(size_t& size) const\n{\n    size = m_info.codecPrivateSize;\n    return m_info.codecPrivate;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"unsigned long Segment::GetCount() const\n{\n    return m_clusterCount;\n}\n","project":"Android","target":1},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"const SSL_CIPHER *ssl3_get_cipher(unsigned int u)\n\t{\n\tif (u < SSL3_NUM_CIPHERS)\n\t\treturn(&(ssl3_ciphers[SSL3_NUM_CIPHERS-1-u]));\n\telse\n\t\treturn(NULL);\n\t}\n","project":"openssl","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"ContentEncoding::GetEncryptionByIndex(unsigned long idx) const {\n   const ptrdiff_t count = encryption_entries_end_ - encryption_entries_;\n   assert(count >= 0);\n \n if (idx >= static_cast<unsigned long>(count))\n return NULL;\n\n return encryption_entries_[idx];\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_colorspace_name_colorant(fz_context *ctx, fz_colorspace *cs, int i, const char *name)\n{\n\tif (!cs)\n\t\treturn;\n\n\tif (i < 0 || i >= cs->n)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Attempt to name out of range colorant\");\n\n\tfz_free(ctx, cs->colorant[i]);\n\tcs->colorant[i] = NULL;\n\tif (name)\n\t{\n\t\tcs->colorant[i] = fz_strdup(ctx, name);\n\n\t\tif (cs->type == FZ_COLORSPACE_SEPARATION)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tif (strcmp(name, \"Cyan\") == 0 ||\n\t\t\t\t\tstrcmp(name, \"Magenta\") == 0 ||\n\t\t\t\t\tstrcmp(name, \"Yellow\") == 0 ||\n\t\t\t\t\tstrcmp(name, \"Black\") == 0)\n\t\t\t\t{\n\t\t\t\t\tcs->flags |= FZ_CS_HAS_CMYK;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((cs->flags & FZ_CS_HAS_CMYK_AND_SPOTS) != FZ_CS_HAS_CMYK_AND_SPOTS)\n\t\t\t\t{\n\t\t\t\t\tif (strcmp(name, \"Cyan\") == 0 ||\n\t\t\t\t\t\tstrcmp(name, \"Magenta\") == 0 ||\n\t\t\t\t\t\tstrcmp(name, \"Yellow\") == 0 ||\n\t\t\t\t\t\tstrcmp(name, \"Black\") == 0)\n\t\t\t\t\t\tcs->flags |= FZ_CS_HAS_CMYK;\n\t\t\t\t\telse\n\t\t\t\t\t\tcs->flags |= FZ_CS_HAS_SPOTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"03a53d1c7765eeb3af0bc34c3dff02ada1953fbf","func":"int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,\n const MotionEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime,\n bool* outConflictingPointerActions) {\n enum InjectionPermission {\n        INJECTION_PERMISSION_UNKNOWN,\n        INJECTION_PERMISSION_GRANTED,\n        INJECTION_PERMISSION_DENIED\n };\n\n nsecs_t startTime = now();\n\n int32_t displayId = entry->displayId;\n int32_t action = entry->action;\n int32_t maskedAction = action & AMOTION_EVENT_ACTION_MASK;\n\n int32_t injectionResult = INPUT_EVENT_INJECTION_PENDING;\n InjectionPermission injectionPermission = INJECTION_PERMISSION_UNKNOWN;\n    sp<InputWindowHandle> newHoverWindowHandle;\n\n const TouchState* oldState = NULL;\n ssize_t oldStateIndex = mTouchStatesByDisplay.indexOfKey(displayId);\n if (oldStateIndex >= 0) {\n        oldState = &mTouchStatesByDisplay.valueAt(oldStateIndex);\n        mTempTouchState.copyFrom(*oldState);\n }\n\n bool isSplit = mTempTouchState.split;\n bool switchedDevice = mTempTouchState.deviceId >= 0 && mTempTouchState.displayId >= 0\n && (mTempTouchState.deviceId != entry->deviceId\n || mTempTouchState.source != entry->source\n || mTempTouchState.displayId != displayId);\n bool isHoverAction = (maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE\n || maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n || maskedAction == AMOTION_EVENT_ACTION_HOVER_EXIT);\n bool newGesture = (maskedAction == AMOTION_EVENT_ACTION_DOWN\n || maskedAction == AMOTION_EVENT_ACTION_SCROLL\n || isHoverAction);\n bool wrongDevice = false;\n if (newGesture) {\n bool down = maskedAction == AMOTION_EVENT_ACTION_DOWN;\n if (switchedDevice && mTempTouchState.down && !down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because a pointer for a different device is already down.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n            switchedDevice = false;\n            wrongDevice = true;\n goto Failed;\n }\n        mTempTouchState.reset();\n        mTempTouchState.down = down;\n        mTempTouchState.deviceId = entry->deviceId;\n        mTempTouchState.source = entry->source;\n        mTempTouchState.displayId = displayId;\n        isSplit = false;\n }\n\n if (newGesture || (isSplit && maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) {\n \/* Case 1: New splittable pointer going down, or need target for hover or scroll. *\/\n\n int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n int32_t x = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_X));\n int32_t y = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_Y));\n        sp<InputWindowHandle> newTouchedWindowHandle;\n bool isTouchModal = false;\n\n size_t numWindows = mWindowHandles.size();\n for (size_t i = 0; i < numWindows; i++) {\n            sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n const InputWindowInfo* windowInfo = windowHandle->getInfo();\n if (windowInfo->displayId != displayId) {\n continue; \/\/ wrong display\n }\n\n int32_t flags = windowInfo->layoutParamsFlags;\n if (windowInfo->visible) {\n if (! (flags & InputWindowInfo::FLAG_NOT_TOUCHABLE)) {\n                    isTouchModal = (flags & (InputWindowInfo::FLAG_NOT_FOCUSABLE\n | InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == 0;\n if (isTouchModal || windowInfo->touchableRegionContainsPoint(x, y)) {\n                        newTouchedWindowHandle = windowHandle;\n break; \/\/ found touched window, exit window loop\n }\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_DOWN\n && (flags & InputWindowInfo::FLAG_WATCH_OUTSIDE_TOUCH)) {\n\n                     int32_t outsideTargetFlags = InputTarget::FLAG_DISPATCH_AS_OUTSIDE;\n                     if (isWindowObscuredAtPointLocked(windowHandle, x, y)) {\n                         outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n                     }\n \n                     mTempTouchState.addOrUpdateWindow(\n                            windowHandle, outsideTargetFlags, BitSet32(0));\n }\n }\n }\n\n if (newTouchedWindowHandle != NULL\n && newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n            isSplit = true;\n } else if (isSplit) {\n            newTouchedWindowHandle = NULL;\n }\n\n if (newTouchedWindowHandle == NULL) {\n            newTouchedWindowHandle = mTempTouchState.getFirstForegroundWindowHandle();\n if (newTouchedWindowHandle == NULL) {\n                ALOGI(\"Dropping event because there is no touchable window at (%d, %d).\", x, y);\n                injectionResult = INPUT_EVENT_INJECTION_FAILED;\n goto Failed;\n }\n }\n\n int32_t targetFlags = InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS;\n if (isSplit) {\n            targetFlags |= InputTarget::FLAG_SPLIT;\n\n         }\n         if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n             targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n         }\n \n if (isHoverAction) {\n            newHoverWindowHandle = newTouchedWindowHandle;\n } else if (maskedAction == AMOTION_EVENT_ACTION_SCROLL) {\n            newHoverWindowHandle = mLastHoverWindowHandle;\n }\n\n BitSet32 pointerIds;\n if (isSplit) {\n uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n            pointerIds.markBit(pointerId);\n }\n        mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n } else {\n \/* Case 2: Pointer move, up, cancel or non-splittable pointer down. *\/\n\n if (! mTempTouchState.down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because the pointer is not down or we previously \"\n \"dropped the pointer down event.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n goto Failed;\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_MOVE\n && entry->pointerCount == 1\n && mTempTouchState.isSlippery()) {\n int32_t x = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_X));\n int32_t y = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_Y));\n\n            sp<InputWindowHandle> oldTouchedWindowHandle =\n                    mTempTouchState.getFirstForegroundWindowHandle();\n            sp<InputWindowHandle> newTouchedWindowHandle =\n                    findTouchedWindowAtLocked(displayId, x, y);\n if (oldTouchedWindowHandle != newTouchedWindowHandle\n && newTouchedWindowHandle != NULL) {\n#if DEBUG_FOCUS\n                ALOGD(\"Touch is slipping out of window %s into window %s.\",\n                        oldTouchedWindowHandle->getName().string(),\n                        newTouchedWindowHandle->getName().string());\n#endif\n                mTempTouchState.addOrUpdateWindow(oldTouchedWindowHandle,\n InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT, BitSet32(0));\n\n if (newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n                    isSplit = true;\n }\n\n int32_t targetFlags = InputTarget::FLAG_FOREGROUND\n | InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER;\n if (isSplit) {\n                    targetFlags |= InputTarget::FLAG_SPLIT;\n }\n if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n                    targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n }\n\n BitSet32 pointerIds;\n if (isSplit) {\n                    pointerIds.markBit(entry->pointerProperties[0].id);\n }\n                mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n }\n }\n }\n\n if (newHoverWindowHandle != mLastHoverWindowHandle) {\n if (mLastHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover exit event to window %s.\",\n                    mLastHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(mLastHoverWindowHandle,\n InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT, BitSet32(0));\n }\n\n if (newHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover enter event to window %s.\",\n                    newHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(newHoverWindowHandle,\n InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER, BitSet32(0));\n }\n }\n\n {\n bool haveForegroundWindow = false;\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n                haveForegroundWindow = true;\n if (! checkInjectionPermission(touchedWindow.windowHandle,\n                        entry->injectionState)) {\n                    injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;\n                    injectionPermission = INJECTION_PERMISSION_DENIED;\n goto Failed;\n }\n }\n }\n if (! haveForegroundWindow) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because there is no touched foreground window to receive it.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n goto Failed;\n }\n\n        injectionPermission = INJECTION_PERMISSION_GRANTED;\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n const int32_t foregroundWindowUid = foregroundWindowHandle->getInfo()->ownerUid;\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n if (touchedWindow.targetFlags & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {\n                sp<InputWindowHandle> inputWindowHandle = touchedWindow.windowHandle;\n if (inputWindowHandle->getInfo()->ownerUid != foregroundWindowUid) {\n                    mTempTouchState.addOrUpdateWindow(inputWindowHandle,\n InputTarget::FLAG_ZERO_COORDS, BitSet32(0));\n }\n }\n }\n }\n\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n String8 reason = checkWindowReadyForMoreInputLocked(currentTime,\n                    touchedWindow.windowHandle, entry, \"touched\");\n if (!reason.isEmpty()) {\n                injectionResult = handleTargetsNotReadyLocked(currentTime, entry,\n                        NULL, touchedWindow.windowHandle, nextWakeupTime, reason.string());\n goto Unresponsive;\n }\n }\n }\n\n if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n if (foregroundWindowHandle->getInfo()->hasWallpaper) {\n for (size_t i = 0; i < mWindowHandles.size(); i++) {\n                sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n const InputWindowInfo* info = windowHandle->getInfo();\n if (info->displayId == displayId\n && windowHandle->getInfo()->layoutParamsType\n\n                                 == InputWindowInfo::TYPE_WALLPAPER) {\n                     mTempTouchState.addOrUpdateWindow(windowHandle,\n                             InputTarget::FLAG_WINDOW_IS_OBSCURED\n                                     | InputTarget::FLAG_DISPATCH_AS_IS,\n                             BitSet32(0));\n                 }\n }\n }\n }\n\n    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;\n\n for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n const TouchedWindow& touchedWindow = mTempTouchState.windows.itemAt(i);\n        addWindowTargetLocked(touchedWindow.windowHandle, touchedWindow.targetFlags,\n                touchedWindow.pointerIds, inputTargets);\n }\n\n    mTempTouchState.filterNonAsIsTouchWindows();\n\nFailed:\n if (injectionPermission == INJECTION_PERMISSION_UNKNOWN) {\n if (checkInjectionPermission(NULL, entry->injectionState)) {\n            injectionPermission = INJECTION_PERMISSION_GRANTED;\n } else {\n            injectionPermission = INJECTION_PERMISSION_DENIED;\n }\n }\n\n if (injectionPermission == INJECTION_PERMISSION_GRANTED) {\n if (!wrongDevice) {\n if (switchedDevice) {\n#if DEBUG_FOCUS\n                ALOGD(\"Conflicting pointer actions: Switched to a different device.\");\n#endif\n *outConflictingPointerActions = true;\n }\n\n if (isHoverAction) {\n if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Hover received while pointer was down.\");\n#endif\n *outConflictingPointerActions = true;\n }\n                mTempTouchState.reset();\n if (maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n || maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE) {\n                    mTempTouchState.deviceId = entry->deviceId;\n                    mTempTouchState.source = entry->source;\n                    mTempTouchState.displayId = displayId;\n }\n } else if (maskedAction == AMOTION_EVENT_ACTION_UP\n || maskedAction == AMOTION_EVENT_ACTION_CANCEL) {\n                mTempTouchState.reset();\n } else if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Down received while already down.\");\n#endif\n *outConflictingPointerActions = true;\n }\n } else if (maskedAction == AMOTION_EVENT_ACTION_POINTER_UP) {\n if (isSplit) {\n int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n\n for (size_t i = 0; i < mTempTouchState.windows.size(); ) {\n TouchedWindow& touchedWindow = mTempTouchState.windows.editItemAt(i);\n if (touchedWindow.targetFlags & InputTarget::FLAG_SPLIT) {\n                            touchedWindow.pointerIds.clearBit(pointerId);\n if (touchedWindow.pointerIds.isEmpty()) {\n                                mTempTouchState.windows.removeAt(i);\n continue;\n }\n }\n                        i += 1;\n }\n }\n }\n\n if (maskedAction != AMOTION_EVENT_ACTION_SCROLL) {\n if (mTempTouchState.displayId >= 0) {\n if (oldStateIndex >= 0) {\n                        mTouchStatesByDisplay.editValueAt(oldStateIndex).copyFrom(mTempTouchState);\n } else {\n                        mTouchStatesByDisplay.add(displayId, mTempTouchState);\n }\n } else if (oldStateIndex >= 0) {\n                    mTouchStatesByDisplay.removeItemsAt(oldStateIndex);\n }\n }\n\n            mLastHoverWindowHandle = newHoverWindowHandle;\n }\n } else {\n#if DEBUG_FOCUS\n        ALOGD(\"Not updating touch focus because injection was denied.\");\n#endif\n }\n\nUnresponsive:\n    mTempTouchState.reset();\n\n nsecs_t timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);\n    updateDispatchStatisticsLocked(currentTime, entry,\n            injectionResult, timeSpentWaitingForApplication);\n#if DEBUG_FOCUS\n    ALOGD(\"findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, \"\n \"timeSpentWaitingForApplication=%0.1fms\",\n            injectionResult, injectionPermission, timeSpentWaitingForApplication \/ 1000000.0);\n#endif\n return injectionResult;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"SegmentInfo::~SegmentInfo()\n{\n    delete[] m_pMuxingAppAsUTF8;\n    m_pMuxingAppAsUTF8 = NULL;\n    delete[] m_pWritingAppAsUTF8;\n    m_pWritingAppAsUTF8 = NULL;\n    delete[] m_pTitleAsUTF8;\n    m_pTitleAsUTF8 = NULL;\n}\n","project":"Android","target":1},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_retrieve_glob (struct url *u, ccon *con, int action)\n{\n  struct fileinfo *f, *start;\n  uerr_t res;\n\n  con->cmd |= LEAVE_PENDING;\n\n  res = ftp_get_listing (u, con, &start);\n  if (res != RETROK)\n    return res;\n  \/* First: weed out that do not conform the global rules given in\n     opt.accepts and opt.rejects.  *\/\n  if (opt.accepts || opt.rejects)\n    {\n      f = start;\n      while (f)\n        {\n          if (f->type != FT_DIRECTORY && !acceptable (f->name))\n            {\n              logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                         quote (f->name));\n              f = delelement (f, &start);\n            }\n          else\n            f = f->next;\n        }\n    }\n  \/* Remove all files with possible harmful names or invalid entries. *\/\n  f = start;\n  while (f)\n    {\n      if (has_insecure_name_p (f->name) || is_invalid_entry (f))\n        {\n          logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                     quote (f->name));\n          f = delelement (f, &start);\n        }\n      else\n        f = f->next;\n    }\n  \/* Now weed out the files that do not match our globbing pattern.\n     If we are dealing with a globbing pattern, that is.  *\/\n  if (*u->file)\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          int (*matcher) (const char *, const char *, int)\n            = opt.ignore_case ? fnmatch_nocase : fnmatch;\n          int matchres = 0;\n\n          f = start;\n          while (f)\n            {\n              matchres = matcher (u->file, f->name, 0);\n              if (matchres == -1)\n                {\n                  logprintf (LOG_NOTQUIET, _(\"Error matching %s against %s: %s\\n\"),\n                             u->file, quotearg_style (escape_quoting_style, f->name),\n                             strerror (errno));\n                  break;\n                }\n              if (matchres == FNM_NOMATCH)\n                f = delelement (f, &start); \/* delete the element from the list *\/\n              else\n                f = f->next;        \/* leave the element in the list *\/\n            }\n          if (matchres == -1)\n            {\n              freefileinfo (start);\n              return RETRBADPATTERN;\n            }\n        }\n      else if (action == GLOB_GETONE)\n        {\n#ifdef __VMS\n          \/* 2009-09-09 SMS.\n           * Odd-ball compiler (\"HP C V7.3-009 on OpenVMS Alpha V7.3-2\")\n           * bug causes spurious %CC-E-BADCONDIT complaint with this\n           * \"?:\" statement.  (Different linkage attributes for strcmp()\n           * and strcasecmp().)  Converting to \"if\" changes the\n           * complaint to %CC-W-PTRMISMATCH on \"cmp = strcmp;\".  Adding\n           * the senseless type cast clears the complaint, and looks\n           * harmless.\n           *\/\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : (int (*)())strcmp;\n#else \/* def __VMS *\/\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : strcmp;\n#endif \/* def __VMS [else] *\/\n          f = start;\n          while (f)\n            {\n              if (0 != cmp(u->file, f->name))\n                f = delelement (f, &start);\n              else\n                f = f->next;\n            }\n        }\n    }\n  if (start)\n    {\n      \/* Just get everything.  *\/\n      res = ftp_retrieve_list (u, start, con);\n    }\n  else\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          \/* No luck.  *\/\n          \/* #### This message SUCKS.  We should see what was the\n             reason that nothing was retrieved.  *\/\n          logprintf (LOG_VERBOSE, _(\"No matches on pattern %s.\\n\"),\n                     quote (u->file));\n        }\n      else if (action == GLOB_GETONE) \/* GLOB_GETONE or GLOB_GETALL *\/\n        {\n          \/* Let's try retrieving it anyway.  *\/\n          con->st |= ON_YOUR_OWN;\n          res = ftp_loop_internal (u, NULL, con, NULL, false);\n          return res;\n        }\n\n      \/* If action == GLOB_GETALL, and the file list is empty, there's\n         no point in trying to download anything or in complaining about\n         it.  (An empty directory should not cause complaints.)\n      *\/\n    }\n  freefileinfo (start);\n  if (opt.quota && total_downloaded_bytes > opt.quota)\n    return QUOTEXC;\n  else\n    return res;\n}\n","project":"savannah","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_BT(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpr->tos.tm = fz_identity;\n\tpr->tos.tlm = fz_identity;\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_hash_alloc (void *p)\n{\n  struct cluster_list * val = (struct cluster_list *) p;\n  struct cluster_list *cluster;\n\n  cluster = XMALLOC (MTYPE_CLUSTER, sizeof (struct cluster_list));\n  cluster->length = val->length;\n\n  if (cluster->length)\n    {\n      cluster->list = XMALLOC (MTYPE_CLUSTER_VAL, val->length);\n      memcpy (cluster->list, val->list, val->length);\n    }\n  else\n    cluster->list = NULL;\n\n  cluster->refcnt = 0;\n\n  return cluster;\n}\n","project":"savannah","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_sort_cmap(fz_context *ctx, pdf_cmap *cmap)\n{\n\tint counts[3];\n\n\tif (cmap->tree == NULL)\n\t\treturn;\n\n\tcounts[0] = 0;\n\tcounts[1] = 0;\n\tcounts[2] = 0;\n\twalk_splay(cmap->tree, cmap->ttop, count_node_types, &counts);\n\n\tcmap->ranges = fz_malloc_array(ctx, counts[0], sizeof(*cmap->ranges));\n\tcmap->rcap = counts[0];\n\tcmap->xranges = fz_malloc_array(ctx, counts[1], sizeof(*cmap->xranges));\n\tcmap->xcap = counts[1];\n\tcmap->mranges = fz_malloc_array(ctx, counts[2], sizeof(*cmap->mranges));\n\tcmap->mcap = counts[2];\n\n\twalk_splay(cmap->tree, cmap->ttop, copy_node_types, cmap);\n\n\tfz_free(ctx, cmap->tree);\n\tcmap->tree = NULL;\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkey_get_details)\n{\n\tzval *key;\n\tEVP_PKEY *pkey;\n\tBIO *out;\n\tunsigned int pbio_len;\n\tchar *pbio;\n\tlong ktype;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &key) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(pkey, EVP_PKEY *, &key, -1, \"OpenSSL key\", le_key);\n\tif (!pkey) {\n\t\tRETURN_FALSE;\n\t}\n\tout = BIO_new(BIO_s_mem());\n\tPEM_write_bio_PUBKEY(out, pkey);\n\tpbio_len = BIO_get_mem_data(out, &pbio);\n\n\tarray_init(return_value);\n\tadd_assoc_long(return_value, \"bits\", EVP_PKEY_bits(pkey));\n\tadd_assoc_stringl(return_value, \"key\", pbio, pbio_len, 1);\n\t\/*TODO: Use the real values once the openssl constants are used \n\t * See the enum at the top of this file\n\t *\/\n\tswitch (EVP_PKEY_type(pkey->type)) {\n\t\tcase EVP_PKEY_RSA:\n\t\tcase EVP_PKEY_RSA2:\n\t\t\tktype = OPENSSL_KEYTYPE_RSA;\n\n\t\t\tif (pkey->pkey.rsa != NULL) {\n\t\t\t\tzval *rsa;\n\n\t\t\t\tALLOC_INIT_ZVAL(rsa);\n\t\t\t\tarray_init(rsa);\n\t\t\t\tOPENSSL_PKEY_GET_BN(rsa, n);\n\t\t\t\tOPENSSL_PKEY_GET_BN(rsa, e);\n\t\t\t\tOPENSSL_PKEY_GET_BN(rsa, d);\n\t\t\t\tOPENSSL_PKEY_GET_BN(rsa, p);\n\t\t\t\tOPENSSL_PKEY_GET_BN(rsa, q);\n\t\t\t\tOPENSSL_PKEY_GET_BN(rsa, dmp1);\n\t\t\t\tOPENSSL_PKEY_GET_BN(rsa, dmq1);\n\t\t\t\tOPENSSL_PKEY_GET_BN(rsa, iqmp);\n\t\t\t\tadd_assoc_zval(return_value, \"rsa\", rsa);\n\t\t\t}\n\n\t\t\tbreak;\t\n\t\tcase EVP_PKEY_DSA:\n\t\tcase EVP_PKEY_DSA2:\n\t\tcase EVP_PKEY_DSA3:\n\t\tcase EVP_PKEY_DSA4:\n\t\t\tktype = OPENSSL_KEYTYPE_DSA;\n\n\t\t\tif (pkey->pkey.dsa != NULL) {\n\t\t\t\tzval *dsa;\n\n\t\t\t\tALLOC_INIT_ZVAL(dsa);\n\t\t\t\tarray_init(dsa);\n\t\t\t\tOPENSSL_PKEY_GET_BN(dsa, p);\n\t\t\t\tOPENSSL_PKEY_GET_BN(dsa, q);\n\t\t\t\tOPENSSL_PKEY_GET_BN(dsa, g);\n\t\t\t\tOPENSSL_PKEY_GET_BN(dsa, priv_key);\n\t\t\t\tOPENSSL_PKEY_GET_BN(dsa, pub_key);\n\t\t\t\tadd_assoc_zval(return_value, \"dsa\", dsa);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVP_PKEY_DH:\n\t\t\t\n\t\t\tktype = OPENSSL_KEYTYPE_DH;\n\n\t\t\tif (pkey->pkey.dh != NULL) {\n\t\t\t\tzval *dh;\n\n\t\t\t\tALLOC_INIT_ZVAL(dh);\n\t\t\t\tarray_init(dh);\n\t\t\t\tOPENSSL_PKEY_GET_BN(dh, p);\n\t\t\t\tOPENSSL_PKEY_GET_BN(dh, g);\n\t\t\t\tOPENSSL_PKEY_GET_BN(dh, priv_key);\n\t\t\t\tOPENSSL_PKEY_GET_BN(dh, pub_key);\n\t\t\t\tadd_assoc_zval(return_value, \"dh\", dh);\n\t\t\t}\n\n\t\t\tbreak;\n#ifdef EVP_PKEY_EC \n\t\tcase EVP_PKEY_EC:\n\t\t\tktype = OPENSSL_KEYTYPE_EC;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tktype = -1;\n\t\t\tbreak;\n\t}\n\tadd_assoc_long(return_value, \"type\", ktype);\n\n\tBIO_free(out);\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void RunMemCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 5000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j) {\n        input_block[j] = rnd.Rand8() - rnd.Rand8();\n        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;\n       }\n      if (i == 0)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = 255;\n      if (i == 1)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = -255;\n \n       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\n                                      output_block, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         EXPECT_EQ(output_block[j], output_ref_block[j]);\n        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))\n            << \"Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\";\n       }\n     }\n   }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_default_cmyk(fz_context *ctx, const fz_default_colorspaces *default_cs)\n{\n\tif (default_cs)\n\t\treturn default_cs->cmyk;\n\telse\n\t\treturn fz_device_cmyk(ctx);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void usage_exit() {\n   fprintf(stderr, \"Usage: %s <infile> <outfile> <N-M|N\/M>\\n\", exec_name);\n   exit(EXIT_FAILURE);\n }\n","project":"Android","target":1},{"commit_id":"086d84f45ab7b64d1a7ed7ac8ba5833664a6a5ab","func":"status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n        OMX_U32 flags, OMX_TICKS timestamp) {\n\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n     header->nFilledLen = rangeLength;\n     header->nOffset = rangeOffset;\n \n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    buffer_meta->CopyToOMX(header);\n\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer);\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunFwdTxfm(int16_t *in, int16_t *out, int stride) {\n     fwd_txfm_(in, out, stride, tx_type_);\n   }\n","project":"Android","target":1},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_get_req_cert_type(SSL *s, unsigned char *p)\n\t{\n\tint ret=0;\n\tunsigned long alg_k;\n\n\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n#ifndef OPENSSL_NO_GOST\n\tif (s->version >= TLS1_VERSION)\n\t\t{\n\t\tif (alg_k & SSL_kGOST)\n\t\t\t{\n\t\t\tp[ret++]=TLS_CT_GOST94_SIGN;\n\t\t\tp[ret++]=TLS_CT_GOST01_SIGN;\n\t\t\treturn(ret);\n\t\t\t}\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_DH\n\tif (alg_k & (SSL_kDHr|SSL_kEDH))\n\t\t{\n#  ifndef OPENSSL_NO_RSA\n\t\tp[ret++]=SSL3_CT_RSA_FIXED_DH;\n#  endif\n#  ifndef OPENSSL_NO_DSA\n\t\tp[ret++]=SSL3_CT_DSS_FIXED_DH;\n#  endif\n\t\t}\n\tif ((s->version == SSL3_VERSION) &&\n\t\t(alg_k & (SSL_kEDH|SSL_kDHd|SSL_kDHr)))\n\t\t{\n#  ifndef OPENSSL_NO_RSA\n\t\tp[ret++]=SSL3_CT_RSA_EPHEMERAL_DH;\n#  endif\n#  ifndef OPENSSL_NO_DSA\n\t\tp[ret++]=SSL3_CT_DSS_EPHEMERAL_DH;\n#  endif\n\t\t}\n#endif \/* !OPENSSL_NO_DH *\/\n#ifndef OPENSSL_NO_RSA\n\tp[ret++]=SSL3_CT_RSA_SIGN;\n#endif\n#ifndef OPENSSL_NO_DSA\n\tp[ret++]=SSL3_CT_DSS_SIGN;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tif ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->version >= TLS1_VERSION))\n\t\t{\n\t\tp[ret++]=TLS_CT_RSA_FIXED_ECDH;\n\t\tp[ret++]=TLS_CT_ECDSA_FIXED_ECDH;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_ECDSA\n\t\/* ECDSA certs can be used with RSA cipher suites as well \n\t * so we don't need to check for SSL_kECDH or SSL_kEECDH\n\t *\/\n\tif (s->version >= TLS1_VERSION)\n\t\t{\n\t\tp[ret++]=TLS_CT_ECDSA_SIGN;\n\t\t}\n#endif\t\n\treturn(ret);\n\t}\n","project":"openssl","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"unsigned long long Track::GetSeekPreRoll() const\n{\n    return m_info.seekPreRoll;\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_copy_gstate(fz_context *ctx, pdf_gstate *gs, pdf_gstate *old)\n{\n\tpdf_drop_gstate(ctx, gs);\n\t*gs = *old;\n\tpdf_keep_gstate(ctx, gs);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"rgb_to_lab(fz_context *ctx, const fz_colorspace *cs, const float *rgb, float *lab)\n{\n\tfz_warn(ctx, \"cannot convert into L*a*b colorspace\");\n\tlab[0] = rgb[0];\n\tlab[1] = rgb[1];\n\tlab[2] = rgb[2];\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Cluster::EOS() const\n\/\/\/\/ long long element_size)\n {\n    return (m_pSegment == NULL);\n }\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftRaw::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mChannelCount;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"attrhash_key_make (void *p)\n{\n  const struct attr * attr = (struct attr *) p;\n  uint32_t key = 0;\n#define MIX(val)\tkey = jhash_1word(val, key)\n\n  MIX(attr->origin);\n  MIX(attr->nexthop.s_addr);\n  MIX(attr->med);\n  MIX(attr->local_pref);\n\n  key += attr->origin;\n  key += attr->nexthop.s_addr;\n  key += attr->med;\n  key += attr->local_pref;\n  \n  if (attr->extra)\n    {\n      MIX(attr->extra->aggregator_as);\n      MIX(attr->extra->aggregator_addr.s_addr);\n      MIX(attr->extra->weight);\n      MIX(attr->extra->mp_nexthop_global_in.s_addr);\n    }\n  \n  if (attr->aspath)\n    MIX(aspath_key_make (attr->aspath));\n  if (attr->community)\n    MIX(community_hash_make (attr->community));\n  \n  if (attr->extra)\n    {\n      if (attr->extra->ecommunity)\n        MIX(ecommunity_hash_make (attr->extra->ecommunity));\n      if (attr->extra->cluster)\n        MIX(cluster_hash_key_make (attr->extra->cluster));\n      if (attr->extra->transit)\n        MIX(transit_hash_key_make (attr->extra->transit));\n\n#ifdef HAVE_IPV6\n      MIX(attr->extra->mp_nexthop_len);\n      key = jhash(attr->extra->mp_nexthop_global.s6_addr, 16, key);\n      key = jhash(attr->extra->mp_nexthop_local.s6_addr, 16, key);\n#endif \/* HAVE_IPV6 *\/\n    }\n\n  return key;\n}\n","project":"savannah","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAMR::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (mMode == MODE_NARROW) {\n                 if (strncmp((const char *)roleParams->cRole,\n                             \"audio_decoder.amrnb\",\n                            OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n } else {\n if (strncmp((const char *)roleParams->cRole,\n \"audio_decoder.amrwb\",\n                            OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             const OMX_AUDIO_PARAM_AMRTYPE *aacParams =\n                 (const OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (aacParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"918eeaa29d99d257282fafec931b4bda0e3bae12","func":"void SoftMPEG2::setDecodeArgs(\n         ivd_video_decode_ip_t *ps_dec_ip,\n         ivd_video_decode_op_t *ps_dec_op,\n         OMX_BUFFERHEADERTYPE *inHeader,\n        OMX_BUFFERHEADERTYPE *outHeader,\n\n         size_t timeStampIx) {\n     size_t sizeY = outputBufferWidth() * outputBufferHeight();\n     size_t sizeUV;\n    uint8_t *pBuf;\n \n     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);\n     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n\n    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;\n\n \/* When in flush and after EOS with zero byte input,\n     * inHeader is set to zero. Hence check for non-null *\/\n if (inHeader) {\n        ps_dec_ip->u4_ts = timeStampIx;\n        ps_dec_ip->pv_stream_buffer = inHeader->pBuffer\n + inHeader->nOffset;\n        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;\n } else {\n        ps_dec_ip->u4_ts = 0;\n        ps_dec_ip->pv_stream_buffer = NULL;\n\n         ps_dec_ip->u4_num_Bytes = 0;\n     }\n \n    if (outHeader) {\n        pBuf = outHeader->pBuffer;\n    } else {\n        pBuf = mFlushOutBuffer;\n    }\n     sizeUV = sizeY \/ 4;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;\n \n     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;\n     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;\n     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;\n     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;\n    return;\n }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_parse (struct in_addr * pnt, int length)\n{\n  struct cluster_list tmp;\n  struct cluster_list *cluster;\n\n  tmp.length = length;\n  tmp.list = pnt;\n\n  cluster = hash_get (cluster_hash, &tmp, cluster_hash_alloc);\n  cluster->refcnt++;\n  return cluster;\n}\n","project":"savannah","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_Do_form(fz_context *ctx, pdf_processor *proc, const char *name, pdf_xobject *xobj, pdf_obj *page_resources)\n{\n\tpdf_run_xobject(ctx, (pdf_run_processor*)proc, xobj, page_resources, &fz_identity, 0);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void SetUp() {\n     InitializeConfig();\n    SetMode(GET_PARAM(1));\n    set_cpu_used_ = GET_PARAM(2);\n   }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"phar_entry_info *phar_get_entry_info(phar_archive_data *phar, char *path, int path_len, char **error, int security TSRMLS_DC) \/* {{{ *\/\n{\n\treturn phar_get_entry_info_dir(phar, path, path_len, 0, error, security TSRMLS_CC);\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long EBMLHeader::Parse(\n    IMkvReader* pReader,\n    long long& pos)\n{\n    assert(pReader);\n \n    long long total, available;\n \n    long status = pReader->Length(&total, &available);\n \n    if (status < 0)  \/\/error\n         return status;\n \n    pos = 0;\n    long long end = (available >= 1024) ? 1024 : available;\n \n    for (;;)\n    {\n        unsigned char b = 0;\n        while (pos < end)\n        {\n            status = pReader->Read(pos, 1, &b);\n            if (status < 0)  \/\/error\n                return status;\n            if (b == 0x1A)\n                break;\n            ++pos;\n        }\n        if (b != 0x1A)\n        {\n            if (pos >= 1024)\n                return E_FILE_FORMAT_INVALID;  \/\/don't bother looking anymore\n            if ((total >= 0) && ((total - available) < 5))\n                return E_FILE_FORMAT_INVALID;\n            return available + 5;  \/\/5 = 4-byte ID + 1st byte of size\n        }\n        if ((total >= 0) && ((total - pos) < 5))\n            return E_FILE_FORMAT_INVALID;\n        if ((available - pos) < 5)\n            return pos + 5;  \/\/try again later\n        long len;\n        const long long result = ReadUInt(pReader, pos, len);\n        if (result < 0)  \/\/error\n            return result;\n        if (result == 0x0A45DFA3)  \/\/EBML Header ID\n        {\n            pos += len;  \/\/consume ID\n            break;\n        }\n        ++pos;  \/\/throw away just the 0x1A byte, and try again\n     }\n \n \n \n     long len;\n     long long result = GetUIntLength(pReader, pos, len);\n \n    if (result < 0)  \/\/error\n        return result;\n \n    if (result > 0)  \/\/need more data\n        return result;\n \n    assert(len > 0);\n    assert(len <= 8);\n \n    if ((total >= 0) && ((total -  pos) < len))\n        return E_FILE_FORMAT_INVALID;\n \n    if ((available - pos) < len)\n        return pos + len;  \/\/try again later\n \n \n    result = ReadUInt(pReader, pos, len);\n \n    if (result < 0)  \/\/error\n        return result;\n \n    pos += len;  \/\/consume size field\n \n \n    if ((total >= 0) && ((total - pos) < result))\n        return E_FILE_FORMAT_INVALID;\n \n    if ((available - pos) < result)\n        return pos + result;\n \n    end = pos + result;\n \n    Init();\n \n    while (pos < end)\n    {\n        long long id, size;\n \n        status = ParseElementHeader(\n                    pReader,\n                    pos,\n                    end,\n                    id,\n                    size);\n \n        if (status < 0) \/\/error\n            return status;\n \n        if (size == 0)  \/\/weird\n            return E_FILE_FORMAT_INVALID;\n \n        if (id == 0x0286)  \/\/version\n        {\n            m_version = UnserializeUInt(pReader, pos, size);\n \n            if (m_version <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x02F7)  \/\/read version\n        {\n            m_readVersion = UnserializeUInt(pReader, pos, size);\n \n            if (m_readVersion <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x02F2)  \/\/max id length\n        {\n            m_maxIdLength = UnserializeUInt(pReader, pos, size);\n \n            if (m_maxIdLength <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x02F3)  \/\/max size length\n        {\n            m_maxSizeLength = UnserializeUInt(pReader, pos, size);\n            if (m_maxSizeLength <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x0282)  \/\/doctype\n        {\n            if (m_docType)\n                return E_FILE_FORMAT_INVALID;\n            status = UnserializeString(pReader, pos, size, m_docType);\n            if (status)  \/\/error\n                return status;\n        }\n        else if (id == 0x0287)  \/\/doctype version\n        {\n            m_docTypeVersion = UnserializeUInt(pReader, pos, size);\n            if (m_docTypeVersion <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x0285)  \/\/doctype read version\n        {\n            m_docTypeReadVersion = UnserializeUInt(pReader, pos, size);\n            if (m_docTypeReadVersion <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        pos += size;\n     }\n \n    assert(pos == end);\n    return 0;\n }\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAVC::setConfig(\n        OMX_INDEXTYPE index, const OMX_PTR _params) {\n switch (index) {\n case OMX_IndexConfigVideoIntraVOPRefresh:\n {\n\n             OMX_CONFIG_INTRAREFRESHVOPTYPE *params =\n                 (OMX_CONFIG_INTRAREFRESHVOPTYPE *)_params;\n \n             if (params->nPortIndex != kOutputPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n            mKeyFrameRequested = params->IntraRefreshVOP;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexConfigVideoBitrate:\n {\n\n             OMX_VIDEO_CONFIG_BITRATETYPE *params =\n                 (OMX_VIDEO_CONFIG_BITRATETYPE *)_params;\n \n             if (params->nPortIndex != kOutputPortIndex) {\n                 return OMX_ErrorBadPortIndex;\n             }\n\n if (mBitrate != params->nEncodeBitrate) {\n                mBitrate = params->nEncodeBitrate;\n                mBitrateUpdated = true;\n }\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::setConfig(index, _params);\n }\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_intern (struct cluster_list *cluster)\n{\n  struct cluster_list *find;\n\n  find = hash_get (cluster_hash, cluster, cluster_hash_alloc);\n  find->refcnt++;\n\n  return find;\n}\n","project":"savannah","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_add_entry(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tret = ldb_build_add_req(&req, ldb, ac,\n\t\t\t\tac->msg,\n\t\t\t\tac->req->controls,\n\t\t\t\tac, samldb_add_entry_callback,\n\t\t\t\tac->req);\n\tLDB_REQ_SET_LOCATION(req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, req);\n}\n","project":"samba","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_drop_icclink(fz_context *ctx, fz_icclink *link)\n{\n\tfz_drop_storable(ctx, &link->storable);\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_M(fz_context *ctx, pdf_processor *proc, float miterlimit)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pdf_flush_text(ctx, pr);\n\n\tpr->dev->flags &= ~FZ_DEVFLAG_MITERLIMIT_UNDEFINED;\n\tgstate->stroke_state = fz_unshare_stroke_state(ctx, gstate->stroke_state);\n\tgstate->stroke_state->miterlimit = miterlimit;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n\n     tot_frame_number_ = 0;\n     first_drop_ = 0;\n     num_drops_ = 0;\n     for (int i = 0; i < 3; ++i) {\n       bits_total_[i] = 0;\n     }\n   }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"transit_hash_cmp (const void *p1, const void *p2)\n{\n  const struct transit * transit1 = p1;\n  const struct transit * transit2 = p2;\n\n  return (transit1->length == transit2->length &&\n\t  memcmp (transit1->val, transit2->val, transit1->length) == 0);\n}\n","project":"savannah","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_shutdown(SSL *s)\n\t{\n\tint ret;\n\n\t\/* Don't do anything much if we have not done the handshake or\n\t * we don't want to send messages :-) *\/\n\tif ((s->quiet_shutdown) || (s->state == SSL_ST_BEFORE))\n\t\t{\n\t\ts->shutdown=(SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\n\t\treturn(1);\n\t\t}\n\n\tif (!(s->shutdown & SSL_SENT_SHUTDOWN))\n\t\t{\n\t\ts->shutdown|=SSL_SENT_SHUTDOWN;\n#if 1\n\t\tssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_CLOSE_NOTIFY);\n#endif\n\t\t\/* our shutdown alert has been sent now, and if it still needs\n\t \t * to be written, s->s3->alert_dispatch will be true *\/\n\t \tif (s->s3->alert_dispatch)\n\t \t\treturn(-1);\t\/* return WANT_WRITE *\/\n\t\t}\n\telse if (s->s3->alert_dispatch)\n\t\t{\n\t\t\/* resend it if not sent *\/\n#if 1\n\t\tret=s->method->ssl_dispatch_alert(s);\n\t\tif(ret == -1)\n\t\t\t{\n\t\t\t\/* we only get to return -1 here the 2nd\/Nth\n\t\t\t * invocation, we must  have already signalled\n\t\t\t * return 0 upon a previous invoation,\n\t\t\t * return WANT_WRITE *\/\n\t\t\treturn(ret);\n\t\t\t}\n#endif\n\t\t}\n\telse if (!(s->shutdown & SSL_RECEIVED_SHUTDOWN))\n\t\t{\n\t\t\/* If we are waiting for a close from our peer, we are closed *\/\n\t\ts->method->ssl_read_bytes(s,0,NULL,0,0);\n\t\tif(!(s->shutdown & SSL_RECEIVED_SHUTDOWN))\n\t\t\t{\n\t\t\treturn(-1);\t\/* return WANT_READ *\/\n\t\t\t}\n\t\t}\n\n\tif ((s->shutdown == (SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN)) &&\n\t\t!s->s3->alert_dispatch)\n\t\treturn(1);\n\telse\n\t\treturn(0);\n\t}\n","project":"openssl","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Chapters* Segment::GetChapters() const\n{\n  return m_pChapters;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {\n    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {\n    }\n   }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_default_intern (u_char origin)\n{\n  struct attr attr;\n  struct attr *new;\n  \n  memset (&attr, 0, sizeof (struct attr));\n  bgp_attr_extra_get (&attr);\n  \n  bgp_attr_default_set(&attr, origin);\n\n  new = bgp_attr_intern (&attr);\n  bgp_attr_extra_free (&attr);\n  \n  aspath_unintern (&new->aspath);\n  return new;\n}\n","project":"savannah","target":0},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"static timelib_ull timelib_get_unsigned_nr(char **ptr, int max_length)\n{\n\ttimelib_ull dir = 1;\n\n\twhile (((**ptr < '0') || (**ptr > '9')) && (**ptr != '+') && (**ptr != '-')) {\n\t\tif (**ptr == '\\0') {\n\t\t\treturn TIMELIB_UNSET;\n\t\t}\n\t\t++*ptr;\n\t}\n\n\twhile (**ptr == '+' || **ptr == '-')\n\t{\n\t\tif (**ptr == '-') {\n\t\t\tdir *= -1;\n\t\t}\n\t\t++*ptr;\n\t}\n\treturn dir * timelib_get_nr(ptr, max_length);\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_drop_cmm_context(fz_context *ctx)\n{\n\tfz_cmm_drop_instance(ctx);\n\tctx->cmm_instance = NULL;\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_add_codespace(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, int n)\n{\n\tif (cmap->codespace_len + 1 == nelem(cmap->codespace))\n\t{\n\t\tfz_warn(ctx, \"assert: too many code space ranges\");\n\t\treturn;\n\t}\n\n\tcmap->codespace[cmap->codespace_len].n = n;\n\tcmap->codespace[cmap->codespace_len].low = low;\n\tcmap->codespace[cmap->codespace_len].high = high;\n\tcmap->codespace_len ++;\n}\n","project":"ghostscript","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAACEncoder2::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.aac\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAAC)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mBitRate = aacParams->nBitRate;\n            mNumChannels = aacParams->nChannels;\n            mSampleRate = aacParams->nSampleRate;\n if (aacParams->eAACProfile != OMX_AUDIO_AACObjectNull) {\n                mAACProfile = aacParams->eAACProfile;\n }\n\n if (!(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && !(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 0;\n                mSBRRatio = 0;\n } else if ((aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && !(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 1;\n                mSBRRatio = 1;\n } else if (!(aacParams->nAACtools & OMX_AUDIO_AACToolAndroidSSBR)\n && (aacParams->nAACtools & OMX_AUDIO_AACToolAndroidDSBR)) {\n                mSBRMode = 1;\n                mSBRRatio = 2;\n } else {\n                mSBRMode = -1; \/\/ codec default sbr mode\n                mSBRRatio = 0;\n }\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const CuePoint::TrackPosition* CuePoint::Find(const Track* pTrack) const\n{\n    assert(pTrack);\n \n    const long long n = pTrack->GetNumber();\n \n    const TrackPosition* i = m_track_positions;\n    const TrackPosition* const j = i + m_track_positions_count;\n \n    while (i != j)\n    {\n        const TrackPosition& p = *i++;\n \n        if (p.m_track == n)\n            return &p;\n    }\n    return NULL;  \/\/no matching track number found\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long mkvparser::ParseElementHeader(\n    IMkvReader* pReader,\n    long long& pos,\n    long long stop,\n    long long& id,\n    long long& size)\n{\n    if ((stop >= 0) && (pos >= stop))\n        return E_FILE_FORMAT_INVALID;\n \n    long len;\n \n    id = ReadUInt(pReader, pos, len);\n \n    if (id < 0)\n        return E_FILE_FORMAT_INVALID;\n \n    pos += len;  \/\/consume id\n \n    if ((stop >= 0) && (pos >= stop))\n        return E_FILE_FORMAT_INVALID;\n \n    size = ReadUInt(pReader, pos, len);\n \n    if (size < 0)\n        return E_FILE_FORMAT_INVALID;\n \n    pos += len;  \/\/consume length of size\n \n \n    if ((stop >= 0) && ((pos + size) > stop))\n        return E_FILE_FORMAT_INVALID;\n    return 0;  \/\/success\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_csr_get_subject)\n{\n\tzval ** zcsr;\n\tzend_bool use_shortnames = 1;\n\tlong csr_resource;\n\tX509_NAME * subject;\n\tX509_REQ * csr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z|b\", &zcsr, &use_shortnames) == FAILURE) {\n\t\treturn;\n\t}\n\n\tcsr = php_openssl_csr_from_zval(zcsr, 0, &csr_resource TSRMLS_CC);\n\n\tif (csr == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tsubject = X509_REQ_get_subject_name(csr);\n\n\tarray_init(return_value);\n\tadd_assoc_name_entry(return_value, NULL, subject, use_shortnames TSRMLS_CC);\n\treturn;\n}\n","project":"php","target":0},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::createGraphicBufferSource(\n\n         OMX_U32 portIndex, sp<IGraphicBufferConsumer> bufferConsumer, MetadataBufferType *type) {\n     status_t err;\n \n    const sp<GraphicBufferSource>& surfaceCheck = getGraphicBufferSource();\n     if (surfaceCheck != NULL) {\n         if (portIndex < NELEM(mMetadataType) && type != NULL) {\n             *type = mMetadataType[portIndex];\n }\n return ALREADY_EXISTS;\n }\n\n if (type != NULL) {\n *type = kMetadataBufferTypeANWBuffer;\n }\n    err = storeMetaDataInBuffers_l(portIndex, OMX_TRUE, type);\n if (err != OK) {\n return err;\n }\n\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n    OMX_ERRORTYPE oerr = OMX_GetParameter(\n            mHandle, OMX_IndexParamPortDefinition, &def);\n if (oerr != OMX_ErrorNone) {\n        OMX_INDEXTYPE index = OMX_IndexParamPortDefinition;\n        CLOG_ERROR(getParameter, oerr, \"%s(%#x): %s:%u\",\n                asString(index), index, portString(portIndex), portIndex);\n return UNKNOWN_ERROR;\n }\n\n if (def.format.video.eColorFormat != OMX_COLOR_FormatAndroidOpaque) {\n        CLOGW(\"createInputSurface requires COLOR_FormatSurface \"\n \"(AndroidOpaque) color format instead of %s(%#x)\",\n                asString(def.format.video.eColorFormat), def.format.video.eColorFormat);\n return INVALID_OPERATION;\n }\n\n uint32_t usageBits;\n    oerr = OMX_GetParameter(\n            mHandle, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits, &usageBits);\n if (oerr != OMX_ErrorNone) {\n        usageBits = 0;\n }\n\n    sp<GraphicBufferSource> bufferSource = new GraphicBufferSource(this,\n            def.format.video.nFrameWidth,\n            def.format.video.nFrameHeight,\n            def.nBufferCountActual,\n            usageBits,\n            bufferConsumer);\n\n if ((err = bufferSource->initCheck()) != OK) {\n return err;\n }\n    setGraphicBufferSource(bufferSource);\n\n return OK;\n}\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_schema_info_update(struct samldb_ctx *ac)\n{\n\tint ret;\n\tstruct ldb_context *ldb;\n\tstruct dsdb_schema *schema;\n\n\t\/* replicated update should always go through *\/\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t\/* do not update schemaInfo during provisioning *\/\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_schema_info_update(ac->module, schema,\n\t\t\t\t\t     DSDB_FLAG_NEXT_MODULE|\n\t\t\t\t\t     DSDB_FLAG_AS_SYSTEM,\n\t\t\t\t\t     ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb_schema_info_update: dsdb_module_schema_info_update failed with %s\",\n\t\t\t\t       ldb_errstring(ldb));\n\t\treturn ret;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n","project":"samba","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" static bool compare_img(const vpx_image_t *img1,\n                         const vpx_image_t *img2) {\n   bool match = (img1->fmt == img2->fmt) &&\n                (img1->d_w == img2->d_w) &&\n                (img1->d_h == img2->d_h);\n \n const unsigned int width_y  = img1->d_w;\n const unsigned int height_y = img1->d_h;\n unsigned int i;\n for (i = 0; i < height_y; ++i)\n    match = (memcmp(img1->planes[VPX_PLANE_Y] + i * img1->stride[VPX_PLANE_Y],\n                    img2->planes[VPX_PLANE_Y] + i * img2->stride[VPX_PLANE_Y],\n                    width_y) == 0) && match;\n const unsigned int width_uv  = (img1->d_w + 1) >> 1;\n const unsigned int height_uv = (img1->d_h + 1) >> 1;\n for (i = 0; i <  height_uv; ++i)\n    match = (memcmp(img1->planes[VPX_PLANE_U] + i * img1->stride[VPX_PLANE_U],\n                    img2->planes[VPX_PLANE_U] + i * img2->stride[VPX_PLANE_U],\n                    width_uv) == 0) && match;\n for (i = 0; i < height_uv; ++i)\n    match = (memcmp(img1->planes[VPX_PLANE_V] + i * img1->stride[VPX_PLANE_V],\n                    img2->planes[VPX_PLANE_V] + i * img2->stride[VPX_PLANE_V],\n                    width_uv) == 0) && match;\n\n   return match;\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static void php_openssl_dispose_config(struct php_x509_request * req TSRMLS_DC) \/* {{{ *\/\n{\n\tif (req->priv_key) {\n\t\tEVP_PKEY_free(req->priv_key);\n\t\treq->priv_key = NULL;\n\t}\n\tif (req->global_config) {\n\t\tCONF_free(req->global_config);\n\t\treq->global_config = NULL;\n\t}\n\tif (req->req_config) {\n\t\tCONF_free(req->req_config);\n\t\treq->req_config = NULL;\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fast_cmyk_to_rgb(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tint sn = src->n;\n\tint ss = src->s;\n\tint sa = src->alpha;\n\tint dn = dst->n;\n\tint ds = dst->s;\n\tint da = dst->alpha;\n\tptrdiff_t d_line_inc = dst->stride - w * dn;\n\tptrdiff_t s_line_inc = src->stride - w * sn;\n\tunsigned int C,M,Y,K;\n\tunsigned char r,g,b;\n\n\t\/* Spots must match, and we can never drop alpha (but we can invent it) *\/\n\tif ((copy_spots && ss != ds) || (!da && sa))\n\t{\n\t\tassert(\"This should never happen\" == NULL);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Cannot convert between incompatible pixmaps\");\n\t}\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tC = 0;\n\tM = 0;\n\tY = 0;\n\tK = 0;\n\tr = 255;\n\tg = 255;\n\tb = 255;\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\tif (ss == 0 && ds == 0)\n\t{\n\t\t\/* Common, no spots case *\/\n\t\tif (da)\n\t\t{\n\t\t\tif (sa)\n\t\t\t{\n#ifdef ARCH_ARM\n\t\t\t\tif (h == 1)\n\t\t\t\t{\n\t\t\t\t\tfast_cmyk_to_rgb_ARM(d, s, w);\n\t\t\t\t\treturn;\n\t\t\t\t}\n#endif\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\tcached_cmyk_conv(&r, &g, &b, &C, &M, &Y, &K, s[0], s[1], s[2], s[3]);\n\t\t\t\t\t\td[0] = r;\n\t\t\t\t\t\td[1] = g;\n\t\t\t\t\t\td[2] = b;\n\t\t\t\t\t\td[3] = s[4];\n\t\t\t\t\t\ts += 5;\n\t\t\t\t\t\td += 4;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (h--)\n\t\t\t\t{\n\t\t\t\t\tsize_t ww = w;\n\t\t\t\t\twhile (ww--)\n\t\t\t\t\t{\n\t\t\t\t\t\tcached_cmyk_conv(&r, &g, &b, &C, &M, &Y, &K, s[0], s[1], s[2], s[3]);\n\t\t\t\t\t\td[0] = r;\n\t\t\t\t\t\td[1] = g;\n\t\t\t\t\t\td[2] = b;\n\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\ts += 4;\n\t\t\t\t\t\td += 4;\n\t\t\t\t\t}\n\t\t\t\t\td += d_line_inc;\n\t\t\t\t\ts += s_line_inc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\tcached_cmyk_conv(&r, &g, &b, &C, &M, &Y, &K, s[0], s[1], s[2], s[3]);\n\t\t\t\t\td[0] = r;\n\t\t\t\t\td[1] = g;\n\t\t\t\t\td[2] = b;\n\t\t\t\t\ts += 4;\n\t\t\t\t\td += 3;\n\t\t\t\t}\n\t\t\t\td += d_line_inc;\n\t\t\t\ts += s_line_inc;\n\t\t\t}\n\t\t}\n\t}\n\telse if (copy_spots)\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\twhile (h--)\n\t\t{\n\t\t\tint i;\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tcached_cmyk_conv(&r, &g, &b, &C, &M, &Y, &K, s[0], s[1], s[2], s[3]);\n\t\t\t\td[0] = r;\n\t\t\t\td[1] = g;\n\t\t\t\td[2] = b;\n\t\t\t\ts += 4;\n\t\t\t\td += 3;\n\t\t\t\tfor (i=ss; i > 0; i--)\n\t\t\t\t\t*d++ = *s++;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = sa ? *s++ : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\t\/* Slower, spots capable version *\/\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tcached_cmyk_conv(&r, &g, &b, &C, &M, &Y, &K, s[0], s[1], s[2], s[3]);\n\t\t\t\td[0] = r;\n\t\t\t\td[1] = g;\n\t\t\t\td[2] = b;\n\t\t\t\ts += sn;\n\t\t\t\td += dn;\n\t\t\t\tif (da)\n\t\t\t\t\td[-1] = sa ? s[-1] : 255;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_set_cmap_wmode(fz_context *ctx, pdf_cmap *cmap, int wmode)\n{\n\tcmap->wmode = wmode;\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkcs7_sign)\n{\n\tzval ** zcert, ** zprivkey, * zheaders;\n\tzval ** hval;\n\tX509 * cert = NULL;\n\tEVP_PKEY * privkey = NULL;\n\tlong flags = PKCS7_DETACHED;\n\tPKCS7 * p7 = NULL;\n\tBIO * infile = NULL, * outfile = NULL;\n\tSTACK_OF(X509) *others = NULL;\n\tlong certresource = -1, keyresource = -1;\n\tulong intindex;\n\tuint strindexlen;\n\tHashPosition hpos;\n\tchar * strindex;\n\tchar * infilename;\tint infilename_len;\n\tchar * outfilename;\tint outfilename_len;\n\tchar * extracertsfilename = NULL; int extracertsfilename_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ssZZa!|ls\",\n\t\t\t\t&infilename, &infilename_len, &outfilename, &outfilename_len,\n\t\t\t\t&zcert, &zprivkey, &zheaders, &flags, &extracertsfilename,\n\t\t\t\t&extracertsfilename_len) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tif (strlen(infilename) != infilename_len) {\n\t\treturn;\n\t}\n\n\tif (strlen(outfilename) != outfilename_len) {\n\t\treturn;\n\t}\n\n\tif (extracertsfilename) {\n\t\tothers = load_all_certs_from_file(extracertsfilename);\n\t\tif (others == NULL) { \n\t\t\tgoto clean_exit;\n\t\t}\n\t}\n\n\tprivkey = php_openssl_evp_from_zval(zprivkey, 0, \"\", 0, &keyresource TSRMLS_CC);\n\tif (privkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error getting private key\");\n\t\tgoto clean_exit;\n\t}\n\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error getting cert\");\n\t\tgoto clean_exit;\n\t}\n\n\tif (php_openssl_safe_mode_chk(infilename TSRMLS_CC) || php_openssl_safe_mode_chk(outfilename TSRMLS_CC)) {\n\t\tgoto clean_exit;\n\t}\n\n\tinfile = BIO_new_file(infilename, \"r\");\n\tif (infile == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error opening input file %s!\", infilename);\n\t\tgoto clean_exit;\n\t}\n\n\toutfile = BIO_new_file(outfilename, \"w\");\n\tif (outfile == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error opening output file %s!\", outfilename);\n\t\tgoto clean_exit;\n\t}\n\n\tp7 = PKCS7_sign(cert, privkey, others, infile, flags);\n\tif (p7 == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error creating PKCS7 structure!\");\n\t\tgoto clean_exit;\n\t}\n\n\t(void)BIO_reset(infile);\n\n\t\/* tack on extra headers *\/\n\tif (zheaders) {\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(zheaders), &hpos);\n\t\twhile(zend_hash_get_current_data_ex(HASH_OF(zheaders), (void**)&hval, &hpos) == SUCCESS) {\n\t\t\tstrindex = NULL;\n\t\t\tzend_hash_get_current_key_ex(HASH_OF(zheaders), &strindex, &strindexlen, &intindex, 0, &hpos);\n\n\t\t\tconvert_to_string_ex(hval);\n\n\t\t\tif (strindex) {\n\t\t\t\tBIO_printf(outfile, \"%s: %s\\n\", strindex, Z_STRVAL_PP(hval));\n\t\t\t} else {\n\t\t\t\tBIO_printf(outfile, \"%s\\n\", Z_STRVAL_PP(hval));\n\t\t\t}\n\t\t\tzend_hash_move_forward_ex(HASH_OF(zheaders), &hpos);\n\t\t}\n\t}\n\t\/* write the signed data *\/\n\tSMIME_write_PKCS7(outfile, p7, infile, flags);\n\n\tRETVAL_TRUE;\n\nclean_exit:\n\tPKCS7_free(p7);\n\tBIO_free(infile);\n\tBIO_free(outfile);\n\tif (others) {\n\t\tsk_X509_pop_free(others, X509_free);\n\t}\n\tif (privkey && keyresource == -1) {\n\t\tEVP_PKEY_free(privkey);\n\t}\n\tif (cert && certresource == -1) {\n\t\tX509_free(cert);\n\t}\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Track::Info::~Info()\n{\n    Clear();\n}\n","project":"Android","target":1},{"commit_id":"daa85dac2055b22dabbb3b4e537597e6ab73a866","func":"void SoftAMR::onQueueFilled(OMX_U32 \/* portIndex *\/) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n\n         BufferInfo *inInfo = *inQueue.begin();\n         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n \n        if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            notifyEmptyBufferDone(inHeader);\n            continue;\n        }\n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n \n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n\n             return;\n         }\n \n         if (inHeader->nOffset == 0) {\n             mAnchorTimeUs = inHeader->nTimeStamp;\n             mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n int32_t numBytesRead;\n\n if (mMode == MODE_NARROW) {\n if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {\n                ALOGE(\"b\/27662364: NB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n size_t frameSize = WmfDecBytesPerFrame[mode] + 1;\n\n if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b\/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            numBytesRead =\n AMRDecode(mState,\n (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; \/\/ Include the frame type header byte.\n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n } else {\n if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {\n                ALOGE(\"b\/27662364: WB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n\n if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n size_t frameSize = getFrameSize(mode);\n if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b\/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n\n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n \/* Delete the 2 LSBs (14-bit output) *\/\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) \/ kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) \/ kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_begin_group(fz_context *ctx, pdf_run_processor *pr, const fz_rect *bbox, softmask_save *softmask)\n{\n\tpdf_gstate *gstate = begin_softmask(ctx, pr, softmask);\n\n\tif (gstate->blendmode)\n\t\tfz_begin_group(ctx, pr->dev, bbox, NULL, 0, 0, gstate->blendmode, 1);\n\n\treturn pr->gstate + pr->gtop;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_lookup_icc(fz_context *ctx, const char *name, size_t *size)\n{\n#ifndef NO_ICC\n\tif (fz_get_cmm_engine(ctx) == NULL)\n\t\treturn *size = 0, NULL;\n\tif (!strcmp(name, FZ_ICC_PROFILE_GRAY)) {\n\t\textern const int fz_resources_icc_gray_icc_size;\n\t\textern const unsigned char fz_resources_icc_gray_icc[];\n\t\t*size = fz_resources_icc_gray_icc_size;\n\t\treturn fz_resources_icc_gray_icc;\n\t}\n\tif (!strcmp(name, FZ_ICC_PROFILE_RGB) || !strcmp(name, FZ_ICC_PROFILE_BGR)) {\n\t\textern const int fz_resources_icc_rgb_icc_size;\n\t\textern const unsigned char fz_resources_icc_rgb_icc[];\n\t\t*size = fz_resources_icc_rgb_icc_size;\n\t\treturn fz_resources_icc_rgb_icc;\n\t}\n\tif (!strcmp(name, FZ_ICC_PROFILE_CMYK)) {\n\t\textern const int fz_resources_icc_cmyk_icc_size;\n\t\textern const unsigned char fz_resources_icc_cmyk_icc[];\n\t\t*size = fz_resources_icc_cmyk_icc_size;\n\t\treturn fz_resources_icc_cmyk_icc;\n\t}\n\tif (!strcmp(name, FZ_ICC_PROFILE_LAB)) {\n\t\textern const int fz_resources_icc_lab_icc_size;\n\t\textern const unsigned char fz_resources_icc_lab_icc[];\n\t\t*size = fz_resources_icc_lab_icc_size;\n\t\treturn fz_resources_icc_lab_icc;\n\t}\n#endif\n\treturn *size = 0, NULL;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void CheckSad(unsigned int max_sad) {\n    unsigned int reference_sad, exp_sad;\n    reference_sad = ReferenceSAD(max_sad);\n    exp_sad = SAD(max_sad);\n    if (reference_sad <= max_sad) {\n      ASSERT_EQ(exp_sad, reference_sad);\n    } else {\n      ASSERT_GE(exp_sad, reference_sad);\n    }\n  }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"transit_intern (struct transit *transit)\n{\n  struct transit *find;\n\n  find = hash_get (transit_hash, transit, transit_hash_alloc);\n  if (find != transit)\n    transit_free (transit);\n  find->refcnt++;\n\n  return find;\n}\n","project":"savannah","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_prim_group_trigger(struct samldb_ctx *ac)\n{\n\tint ret;\n\n\tif (ac->req->operation == LDB_ADD) {\n\t\tret = samldb_prim_group_set(ac);\n\t} else {\n\t\tret = samldb_prim_group_change(ac);\n\t}\n\n\treturn ret;\n}\n","project":"samba","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"int phar_wrapper_rmdir(php_stream_wrapper *wrapper, char *url, int options, php_stream_context *context TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_entry_info *entry;\n\tphar_archive_data *phar = NULL;\n\tchar *error, *arch, *entry2;\n\tint arch_len, entry_len;\n\tphp_url *resource = NULL;\n\tuint host_len;\n\tphar_zstr key;\n\tchar *str_key;\n\tuint key_len;\n\tulong unused;\n\tuint path_len;\n\n\t\/* pre-readonly check, we need to know if this is a data phar *\/\n\tif (FAILURE == phar_split_fname(url, strlen(url), &arch, &arch_len, &entry2, &entry_len, 2, 2 TSRMLS_CC)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot remove directory \\\"%s\\\", no phar archive specified, or phar archive does not exist\", url);\n\t\treturn 0;\n\t}\n\n\tif (FAILURE == phar_get_archive(&phar, arch, arch_len, NULL, 0, NULL TSRMLS_CC)) {\n\t\tphar = NULL;\n\t}\n\n\tefree(arch);\n\tefree(entry2);\n\n\tif (PHAR_G(readonly) && (!phar || !phar->is_data)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot rmdir directory \\\"%s\\\", write operations disabled\", url);\n\t\treturn 0;\n\t}\n\n\tif ((resource = phar_parse_url(wrapper, url, \"w\", options TSRMLS_CC)) == NULL) {\n\t\treturn 0;\n\t}\n\n\t\/* we must have at the very least phar:\/\/alias.phar\/internalfile.php *\/\n\tif (!resource->scheme || !resource->host || !resource->path) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: invalid url \\\"%s\\\"\", url);\n\t\treturn 0;\n\t}\n\n\tif (strcasecmp(\"phar\", resource->scheme)) {\n\t\tphp_url_free(resource);\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: not a phar stream url \\\"%s\\\"\", url);\n\t\treturn 0;\n\t}\n\n\thost_len = strlen(resource->host);\n\n\tif (FAILURE == phar_get_archive(&phar, resource->host, host_len, NULL, 0, &error TSRMLS_CC)) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot remove directory \\\"%s\\\" in phar \\\"%s\\\", error retrieving phar information: %s\", resource->path+1, resource->host, error);\n\t\tefree(error);\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\n\tpath_len = strlen(resource->path+1);\n\n\tif (!(entry = phar_get_entry_info_dir(phar, resource->path + 1, path_len, 2, &error, 1 TSRMLS_CC))) {\n\t\tif (error) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot remove directory \\\"%s\\\" in phar \\\"%s\\\", %s\", resource->path+1, resource->host, error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot remove directory \\\"%s\\\" in phar \\\"%s\\\", directory does not exist\", resource->path+1, resource->host);\n\t\t}\n\t\tphp_url_free(resource);\n\t\treturn 0;\n\t}\n\n\tif (!entry->is_deleted) {\n\t\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&phar->manifest, &key, &key_len, &unused, 0, NULL);\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\n\t\t\tPHAR_STR(key, str_key);\n\n\t\t\tif (key_len > path_len && \n\t\t\t\tmemcmp(str_key, resource->path+1, path_len) == 0 && \n\t\t\t\tIS_SLASH(str_key[path_len])) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: Directory not empty\");\n\t\t\t\tif (entry->is_temp_dir) {\n\t\t\t\t\tefree(entry->filename);\n\t\t\t\t\tefree(entry);\n\t\t\t\t}\n\t\t\t\tphp_url_free(resource);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tPHAR_STR_FREE(str_key);\n\t\t}\n\n\t\tfor (zend_hash_internal_pointer_reset(&phar->virtual_dirs);\n\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&phar->virtual_dirs, &key, &key_len, &unused, 0, NULL);\n\t\t\tzend_hash_move_forward(&phar->virtual_dirs)) {\n\t\n\t\t\tPHAR_STR(key, str_key);\n\t\n\t\t\tif (key_len > path_len && \n\t\t\t\tmemcmp(str_key, resource->path+1, path_len) == 0 && \n\t\t\t\tIS_SLASH(str_key[path_len])) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: Directory not empty\");\n\t\t\t\tif (entry->is_temp_dir) {\n\t\t\t\t\tefree(entry->filename);\n\t\t\t\t\tefree(entry);\n\t\t\t\t}\n\t\t\t\tphp_url_free(resource);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tPHAR_STR_FREE(str_key);\n\t\t}\n\t}\n\n\tif (entry->is_temp_dir) {\n\t\tzend_hash_del(&phar->virtual_dirs, resource->path+1, path_len);\n\t\tefree(entry->filename);\n\t\tefree(entry);\n\t} else {\n\t\tentry->is_deleted = 1;\n\t\tentry->is_modified = 1;\n\t\tphar_flush(phar, 0, 0, 0, &error TSRMLS_CC);\n\n\t\tif (error) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"phar error: cannot remove directory \\\"%s\\\" in phar \\\"%s\\\", %s\", entry->filename, phar->fname, error);\n\t\t\tphp_url_free(resource);\n\t\t\tefree(error);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tphp_url_free(resource);\n\treturn 1;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_hash_key_make (void *p)\n{\n  const struct cluster_list *cluster = p;\n\n  return jhash(cluster->list, cluster->length, 0);\n}\n","project":"savannah","target":0},{"commit_id":"45737cb776625f17384540523674761e6313e6d4","func":" status_t SampleTable::setTimeToSampleParams(\n         off64_t data_offset, size_t data_size) {\n    if (mTimeToSample != NULL || data_size < 8) {\n         return ERROR_MALFORMED;\n     }\n \n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n\n     }\n \n     mTimeToSampleCount = U32_AT(&header[4]);\n    uint64_t allocSize = (uint64_t)mTimeToSampleCount * 2 * sizeof(uint32_t);\n    if (allocSize > UINT32_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }\n    mTimeToSample = new (std::nothrow) uint32_t[mTimeToSampleCount * 2];\n    if (!mTimeToSample)\n        return ERROR_OUT_OF_RANGE;\n \n    size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n    if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n         return ERROR_IO;\n     }\n \n    for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n     }\n     return OK;\n }\n","project":"Android","target":1},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"long ssl3_ctx_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))\n\t{\n\tCERT *cert;\n\n\tcert=ctx->cert;\n\n\tswitch (cmd)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\tcase SSL_CTRL_SET_TMP_RSA_CB:\n\t\t{\n\t\tcert->rsa_tmp_cb = (RSA *(*)(SSL *, int, int))fp;\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DH\n\tcase SSL_CTRL_SET_TMP_DH_CB:\n\t\t{\n\t\tcert->dh_tmp_cb = (DH *(*)(SSL *, int, int))fp;\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tcase SSL_CTRL_SET_TMP_ECDH_CB:\n\t\t{\n\t\tcert->ecdh_tmp_cb = (EC_KEY *(*)(SSL *, int, int))fp;\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_TLSEXT\n\tcase SSL_CTRL_SET_TLSEXT_SERVERNAME_CB:\n\t\tctx->tlsext_servername_callback=(int (*)(SSL *,int *,void *))fp;\n\t\tbreak;\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tcase SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB:\n\t\tctx->tlsext_opaque_prf_input_callback = (int (*)(SSL *,void *, size_t, void *))fp;\n\t\tbreak;\n#endif\n\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB:\n\t\tctx->tlsext_status_cb=(int (*)(SSL *,void *))fp;\n\t\tbreak;\n\n\tcase SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB:\n\t\tctx->tlsext_ticket_key_cb=(int (*)(SSL *,unsigned char  *,\n\t\t\t\t\t\tunsigned char *,\n\t\t\t\t\t\tEVP_CIPHER_CTX *,\n\t\t\t\t\t\tHMAC_CTX *, int))fp;\n\t\tbreak;\n\n#ifndef OPENSSL_NO_SRP\n\tcase SSL_CTRL_SET_SRP_VERIFY_PARAM_CB:\n\t\tctx->srp_ctx.srp_Mask|=SSL_kSRP;\n\t\tctx->srp_ctx.SRP_verify_param_callback=(int (*)(SSL *,void *))fp;\n\t\tbreak;\n\tcase SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB:\n\t\tctx->srp_ctx.srp_Mask|=SSL_kSRP;\n\t\tctx->srp_ctx.TLS_ext_srp_username_callback=(int (*)(SSL *,int *,void *))fp;\n\t\tbreak;\n\tcase SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB:\n\t\tctx->srp_ctx.srp_Mask|=SSL_kSRP;\n\t\tctx->srp_ctx.SRP_give_srp_client_pwd_callback=(char *(*)(SSL *,void *))fp;\n\t\tbreak;\n#endif\n#endif\n\tdefault:\n\t\treturn(0);\n\t\t}\n\treturn(1);\n\t}\n","project":"openssl","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static int preg_do_eval(char *eval_str, int eval_str_len, char *subject,\n\t\t\t\t\t\tint *offsets, int count, char **result TSRMLS_DC)\n{\n\tzval\t\t retval;\t\t\t\/* Return value from evaluation *\/\n\tchar\t\t*eval_str_end,\t\t\/* End of eval string *\/\n\t\t\t\t*match,\t\t\t\t\/* Current match for a backref *\/\n\t\t\t\t*esc_match,\t\t\t\/* Quote-escaped match *\/\n\t\t\t\t*walk,\t\t\t\t\/* Used to walk the code string *\/\n\t\t\t\t*segment,\t\t\t\/* Start of segment to append while walking *\/\n\t\t\t\t walk_last;\t\t\t\/* Last walked character *\/\n\tint\t\t\t match_len;\t\t\t\/* Length of the match *\/\n\tint\t\t\t esc_match_len;\t\t\/* Length of the quote-escaped match *\/\n\tint\t\t\t result_len;\t\t\/* Length of the result of the evaluation *\/\n\tint\t\t\t backref;\t\t\t\/* Current backref *\/\n\tchar        *compiled_string_description;\n\tsmart_str    code = {0};\n\t\n\teval_str_end = eval_str + eval_str_len;\n\twalk = segment = eval_str;\n\twalk_last = 0;\n\t\n\twhile (walk < eval_str_end) {\n\t\t\/* If found a backreference.. *\/\n\t\tif ('\\\\' == *walk || '$' == *walk) {\n\t\t\tsmart_str_appendl(&code, segment, walk - segment);\n\t\t\tif (walk_last == '\\\\') {\n\t\t\t\tcode.c[code.len-1] = *walk++;\n\t\t\t\tsegment = walk;\n\t\t\t\twalk_last = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsegment = walk;\n\t\t\tif (preg_get_backref(&walk, &backref)) {\n\t\t\t\tif (backref < count) {\n\t\t\t\t\t\/* Find the corresponding string match and substitute it\n\t\t\t\t\t   in instead of the backref *\/\n\t\t\t\t\tmatch = subject + offsets[backref<<1];\n\t\t\t\t\tmatch_len = offsets[(backref<<1)+1] - offsets[backref<<1];\n\t\t\t\t\tif (match_len) {\n\t\t\t\t\t\tesc_match = php_addslashes(match, match_len, &esc_match_len, 0 TSRMLS_CC);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tesc_match = match;\n\t\t\t\t\t\tesc_match_len = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tesc_match = \"\";\n\t\t\t\t\tesc_match_len = 0;\n\t\t\t\t}\n\t\t\t\tsmart_str_appendl(&code, esc_match, esc_match_len);\n\n\t\t\t\tsegment = walk;\n\n\t\t\t\t\/* Clean up and reassign *\/\n\t\t\t\tif (esc_match_len)\n\t\t\t\t\tefree(esc_match);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\twalk++;\n\t\twalk_last = walk[-1];\n\t}\n\tsmart_str_appendl(&code, segment, walk - segment);\n\tsmart_str_0(&code);\n\n\tcompiled_string_description = zend_make_compiled_string_description(\"regexp code\" TSRMLS_CC);\n\t\/* Run the code *\/\n\tif (zend_eval_stringl(code.c, code.len, &retval, compiled_string_description TSRMLS_CC) == FAILURE) {\n\t\tefree(compiled_string_description);\n\t\tphp_error_docref(NULL TSRMLS_CC,E_ERROR, \"Failed evaluating code: %s%s\", PHP_EOL, code.c);\n\t\t\/* zend_error() does not return in this case *\/\n\t}\n\tefree(compiled_string_description);\n\tconvert_to_string(&retval);\n\t\n\t\/* Save the return value and its length *\/\n\t*result = estrndup(Z_STRVAL(retval), Z_STRLEN(retval));\n\tresult_len = Z_STRLEN(retval);\n\t\n\t\/* Clean up *\/\n\tzval_dtor(&retval);\n\tsmart_str_free(&code);\n\t\n\treturn result_len;\n}\n","project":"php","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAMR::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            amrParams->nChannels = 1;\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n if (!isConfigured()) {\n                amrParams->nBitRate = 0;\n                amrParams->eAMRBandMode = OMX_AUDIO_AMRBandModeUnused;\n } else {\n                amrParams->nBitRate = 0;\n                amrParams->eAMRBandMode =\n                    mMode == MODE_NARROW\n ? OMX_AUDIO_AMRBandModeNB0 : OMX_AUDIO_AMRBandModeWB0;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->nChannels = 1;\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n\n            pcmParams->nSamplingRate =\n (mMode == MODE_NARROW) ? kSampleRateNB : kSampleRateWB;\n\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":" status_t OMXNodeInstance::updateNativeHandleInMeta(\n        OMX_U32 portIndex, const sp<NativeHandle>& nativeHandle, OMX::buffer_id buffer) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n if (header == NULL) {\n        ALOGE(\"b\/25884056\");\n return BAD_VALUE;\n }\n\n if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n return BAD_VALUE;\n }\n\n\n     BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);\n     sp<ABuffer> data = bufferMeta->getBuffer(\n            header, portIndex == kPortIndexInput \/* backup *\/, false \/* limit *\/);\n     bufferMeta->setNativeHandle(nativeHandle);\n     if (mMetadataType[portIndex] == kMetadataBufferTypeNativeHandleSource\n             && data->capacity() >= sizeof(VideoNativeHandleMetadata)) {\n VideoNativeHandleMetadata &metadata = *(VideoNativeHandleMetadata *)(data->data());\n        metadata.eType = mMetadataType[portIndex];\n        metadata.pHandle =\n            nativeHandle == NULL ? NULL : const_cast<native_handle*>(nativeHandle->handle());\n } else {\n        CLOG_ERROR(updateNativeHandleInMeta, BAD_VALUE, \"%s:%u, %#x bad type (%d) or size (%zu)\",\n            portString(portIndex), portIndex, buffer, mMetadataType[portIndex], data->capacity());\n return BAD_VALUE;\n }\n\n    CLOG_BUFFER(updateNativeHandleInMeta, \"%s:%u, %#x := %p\",\n            portString(portIndex), portIndex, buffer,\n            nativeHandle == NULL ? NULL : nativeHandle->handle());\n return OK;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void rgb_to_gray(fz_context *ctx, const fz_colorspace *cs, const float *rgb, float *gray)\n{\n\tfloat r = rgb[0];\n\tfloat g = rgb[1];\n\tfloat b = rgb[2];\n\tgray[0] = r * 0.3f + g * 0.59f + b * 0.11f;\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkcs7_verify)\n{\n\tX509_STORE * store = NULL;\n\tzval * cainfo = NULL;\n\tSTACK_OF(X509) *signers= NULL;\n\tSTACK_OF(X509) *others = NULL;\n\tPKCS7 * p7 = NULL;\n\tBIO * in = NULL, * datain = NULL, * dataout = NULL;\n\tlong flags = 0;\n\tchar * filename; int filename_len;\n\tchar * extracerts = NULL; int extracerts_len = 0;\n\tchar * signersfilename = NULL; int signersfilename_len = 0;\n\tchar * datafilename = NULL; int datafilename_len = 0;\n\t\n\tRETVAL_LONG(-1);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sl|sass\", &filename, &filename_len,\n\t\t\t\t&flags, &signersfilename, &signersfilename_len, &cainfo,\n\t\t\t\t&extracerts, &extracerts_len, &datafilename, &datafilename_len) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (extracerts) {\n\t\tothers = load_all_certs_from_file(extracerts);\n\t\tif (others == NULL) {\n\t\t\tgoto clean_exit;\n\t\t}\n\t}\n\n\tflags = flags & ~PKCS7_DETACHED;\n\n\tstore = setup_verify(cainfo TSRMLS_CC);\n\n\tif (!store) {\n\t\tgoto clean_exit;\n\t}\n\tif (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {\n\t\tgoto clean_exit;\n\t}\n\n\tin = BIO_new_file(filename, (flags & PKCS7_BINARY) ? \"rb\" : \"r\");\n\tif (in == NULL) {\n\t\tgoto clean_exit;\n\t}\n\tp7 = SMIME_read_PKCS7(in, &datain);\n\tif (p7 == NULL) {\n#if DEBUG_SMIME\n\t\tzend_printf(\"SMIME_read_PKCS7 failed\\n\");\n#endif\n\t\tgoto clean_exit;\n\t}\n\n\tif (datafilename) {\n\n\t\tif (php_openssl_safe_mode_chk(datafilename TSRMLS_CC)) {\n\t\t\tgoto clean_exit;\n\t\t}\n\n\t\tdataout = BIO_new_file(datafilename, \"w\");\n\t\tif (dataout == NULL) {\n\t\t\tgoto clean_exit;\n\t\t}\n\t}\n#if DEBUG_SMIME\n\tzend_printf(\"Calling PKCS7 verify\\n\");\n#endif\n\n\tif (PKCS7_verify(p7, others, store, datain, dataout, flags)) {\n\n\t\tRETVAL_TRUE;\n\n\t\tif (signersfilename) {\n\t\t\tBIO *certout;\n\t\t\n\t\t\tif (php_openssl_safe_mode_chk(signersfilename TSRMLS_CC)) {\n\t\t\t\tgoto clean_exit;\n\t\t\t}\n\t\t\n\t\t\tcertout = BIO_new_file(signersfilename, \"w\");\n\t\t\tif (certout) {\n\t\t\t\tint i;\n\t\t\t\tsigners = PKCS7_get0_signers(p7, NULL, flags);\n\n\t\t\t\tfor(i = 0; i < sk_X509_num(signers); i++) {\n\t\t\t\t\tPEM_write_bio_X509(certout, sk_X509_value(signers, i));\n\t\t\t\t}\n\t\t\t\tBIO_free(certout);\n\t\t\t\tsk_X509_free(signers);\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"signature OK, but cannot open %s for writing\", signersfilename);\n\t\t\t\tRETVAL_LONG(-1);\n\t\t\t}\n\t\t}\n\t\tgoto clean_exit;\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\nclean_exit:\n\tX509_STORE_free(store);\n\tBIO_free(datain);\n\tBIO_free(in);\n\tBIO_free(dataout);\n\tPKCS7_free(p7);\n\tsk_X509_free(others);\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"static void encode_frame(vpx_codec_ctx_t *codec,\n                         vpx_image_t *img,\n                         int frame_index,\n                         int flags,\n                         VpxVideoWriter *writer) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1,\n                                               flags, VPX_DL_GOOD_QUALITY);\n if (res != VPX_CODEC_OK)\n\n     die_codec(codec, \"Failed to encode frame\");\n \n   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n       if (!vpx_video_writer_write_frame(writer,\n                                        pkt->data.frame.buf,\n                                        pkt->data.frame.sz,\n\n                                         pkt->data.frame.pts)) {\n         die_codec(codec, \"Failed to write compressed frame\");\n       }\n       printf(keyframe ? \"K\" : \".\");\n       fflush(stdout);\n     }\n   }\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"BlockEntry::Kind Track::EOSBlock::GetKind() const\n{\n    return kBlockEOS;\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static int preg_do_repl_func(zval *function, char *subject, int *offsets, char **subpat_names, int count, char **result TSRMLS_DC)\n{\n\tzval\t\t*retval_ptr;\t\t\/* Function return value *\/\n\tzval\t   **args[1];\t\t\t\/* Argument to pass to function *\/\n\tzval\t\t*subpats;\t\t\t\/* Captured subpatterns *\/ \n\tint\t\t\t result_len;\t\t\/* Return value length *\/\n\tint\t\t\t i;\n\n\tMAKE_STD_ZVAL(subpats);\n\tarray_init(subpats);\n\tfor (i = 0; i < count; i++) {\n\t\tif (subpat_names[i]) {\n\t\t\tadd_assoc_stringl(subpats, subpat_names[i], &subject[offsets[i<<1]] , offsets[(i<<1)+1] - offsets[i<<1], 1);\n\t\t}\n\t\tadd_next_index_stringl(subpats, &subject[offsets[i<<1]], offsets[(i<<1)+1] - offsets[i<<1], 1);\n\t}\n\targs[0] = &subpats;\n\n\tif (call_user_function_ex(EG(function_table), NULL, function, &retval_ptr, 1, args, 0, NULL TSRMLS_CC) == SUCCESS && retval_ptr) {\n\t\tconvert_to_string_ex(&retval_ptr);\n\t\t*result = estrndup(Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n\t\tresult_len = Z_STRLEN_P(retval_ptr);\n\t\tzval_ptr_dtor(&retval_ptr);\n\t} else {\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n\t\t}\n\t\tresult_len = offsets[1] - offsets[0];\n\t\t*result = estrndup(&subject[offsets[0]], result_len);\n\t}\n\n\tzval_ptr_dtor(&subpats);\n\n\treturn result_len;\n}\n","project":"php","target":0},{"commit_id":"c17ad2f0c7e00fd1bbf01d0dfed41f72d78267ad","func":" void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_MINIT_FUNCTION(pcre)\n{\n\tREGISTER_INI_ENTRIES();\n\t\n\tREGISTER_LONG_CONSTANT(\"PREG_PATTERN_ORDER\", PREG_PATTERN_ORDER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_SET_ORDER\", PREG_SET_ORDER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_OFFSET_CAPTURE\", PREG_OFFSET_CAPTURE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_SPLIT_NO_EMPTY\", PREG_SPLIT_NO_EMPTY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_SPLIT_DELIM_CAPTURE\", PREG_SPLIT_DELIM_CAPTURE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_SPLIT_OFFSET_CAPTURE\", PREG_SPLIT_OFFSET_CAPTURE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_GREP_INVERT\", PREG_GREP_INVERT, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"PREG_NO_ERROR\", PHP_PCRE_NO_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_INTERNAL_ERROR\", PHP_PCRE_INTERNAL_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_BACKTRACK_LIMIT_ERROR\", PHP_PCRE_BACKTRACK_LIMIT_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_RECURSION_LIMIT_ERROR\", PHP_PCRE_RECURSION_LIMIT_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_BAD_UTF8_ERROR\", PHP_PCRE_BAD_UTF8_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PREG_BAD_UTF8_OFFSET_ERROR\", PHP_PCRE_BAD_UTF8_OFFSET_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"PCRE_VERSION\", (char *)pcre_version(), CONST_CS | CONST_PERSISTENT);\n\n\treturn SUCCESS;\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Block::SetKey(bool bKey)\n{\n    if (bKey)\n        m_flags |= static_cast<unsigned char>(1 << 7);\n    else\n        m_flags &= 0x7F;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_bgr(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && cs->type == FZ_COLORSPACE_BGR;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Cluster::GetElementSize() const\n{\n    return m_element_size;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Chapters::Edition::ShallowCopy(Edition& rhs) const\n{\n    rhs.m_atoms = m_atoms;\n    rhs.m_atoms_size = m_atoms_size;\n    rhs.m_atoms_count = m_atoms_count;\n }\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static bool samldb_krbtgtnumber_available(struct samldb_ctx *ac,\n\t\t\t\t\t  uint32_t krbtgt_number)\n{\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tret = dsdb_module_search(ac->module, tmp_ctx, &res,\n\t\t\t\t ldb_get_default_basedn(ldb_module_get_ctx(ac->module)),\n\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(msDC-SecondaryKrbTgtNumber=%u)\",\n\t\t\t\t krbtgt_number);\n\tif (ret == LDB_SUCCESS && res->count == 0) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn true;\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn false;\n}\n","project":"samba","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_expand_indexed_pixmap(fz_context *ctx, const fz_pixmap *src, int alpha)\n{\n\tstruct indexed *idx;\n\tfz_pixmap *dst;\n\tconst unsigned char *s;\n\tunsigned char *d;\n\tint y, x, k, n, high;\n\tunsigned char *lookup;\n\tfz_irect bbox;\n\tint s_line_inc, d_line_inc;\n\n\tassert(src->colorspace->to_ccs == indexed_to_rgb || src->colorspace->to_ccs == indexed_to_alt);\n\tassert(src->n == 1 + alpha);\n\n\tidx = src->colorspace->data;\n\thigh = idx->high;\n\tlookup = idx->lookup;\n\tn = idx->base->n;\n\n\tdst = fz_new_pixmap_with_bbox(ctx, idx->base, fz_pixmap_bbox(ctx, src, &bbox), src->seps, alpha);\n\ts = src->samples;\n\td = dst->samples;\n\ts_line_inc = src->stride - src->w * src->n;\n\td_line_inc = dst->stride - dst->w * dst->n;\n\n\tif (alpha)\n\t{\n\t\tfor (y = 0; y < src->h; y++)\n\t\t{\n\t\t\tfor (x = 0; x < src->w; x++)\n\t\t\t{\n\t\t\t\tint v = *s++;\n\t\t\t\tint a = *s++;\n\t\t\t\tint aa = a + (a>>7);\n\t\t\t\tv = fz_mini(v, high);\n\t\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\t\t*d++ = (aa * lookup[v * n + k] + 128)>>8;\n\t\t\t\t*d++ = a;\n\t\t\t}\n\t\t\ts += s_line_inc;\n\t\t\td += d_line_inc;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (y = 0; y < src->h; y++)\n\t\t{\n\t\t\tfor (x = 0; x < src->w; x++)\n\t\t\t{\n\t\t\t\tint v = *s++;\n\t\t\t\tv = fz_mini(v, high);\n\t\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\t\t*d++ = lookup[v * n + k];\n\t\t\t}\n\t\t\ts += s_line_inc;\n\t\t\td += d_line_inc;\n\t\t}\n\t}\n\n\tif (src->flags & FZ_PIXMAP_FLAG_INTERPOLATE)\n\t\tdst->flags |= FZ_PIXMAP_FLAG_INTERPOLATE;\n\telse\n\t\tdst->flags &= ~FZ_PIXMAP_FLAG_INTERPOLATE;\n\n\treturn dst;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_drop_link_key(fz_context *ctx, void *key_)\n{\n\tfz_link_key *key = (fz_link_key *)key_;\n\tif (fz_drop_imp(ctx, key, &key->refs))\n\t\tfz_free(ctx, key);\n}\n","project":"ghostscript","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_BX(fz_context *ctx, pdf_processor *proc)\n{\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"std_conv_color(fz_context *ctx, fz_color_converter *cc, float *dstv, const float *srcv)\n{\n\tfloat rgb[3];\n\tint i;\n\tconst fz_colorspace *srcs = cc->ss;\n\tconst fz_colorspace *dsts = cc->ds;\n\n\tif (srcs == NULL)\n\t\tsrcs = fz_device_rgb(ctx);\n\tif (dsts == NULL)\n\t\tdsts = fz_device_rgb(ctx);\n\n\tif (srcs != dsts)\n\t{\n\t\tassert(srcs->to_ccs && dsts->from_ccs);\n\t\tsrcs->to_ccs(ctx, srcs, srcv, rgb);\n\t\tdsts->from_ccs(ctx, dsts, rgb, dstv);\n\t\tfor (i = 0; i < dsts->n; i++)\n\t\t\tdstv[i] = fz_clamp(dstv[i], 0, 1);\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < srcs->n; i++)\n\t\t\tdstv[i] = srcv[i];\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"check_splay(cmap_splay *tree, unsigned int node, int depth)\n{\n\tif (node == EMPTY)\n\t\treturn;\n\tassert(tree[node].parent == EMPTY);\n\twalk_splay(tree, node, do_check, tree);\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_init (void)\n{\n  aspath_init ();\n  attrhash_init ();\n  community_init ();\n  ecommunity_init ();\n  cluster_init ();\n  transit_init ();\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* SegmentInfo::GetTitleAsUTF8() const\n{\n    return m_pTitleAsUTF8;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Chapters::Atom::Clear()\n{\n    delete[] m_string_uid;\n    m_string_uid = NULL;\n    while (m_displays_count > 0)\n    {\n        Display& d = m_displays[--m_displays_count];\n        d.Clear();\n    }\n    delete[] m_displays;\n    m_displays = NULL;\n    m_displays_size = 0;\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_flag_invalid (struct bgp_attr_parser_args *args)\n{\n  u_int8_t mask = BGP_ATTR_FLAG_EXTLEN;\n  const u_int8_t flags = args->flags;\n  const u_int8_t attr_code = args->type;\n  struct peer *const peer = args->peer; \n  \n  \/* there may be attributes we don't know about *\/\n  if (attr_code > attr_flags_values_max)\n    return 0;\n  if (attr_flags_values[attr_code] == 0)\n    return 0;\n  \n  \/* RFC4271, \"For well-known attributes, the Transitive bit MUST be set to\n   * 1.\"\n   *\/\n  if (!CHECK_FLAG (BGP_ATTR_FLAG_OPTIONAL, flags)\n      && !CHECK_FLAG (BGP_ATTR_FLAG_TRANS, flags))\n    {\n      zlog (peer->log, LOG_ERR,\n            \"%s well-known attributes must have transitive flag set (%x)\",\n            LOOKUP (attr_str, attr_code), flags);\n      return 1;\n    }\n  \n  \/* \"For well-known attributes and for optional non-transitive attributes,\n   *  the Partial bit MUST be set to 0.\" \n   *\/\n  if (CHECK_FLAG (flags, BGP_ATTR_FLAG_PARTIAL))\n    {\n      if (!CHECK_FLAG (flags, BGP_ATTR_FLAG_OPTIONAL))\n        {\n          zlog (peer->log, LOG_ERR,\n                \"%s well-known attribute \"\n                \"must NOT have the partial flag set (%x)\",\n                 LOOKUP (attr_str, attr_code), flags);\n          return 1;\n        }\n      if (CHECK_FLAG (flags, BGP_ATTR_FLAG_OPTIONAL)\n          && !CHECK_FLAG (flags, BGP_ATTR_FLAG_TRANS))\n        {\n          zlog (peer->log, LOG_ERR,\n                \"%s optional + transitive attribute \"\n                \"must NOT have the partial flag set (%x)\",\n                 LOOKUP (attr_str, attr_code), flags);\n          return 1;\n        }\n    }\n  \n  \/* Optional transitive attributes may go through speakers that don't\n   * reocgnise them and set the Partial bit.\n   *\/\n  if (CHECK_FLAG (flags, BGP_ATTR_FLAG_OPTIONAL)\n      && CHECK_FLAG (flags, BGP_ATTR_FLAG_TRANS))\n    SET_FLAG (mask, BGP_ATTR_FLAG_PARTIAL);\n  \n  if ((flags & ~mask)\n      == attr_flags_values[attr_code])\n    return 0;\n  \n  bgp_attr_flags_diagnose (args, attr_flags_values[attr_code]);\n  return 1;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"rgb2cmyk(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tfloat c = 1 - sv[0];\n\tfloat m = 1 - sv[1];\n\tfloat y = 1 - sv[2];\n\tfloat k = fz_min(c, fz_min(m, y));\n\tdv[0] = c - k;\n\tdv[1] = m - k;\n\tdv[2] = y - k;\n\tdv[3] = k;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunInvTxfm(const int16_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride);\n   }\n","project":"Android","target":1},{"commit_id":"51e0cb2e5ec18eaf6fb331bc573ff27b743898f4","func":"xmlParse3986Port(xmlURIPtr uri, const char **str)\n{\n const char *cur = *str;\n unsigned port = 0; \/* unsigned for defined overflow behavior *\/\n\n if (ISA_DIGIT(cur)) {\n while (ISA_DIGIT(cur)) {\n\t    port = port * 10 + (*cur - '0');\n\n\n \t    cur++;\n \t}\n \tif (uri != NULL)\n\t    uri->port = port & INT_MAX; \/* port value modulo INT_MAX+1 *\/\n \t*str = cur;\n \treturn(0);\n     }\n return(1);\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" static void set_active_map(const vpx_codec_enc_cfg_t *cfg,\n                            vpx_codec_ctx_t *codec) {\n   unsigned int i;\n  vpx_active_map_t map = {0};\n \n   map.rows = (cfg->g_h + 15) \/ 16;\n   map.cols = (cfg->g_w + 15) \/ 16;\n\n map.active_map = (uint8_t *)malloc(map.rows * map.cols);\n for (i = 0; i < map.rows * map.cols; ++i)\n map.active_map[i] = i % 2;\n\n if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))\n    die_codec(codec, \"Failed to set active map\");\n\n  free(map.active_map);\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"get_base_icc_profile(fz_context *ctx, const fz_colorspace *cs)\n{\n\tfz_colorspace *base;\n\tfz_cal_colorspace *cal;\n\tfz_iccprofile *cal_icc;\n\n\tif (!cs || !cs->get_base)\n\t\treturn NULL;\n\n\tbase = cs->get_base(cs);\n\tif (base == NULL)\n\t\treturn NULL;\n\n\tif (fz_colorspace_is_icc(ctx, base))\n\t\treturn base->data;\n\tif (!fz_colorspace_is_cal(ctx, base))\n\t\treturn get_base_icc_profile(ctx, base);\n\n\tcal = base->data;\n\tcal_icc = cal->profile;\n\tif (cal_icc && cal_icc->cmm_handle == NULL)\n\t\tfz_cmm_init_profile(ctx, cal_icc);\n\n\treturn cal_icc;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_keep_colorspace(fz_context *ctx, fz_colorspace *cs)\n{\n\treturn fz_keep_key_storable(ctx, &cs->key_storable);\n}\n","project":"ghostscript","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\n\t{\n\tlong l;\n\n\tif (p != NULL)\n\t\t{\n\t\tl=c->id;\n\t\tif ((l & 0xff000000) != 0x03000000) return(0);\n\t\tp[0]=((unsigned char)(l>> 8L))&0xFF;\n\t\tp[1]=((unsigned char)(l     ))&0xFF;\n\t\t}\n\treturn(2);\n\t}\n","project":"openssl","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Track::Seek(\n    long long time_ns,\n    const BlockEntry*& pResult) const\n{\n    const long status = GetFirst(pResult);\n \n    if (status < 0)  \/\/buffer underflow, etc\n        return status;\n \n    assert(pResult);\n \n    if (pResult->EOS())\n        return 0;\n \n    const Cluster* pCluster = pResult->GetCluster();\n     assert(pCluster);\n     assert(pCluster->GetIndex() >= 0);\n \n    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))\n        return 0;\n \n    Cluster** const clusters = m_pSegment->m_clusters;\n    assert(clusters);\n \n    const long count = m_pSegment->GetCount();  \/\/loaded only, not preloaded\n    assert(count > 0);\n \n    Cluster** const i = clusters + pCluster->GetIndex();\n    assert(i);\n    assert(*i == pCluster);\n     assert(pCluster->GetTime() <= time_ns);\n \n    Cluster** const j = clusters + count;\n \n    Cluster** lo = i;\n    Cluster** hi = j;\n \n    while (lo < hi)\n    {\n \n        Cluster** const mid = lo + (hi - lo) \/ 2;\n        assert(mid < hi);\n        pCluster = *mid;\n        assert(pCluster);\n        assert(pCluster->GetIndex() >= 0);\n        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));\n        const long long t = pCluster->GetTime();\n        if (t <= time_ns)\n            lo = mid + 1;\n        else\n            hi = mid;\n        assert(lo <= hi);\n    }\n    assert(lo == hi);\n    assert(lo > i);\n    assert(lo <= j);\n    while (lo > i)\n    {\n        pCluster = *--lo;\n        assert(pCluster);\n        assert(pCluster->GetTime() <= time_ns);\n        pResult = pCluster->GetEntry(this);\n        if ((pResult != 0) && !pResult->EOS())\n            return 0;\n    }\n    pResult = GetEOS();  \/\/weird\n    return 0;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::GetNext(\n    const BlockEntry* pCurr,\n    const BlockEntry*& pNext) const\n{\n    assert(pCurr);\n     assert(m_entries);\n     assert(m_entries_count > 0);\n    size_t idx = pCurr->GetIndex();\n     assert(idx < size_t(m_entries_count));\n    assert(m_entries[idx] == pCurr);\n \n    ++idx;\n \n    if (idx >= size_t(m_entries_count))\n    {\n        long long pos;\n        long len;\n        const long status = Parse(pos, len);\n        if (status < 0)  \/\/error\n        {\n            pNext = NULL;\n            return status;\n        }\n        if (status > 0)\n        {\n            pNext = NULL;\n            return 0;\n        }\n        assert(m_entries);\n        assert(m_entries_count > 0);\n        assert(idx < size_t(m_entries_count));\n    }\n    pNext = m_entries[idx];\n    assert(pNext);\n    return 0;\n }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_create_signature(phar_archive_data *phar, php_stream *fp, char **signature, int *signature_length, char **error TSRMLS_DC) \/* {{{ *\/\n{\n\tunsigned char buf[1024];\n\tint sig_len;\n\n\tphp_stream_rewind(fp);\n\n\tif (phar->signature) {\n\t\tefree(phar->signature);\n\t\tphar->signature = NULL;\n\t}\n\n\tswitch(phar->sig_flags) {\n#ifdef PHAR_HASH_OK\n\t\tcase PHAR_SIG_SHA512: {\n\t\t\tunsigned char digest[64];\n\t\t\tPHP_SHA512_CTX context;\n\n\t\t\tPHP_SHA512Init(&context);\n\n\t\t\twhile ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {\n\t\t\t\tPHP_SHA512Update(&context, buf, sig_len);\n\t\t\t}\n\n\t\t\tPHP_SHA512Final(digest, &context);\n\t\t\t*signature = estrndup((char *) digest, 64);\n\t\t\t*signature_length = 64;\n\t\t\tbreak;\n\t\t}\n\t\tcase PHAR_SIG_SHA256: {\n\t\t\tunsigned char digest[32];\n\t\t\tPHP_SHA256_CTX  context;\n\n\t\t\tPHP_SHA256Init(&context);\n\n\t\t\twhile ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {\n\t\t\t\tPHP_SHA256Update(&context, buf, sig_len);\n\t\t\t}\n\n\t\t\tPHP_SHA256Final(digest, &context);\n\t\t\t*signature = estrndup((char *) digest, 32);\n\t\t\t*signature_length = 32;\n\t\t\tbreak;\n\t\t}\n#else\n\t\tcase PHAR_SIG_SHA512:\n\t\tcase PHAR_SIG_SHA256:\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write to phar \\\"%s\\\" with requested hash type\", phar->fname);\n\t\t\t}\n\n\t\t\treturn FAILURE;\n#endif\n\t\tcase PHAR_SIG_OPENSSL: {\n\t\t\tint siglen;\n\t\t\tunsigned char *sigbuf;\n#ifdef PHAR_HAVE_OPENSSL\n\t\t\tBIO *in;\n\t\t\tEVP_PKEY *key;\n\t\t\tEVP_MD_CTX *md_ctx;\n\n\t\t\tin = BIO_new_mem_buf(PHAR_G(openssl_privatekey), PHAR_G(openssl_privatekey_len));\n\n\t\t\tif (in == NULL) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write to phar \\\"%s\\\" with requested openssl signature\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tkey = PEM_read_bio_PrivateKey(in, NULL,NULL, \"\");\n\t\t\tBIO_free(in);\n\n\t\t\tif (!key) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to process private key\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tmd_ctx = EVP_MD_CTX_create();\n\n\t\t\tsiglen = EVP_PKEY_size(key);\n\t\t\tsigbuf = emalloc(siglen + 1);\n\n\t\t\tif (!EVP_SignInit(md_ctx, EVP_sha1())) {\n\t\t\t\tefree(sigbuf);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to initialize openssl signature for phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\twhile ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {\n\t\t\t\tif (!EVP_SignUpdate(md_ctx, buf, sig_len)) {\n\t\t\t\t\tefree(sigbuf);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"unable to update the openssl signature for phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!EVP_SignFinal (md_ctx, sigbuf,(unsigned int *)&siglen, key)) {\n\t\t\t\tefree(sigbuf);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write phar \\\"%s\\\" with requested openssl signature\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tsigbuf[siglen] = '\\0';\n\t\t\tEVP_MD_CTX_destroy(md_ctx);\n#else\n\t\t\tsigbuf = NULL;\n\t\t\tsiglen = 0;\n\t\t\tphp_stream_seek(fp, 0, SEEK_END);\n\n\t\t\tif (FAILURE == phar_call_openssl_signverify(1, fp, php_stream_tell(fp), PHAR_G(openssl_privatekey), PHAR_G(openssl_privatekey_len), (char **)&sigbuf, &siglen TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write phar \\\"%s\\\" with requested openssl signature\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n#endif\n\t\t\t*signature = (char *) sigbuf;\n\t\t\t*signature_length = siglen;\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tphar->sig_flags = PHAR_SIG_SHA1;\n\t\tcase PHAR_SIG_SHA1: {\n\t\t\tunsigned char digest[20];\n\t\t\tPHP_SHA1_CTX  context;\n\n\t\t\tPHP_SHA1Init(&context);\n\n\t\t\twhile ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {\n\t\t\t\tPHP_SHA1Update(&context, buf, sig_len);\n\t\t\t}\n\n\t\t\tPHP_SHA1Final(digest, &context);\n\t\t\t*signature = estrndup((char *) digest, 20);\n\t\t\t*signature_length = 20;\n\t\t\tbreak;\n\t\t}\n\t\tcase PHAR_SIG_MD5: {\n\t\t\tunsigned char digest[16];\n\t\t\tPHP_MD5_CTX   context;\n\n\t\t\tPHP_MD5Init(&context);\n\n\t\t\twhile ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {\n\t\t\t\tPHP_MD5Update(&context, buf, sig_len);\n\t\t\t}\n\n\t\t\tPHP_MD5Final(digest, &context);\n\t\t\t*signature = estrndup((char *) digest, 16);\n\t\t\t*signature_length = 16;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tphar->sig_len = phar_hex_str((const char *)*signature, *signature_length, &phar->signature TSRMLS_CC);\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"unsigned long long Track::GetCodecDelay() const\n{\n    return m_info.codecDelay;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Track::Info::Clear()\n{\n    delete[] nameAsUTF8;\n    nameAsUTF8 = NULL;\n \n    delete[] language;\n    language = NULL;\n \n    delete[] codecId;\n    codecId = NULL;\n    delete[] codecPrivate;\n    codecPrivate = NULL;\n    codecPrivateSize = 0;\n    delete[] codecNameAsUTF8;\n    codecNameAsUTF8 = NULL;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"clamp_default(const fz_colorspace *cs, const float *src, float *dst)\n{\n\tint i;\n\n\tfor (i = 0; i < cs->n; i++)\n\t\tdst[i] = fz_clamp(src[i], 0, 1);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void RunInvAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       double out_r[kNumCoeffs];\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        in[j] = src[j] - dst[j];\n       }\n \n       reference_16x16_dct_2d(in, out_r);\n       for (int j = 0; j < kNumCoeffs; ++j)\n        coeff[j] = round(out_r[j]);\n \n      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n         EXPECT_GE(1u, error)\n             << \"Error: 16x16 IDCT has error \" << error\n << \" at index \" << j;\n\n       }\n     }\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Segment::~Segment()\n{\n    const long count = m_clusterCount + m_clusterPreloadCount;\n \n    Cluster** i = m_clusters;\n    Cluster** j = m_clusters + count;\n \n    while (i != j)\n    {\n        Cluster* const p = *i++;\n        assert(p);\n \n        delete p;\n    }\n \n    delete[] m_clusters;\n \n    delete m_pTracks;\n    delete m_pInfo;\n    delete m_pCues;\n    delete m_pChapters;\n    delete m_pSeekHead;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_MINIT_FUNCTION(openssl)\n{\n\tchar * config_filename;\n\n\tle_key = zend_register_list_destructors_ex(php_pkey_free, NULL, \"OpenSSL key\", module_number);\n\tle_x509 = zend_register_list_destructors_ex(php_x509_free, NULL, \"OpenSSL X.509\", module_number);\n\tle_csr = zend_register_list_destructors_ex(php_csr_free, NULL, \"OpenSSL X.509 CSR\", module_number);\n\n\tSSL_library_init();\n\tOpenSSL_add_all_ciphers();\n\tOpenSSL_add_all_digests();\n\tOpenSSL_add_all_algorithms();\n\n\tERR_load_ERR_strings();\n\tERR_load_crypto_strings();\n\tERR_load_EVP_strings();\n\n\t\/* register a resource id number with OpenSSL so that we can map SSL -> stream structures in\n\t * OpenSSL callbacks *\/\n\tssl_stream_data_index = SSL_get_ex_new_index(0, \"PHP stream index\", NULL, NULL, NULL);\n\t\n\tREGISTER_STRING_CONSTANT(\"OPENSSL_VERSION_TEXT\", OPENSSL_VERSION_TEXT, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_VERSION_NUMBER\", OPENSSL_VERSION_NUMBER, CONST_CS|CONST_PERSISTENT);\n\t\n\t\/* purposes for cert purpose checking *\/\n\tREGISTER_LONG_CONSTANT(\"X509_PURPOSE_SSL_CLIENT\", X509_PURPOSE_SSL_CLIENT, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"X509_PURPOSE_SSL_SERVER\", X509_PURPOSE_SSL_SERVER, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"X509_PURPOSE_NS_SSL_SERVER\", X509_PURPOSE_NS_SSL_SERVER, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"X509_PURPOSE_SMIME_SIGN\", X509_PURPOSE_SMIME_SIGN, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"X509_PURPOSE_SMIME_ENCRYPT\", X509_PURPOSE_SMIME_ENCRYPT, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"X509_PURPOSE_CRL_SIGN\", X509_PURPOSE_CRL_SIGN, CONST_CS|CONST_PERSISTENT);\n#ifdef X509_PURPOSE_ANY\n\tREGISTER_LONG_CONSTANT(\"X509_PURPOSE_ANY\", X509_PURPOSE_ANY, CONST_CS|CONST_PERSISTENT);\n#endif\n\n\t\/* signature algorithm constants *\/\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_ALGO_SHA1\", OPENSSL_ALGO_SHA1, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_ALGO_MD5\", OPENSSL_ALGO_MD5, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_ALGO_MD4\", OPENSSL_ALGO_MD4, CONST_CS|CONST_PERSISTENT);\n#ifdef HAVE_OPENSSL_MD2_H\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_ALGO_MD2\", OPENSSL_ALGO_MD2, CONST_CS|CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_ALGO_DSS1\", OPENSSL_ALGO_DSS1, CONST_CS|CONST_PERSISTENT);\n\n\t\/* flags for S\/MIME *\/\n\tREGISTER_LONG_CONSTANT(\"PKCS7_DETACHED\", PKCS7_DETACHED, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PKCS7_TEXT\", PKCS7_TEXT, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PKCS7_NOINTERN\", PKCS7_NOINTERN, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PKCS7_NOVERIFY\", PKCS7_NOVERIFY, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PKCS7_NOCHAIN\", PKCS7_NOCHAIN, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PKCS7_NOCERTS\", PKCS7_NOCERTS, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PKCS7_NOATTR\", PKCS7_NOATTR, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PKCS7_BINARY\", PKCS7_BINARY, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PKCS7_NOSIGS\", PKCS7_NOSIGS, CONST_CS|CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_PKCS1_PADDING\", RSA_PKCS1_PADDING, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_SSLV23_PADDING\", RSA_SSLV23_PADDING, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_NO_PADDING\", RSA_NO_PADDING, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_PKCS1_OAEP_PADDING\", RSA_PKCS1_OAEP_PADDING, CONST_CS|CONST_PERSISTENT);\n\n\t\/* Ciphers *\/\n#ifndef OPENSSL_NO_RC2\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_CIPHER_RC2_40\", PHP_OPENSSL_CIPHER_RC2_40, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_CIPHER_RC2_128\", PHP_OPENSSL_CIPHER_RC2_128, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_CIPHER_RC2_64\", PHP_OPENSSL_CIPHER_RC2_64, CONST_CS|CONST_PERSISTENT);\n#endif\n#ifndef OPENSSL_NO_DES\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_CIPHER_DES\", PHP_OPENSSL_CIPHER_DES, CONST_CS|CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_CIPHER_3DES\", PHP_OPENSSL_CIPHER_3DES, CONST_CS|CONST_PERSISTENT);\n#endif\n\n\t\/* Values for key types *\/\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_KEYTYPE_RSA\", OPENSSL_KEYTYPE_RSA, CONST_CS|CONST_PERSISTENT);\n#ifndef NO_DSA\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_KEYTYPE_DSA\", OPENSSL_KEYTYPE_DSA, CONST_CS|CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_KEYTYPE_DH\", OPENSSL_KEYTYPE_DH, CONST_CS|CONST_PERSISTENT);\n#ifdef EVP_PKEY_EC\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_KEYTYPE_EC\", OPENSSL_KEYTYPE_EC, CONST_CS|CONST_PERSISTENT);\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n\t\/* SNI support included in OpenSSL >= 0.9.8j *\/\n\tREGISTER_LONG_CONSTANT(\"OPENSSL_TLSEXT_SERVER_NAME\", 1, CONST_CS|CONST_PERSISTENT);\n#endif\n\n\t\/* Determine default SSL configuration file *\/\n\tconfig_filename = getenv(\"OPENSSL_CONF\");\n\tif (config_filename == NULL) {\n\t\tconfig_filename = getenv(\"SSLEAY_CONF\");\n\t}\n\n\t\/* default to 'openssl.cnf' if no environment variable is set *\/\n\tif (config_filename == NULL) {\n\t\tsnprintf(default_ssl_conf_filename, sizeof(default_ssl_conf_filename), \"%s\/%s\",\n\t\t\t\tX509_get_default_cert_area(),\n\t\t\t\t\"openssl.cnf\");\n\t} else {\n\t\tstrlcpy(default_ssl_conf_filename, config_filename, sizeof(default_ssl_conf_filename));\n\t}\n\n\tphp_stream_xport_register(\"ssl\", php_openssl_ssl_socket_factory TSRMLS_CC);\n\tphp_stream_xport_register(\"sslv3\", php_openssl_ssl_socket_factory TSRMLS_CC);\n#ifndef OPENSSL_NO_SSL2\n\tphp_stream_xport_register(\"sslv2\", php_openssl_ssl_socket_factory TSRMLS_CC);\n#endif\n\tphp_stream_xport_register(\"tls\", php_openssl_ssl_socket_factory TSRMLS_CC);\n\n\t\/* override the default tcp socket provider *\/\n\tphp_stream_xport_register(\"tcp\", php_openssl_ssl_socket_factory TSRMLS_CC);\n\n\tphp_register_url_stream_wrapper(\"https\", &php_stream_http_wrapper TSRMLS_CC);\n\tphp_register_url_stream_wrapper(\"ftps\", &php_stream_ftp_wrapper TSRMLS_CC);\n\t\n\treturn SUCCESS;\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" void VarianceTest<VarianceFunctionType>::ZeroTest() {\n   for (int i = 0; i <= 255; ++i) {\n    memset(src_, i, block_size_);\n     for (int j = 0; j <= 255; ++j) {\n      memset(ref_, j, block_size_);\n       unsigned int sse;\n       unsigned int var;\n      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n      EXPECT_EQ(0u, var) << \"src values: \" << i << \"ref values: \" << j;\n     }\n   }\n }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_cluster_list (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  \/* Check length. *\/\n  if (length % 4)\n    {\n      zlog (peer->log, LOG_ERR, \"Bad cluster list length %d\", length);\n\n      return bgp_attr_malformed (args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n\n  (bgp_attr_extra_get (attr))->cluster \n    = cluster_parse ((struct in_addr *)stream_pnt (peer->ibuf), length);\n  \n  \/* XXX: Fix cluster_parse to use stream API and then remove this *\/\n  stream_forward_getp (peer->ibuf, length);\n\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_CLUSTER_LIST);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_loop_check (struct cluster_list *cluster, struct in_addr originator)\n{\n  int i;\n    \n  for (i = 0; i < cluster->length \/ 4; i++)\n    if (cluster->list[i].s_addr == originator.s_addr)\n      return 1;\n  return 0;\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" void RunRoundTripErrorCheck() {\n ACMRandom rnd(ACMRandom::DeterministicSeed());\n\n     int max_error = 0;\n     int total_error = 0;\n     const int count_test_block = 100000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        test_input_block[j] = src[j] - dst[j];\n       }\n \n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_temp_block, pitch_));\n       for (int j = 0; j < 64; ++j) {\n           if (test_temp_block[j] > 0) {\n            test_temp_block[j] += 2;\n            test_temp_block[j] \/= 4;\n            test_temp_block[j] *= 4;\n } else {\n            test_temp_block[j] -= 2;\n            test_temp_block[j] \/= 4;\n\n             test_temp_block[j] *= 4;\n           }\n       }\n      REGISTER_STATE_CHECK(\n          RunInvTxfm(test_temp_block, dst, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n         const int diff = dst[j] - src[j];\n         const int error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n        total_error += error;\n\n       }\n     }\n \n    EXPECT_GE(1, max_error)\n       << \"Error: 8x8 FDCT\/IDCT or FHT\/IHT has an individual\"\n       << \" roundtrip error > 1\";\n \n    EXPECT_GE(count_test_block\/5, total_error)\n       << \"Error: 8x8 FDCT\/IDCT or FHT\/IHT has average roundtrip \"\n       << \"error > 1\/5 per block\";\n   }\n","project":"Android","target":1},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"int main(int argc, char *argv[])\n{\n\tint opt;\n\tchar *line;\n\n\tprogname = basename(argv[0]);\n\n#if POSIXLY_CORRECT\n\tcmd_line_options = POSIXLY_CMD_LINE_OPTIONS;\n#else\n\tif (getenv(POSIXLY_CORRECT_STR))\n\t\tposixly_correct = 1;\n\tif (!posixly_correct)\n\t\tcmd_line_options = CMD_LINE_OPTIONS;\n\telse\n\t\tcmd_line_options = POSIXLY_CMD_LINE_OPTIONS;\n#endif\n\n\tsetlocale(LC_CTYPE, \"\");\n\tsetlocale(LC_MESSAGES, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\n\t\/* Align `#effective:' comments to column 40 for tty's *\/\n\tif (!posixly_correct && isatty(fileno(stdout)))\n\t\tprint_options |= TEXT_SMART_INDENT;\n\n\twhile ((opt = getopt_long(argc, argv, cmd_line_options,\n\t\t                 long_options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\t\tcase 'a':  \/* acl only *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_print_acl = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd':  \/* default acl only *\/\n\t\t\t\topt_print_default_acl = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':  \/* no comments *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_comments = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'e':  \/* all #effective comments *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\tprint_options |= TEXT_ALL_EFFECTIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':  \/* no #effective comments *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\tprint_options &= ~(TEXT_SOME_EFFECTIVE |\n\t\t\t\t                   TEXT_ALL_EFFECTIVE);\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':  \/* recursive *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_RECURSIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'L':  \/* follow all symlinks *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_LOGICAL;\n\t\t\t\twalk_flags &= ~WALK_TREE_PHYSICAL;\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':  \/* skip all symlinks *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_PHYSICAL;\n\t\t\t\twalk_flags &= ~WALK_TREE_LOGICAL;\n\t\t\t\tbreak;\n\n\t\t\tcase 's':  \/* skip files with only base entries *\/\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_skip_base = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_strip_leading_slash = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_tabular = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':  \/* numeric *\/\n\t\t\t\topt_numeric = 1;\n\t\t\t\tprint_options |= TEXT_NUMERIC_IDS;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':  \/* print version *\/\n\t\t\t\tprintf(\"%s \" VERSION \"\\n\", progname);\n\t\t\t\treturn 0;\n\n\t\t\tcase 'h':  \/* help *\/\n\t\t\t\thelp();\n\t\t\t\treturn 0;\n\n\t\t\tcase ':':  \/* option missing *\/\n\t\t\tcase '?':  \/* unknown option *\/\n\t\t\tdefault:\n\t\t\t\tgoto synopsis;\n\t\t}\n\t}\n\n\tif (!(opt_print_acl || opt_print_default_acl)) {\n\t\topt_print_acl = 1;\n\t\tif (!posixly_correct)\n\t\t\topt_print_default_acl = 1;\n\t}\n\t\t\n\tif ((optind == argc) && !posixly_correct)\n\t\tgoto synopsis;\n\n\tdo {\n\t\tif (optind == argc ||\n\t\t    strcmp(argv[optind], \"-\") == 0) {\n\t\t\twhile ((line = next_line(stdin)) != NULL) {\n\t\t\t\tif (*line == '\\0')\n\t\t\t\t\tcontinue;\n\n\t\t\t\thad_errors += walk_tree(line, walk_flags, 0,\n\t\t\t\t\t\t\tdo_print, NULL);\n\t\t\t}\n\t\t\tif (!feof(stdin)) {\n\t\t\t\tfprintf(stderr, _(\"%s: Standard input: %s\\n\"),\n\t\t\t\t        progname, strerror(errno));\n\t\t\t\thad_errors++;\n\t\t\t}\n\t\t} else\n\t\t\thad_errors += walk_tree(argv[optind], walk_flags, 0,\n\t\t\t\t\t\tdo_print, NULL);\n\t\toptind++;\n\t} while (optind < argc);\n\n\treturn had_errors ? 1 : 0;\n\nsynopsis:\n\tfprintf(stderr, _(\"Usage: %s [-%s] file ...\\n\"),\n\t        progname, cmd_line_options);\n\tfprintf(stderr, _(\"Try `%s --help' for more information.\\n\"),\n\t\tprogname);\n\treturn 2;\n}\n","project":"savannah","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftMPEG4Encoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamVideoBitrate:\n {\n\n             OMX_VIDEO_PARAM_BITRATETYPE *bitRate =\n                 (OMX_VIDEO_PARAM_BITRATETYPE *) params;\n \n             if (bitRate->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            bitRate->eControlRate = OMX_Video_ControlRateVariable;\n            bitRate->nTargetBitrate = mBitrate;\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoH263:\n {\n\n             OMX_VIDEO_PARAM_H263TYPE *h263type =\n                 (OMX_VIDEO_PARAM_H263TYPE *)params;\n \n             if (h263type->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            h263type->nAllowedPictureTypes =\n (OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP);\n            h263type->eProfile = OMX_VIDEO_H263ProfileBaseline;\n            h263type->eLevel = OMX_VIDEO_H263Level45;\n            h263type->bPLUSPTYPEAllowed = OMX_FALSE;\n            h263type->bForceRoundingTypeToZero = OMX_FALSE;\n            h263type->nPictureHeaderRepetition = 0;\n            h263type->nGOBHeaderInterval = 0;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamVideoMpeg4:\n {\n\n             OMX_VIDEO_PARAM_MPEG4TYPE *mpeg4type =\n                 (OMX_VIDEO_PARAM_MPEG4TYPE *)params;\n \n             if (mpeg4type->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mpeg4type->eProfile = OMX_VIDEO_MPEG4ProfileCore;\n            mpeg4type->eLevel = OMX_VIDEO_MPEG4Level2;\n            mpeg4type->nAllowedPictureTypes =\n (OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP);\n            mpeg4type->nBFrames = 0;\n            mpeg4type->nIDCVLCThreshold = 0;\n            mpeg4type->bACPred = OMX_TRUE;\n            mpeg4type->nMaxPacketSize = 256;\n            mpeg4type->nTimeIncRes = 1000;\n            mpeg4type->nHeaderExtension = 0;\n            mpeg4type->bReversibleVLC = OMX_FALSE;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SoftVideoEncoderOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_mp_unreach_parse (struct bgp_attr_parser_args *args,\n\t\t      struct bgp_nlri *mp_withdraw)\n{\n  struct stream *s;\n  afi_t afi;\n  safi_t safi;\n  u_int16_t withdraw_len;\n  int ret;\n  struct peer *const peer = args->peer;  \n  const bgp_size_t length = args->length;\n\n  s = peer->ibuf;\n  \n#define BGP_MP_UNREACH_MIN_SIZE 3\n  if ((length > STREAM_READABLE(s)) || (length <  BGP_MP_UNREACH_MIN_SIZE))\n    return BGP_ATTR_PARSE_ERROR;\n  \n  afi = stream_getw (s);\n  safi = stream_getc (s);\n  \n  withdraw_len = length - BGP_MP_UNREACH_MIN_SIZE;\n\n  if (safi != SAFI_MPLS_LABELED_VPN)\n    {\n      ret = bgp_nlri_sanity_check (peer, afi, stream_pnt (s), withdraw_len);\n      if (ret < 0)\n\treturn BGP_ATTR_PARSE_ERROR;\n    }\n\n  mp_withdraw->afi = afi;\n  mp_withdraw->safi = safi;\n  mp_withdraw->nlri = stream_pnt (s);\n  mp_withdraw->length = withdraw_len;\n\n  stream_forward_getp (s, withdraw_len);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_error_string)\n{\n\tchar buf[512];\n\tunsigned long val;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tval = ERR_get_error();\n\tif (val) {\n\t\tRETURN_STRING(ERR_error_string(val, buf), 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":" ContentEncoding::~ContentEncoding() {\n   ContentCompression** comp_i = compression_entries_;\n ContentCompression** const comp_j = compression_entries_end_;\n\n while (comp_i != comp_j) {\n ContentCompression* const comp = *comp_i++;\n\n     delete comp;\n   }\n \n  delete [] compression_entries_;\n \n   ContentEncryption** enc_i = encryption_entries_;\n   ContentEncryption** const enc_j = encryption_entries_end_;\n\n while (enc_i != enc_j) {\n ContentEncryption* const enc = *enc_i++;\n\n     delete enc;\n   }\n \n  delete [] encryption_entries_;\n }\n","project":"Android","target":1},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"static const char *xquote(const char *str, const char *quote_chars)\n{\n\tconst char *q = quote(str, quote_chars);\n\tif (q == NULL) {\n\t\tfprintf(stderr, \"%s: %s\\n\", progname, strerror(errno));\n\t\texit(1);\n\t}\n\treturn q;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_drop_colorspace_context(fz_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\tif (fz_drop_imp(ctx, ctx->colorspace, &ctx->colorspace->ctx_refs))\n\t{\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->gray);\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->rgb);\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->bgr);\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->cmyk);\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->lab);\n\t\tfz_drop_cmm_context(ctx);\n\t\tfz_free(ctx, ctx->colorspace);\n\t\tctx->colorspace = NULL;\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunInvTxfm(int16_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride, tx_type_);\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Chapters::Atom::GetStartTimecode() const\n{\n    return m_start_timecode;\n}\n","project":"Android","target":1},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_lookup_cmap_full(pdf_cmap *cmap, unsigned int cpt, int *out)\n{\n\tpdf_range *ranges = cmap->ranges;\n\tpdf_xrange *xranges = cmap->xranges;\n\tpdf_mrange *mranges = cmap->mranges;\n\tunsigned int i;\n\tint l, r, m;\n\n\tl = 0;\n\tr = cmap->rlen - 1;\n\twhile (l <= r)\n\t{\n\t\tm = (l + r) >> 1;\n\t\tif (cpt < ranges[m].low)\n\t\t\tr = m - 1;\n\t\telse if (cpt > ranges[m].high)\n\t\t\tl = m + 1;\n\t\telse\n\t\t{\n\t\t\tout[0] = cpt - ranges[m].low + ranges[m].out;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tl = 0;\n\tr = cmap->xlen - 1;\n\twhile (l <= r)\n\t{\n\t\tm = (l + r) >> 1;\n\t\tif (cpt < xranges[m].low)\n\t\t\tr = m - 1;\n\t\telse if (cpt > xranges[m].high)\n\t\t\tl = m + 1;\n\t\telse\n\t\t{\n\t\t\tout[0] = cpt - xranges[m].low + xranges[m].out;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tl = 0;\n\tr = cmap->mlen - 1;\n\twhile (l <= r)\n\t{\n\t\tm = (l + r) >> 1;\n\t\tif (cpt < mranges[m].low)\n\t\t\tr = m - 1;\n\t\telse if (cpt > mranges[m].low)\n\t\t\tl = m + 1;\n\t\telse\n\t\t{\n\t\t\tint *ptr = &cmap->dict[cmap->mranges[m].out];\n\t\t\tunsigned int len = (unsigned int)*ptr++;\n\t\t\tfor (i = 0; i < len; ++i)\n\t\t\t\tout[i] = *ptr++;\n\t\t\treturn len;\n\t\t}\n\t}\n\n\tif (cmap->usecmap)\n\t\treturn pdf_lookup_cmap_full(cmap->usecmap, cpt, out);\n\n\treturn 0;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Tracks::ParseTrackEntry(\n    long long track_start,\n    long long track_size,\n    long long element_start,\n    long long element_size,\n    Track*& pResult) const\n{\n    if (pResult)\n        return -1;\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long pos = track_start;\n    const long long track_stop = track_start + track_size;\n    Track::Info info;\n    info.type = 0;\n    info.number = 0;\n    info.uid = 0;\n    info.defaultDuration = 0;\n    Track::Settings v;\n    v.start = -1;\n    v.size = -1;\n    Track::Settings a;\n    a.start = -1;\n    a.size = -1;\n    Track::Settings e;  \/\/content_encodings_settings;\n    e.start = -1;\n    e.size = -1;\n    long long lacing = 1;  \/\/default is true\n    while (pos < track_stop)\n    {\n        long long id, size;\n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                track_stop,\n                                id,\n                                size);\n        if (status < 0)  \/\/error\n            return status;\n        if (size < 0)\n            return E_FILE_FORMAT_INVALID;\n        const long long start = pos;\n        if (id == 0x60)  \/\/ VideoSettings ID\n        {\n            v.start = start;\n            v.size = size;\n        }\n        else if (id == 0x61)  \/\/ AudioSettings ID\n        {\n            a.start = start;\n            a.size = size;\n        }\n        else if (id == 0x2D80) \/\/ ContentEncodings ID\n        {\n            e.start = start;\n            e.size = size;\n        }\n        else if (id == 0x33C5)  \/\/Track UID\n        {\n            if (size > 8)\n                return E_FILE_FORMAT_INVALID;\n            info.uid = 0;\n            long long pos_ = start;\n            const long long pos_end = start + size;\n            while (pos_ != pos_end)\n            {\n                unsigned char b;\n                const int status = pReader->Read(pos_, 1, &b);\n                if (status)\n                    return status;\n                info.uid <<= 8;\n                info.uid |= b;\n                ++pos_;\n            }\n        }\n        else if (id == 0x57)  \/\/Track Number\n        {\n            const long long num = UnserializeUInt(pReader, pos, size);\n            if ((num <= 0) || (num > 127))\n                return E_FILE_FORMAT_INVALID;\n            info.number = static_cast<long>(num);\n        }\n        else if (id == 0x03)  \/\/Track Type\n        {\n            const long long type = UnserializeUInt(pReader, pos, size);\n            if ((type <= 0) || (type > 254))\n                return E_FILE_FORMAT_INVALID;\n            info.type = static_cast<long>(type);\n        }\n        else if (id == 0x136E)  \/\/Track Name\n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    info.nameAsUTF8);\n            if (status)\n                return status;\n        }\n        else if (id == 0x02B59C)  \/\/Track Language\n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    info.language);\n            if (status)\n                return status;\n        }\n        else if (id == 0x03E383)  \/\/Default Duration\n        {\n            const long long duration = UnserializeUInt(pReader, pos, size);\n            if (duration < 0)\n                return E_FILE_FORMAT_INVALID;\n            info.defaultDuration = static_cast<unsigned long long>(duration);\n        }\n        else if (id == 0x06)  \/\/CodecID\n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    info.codecId);\n            if (status)\n                return status;\n        }\n        else if (id == 0x1C)  \/\/lacing\n        {\n            lacing = UnserializeUInt(pReader, pos, size);\n            if ((lacing < 0) || (lacing > 1))\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x23A2)  \/\/Codec Private\n        {\n            delete[] info.codecPrivate;\n            info.codecPrivate = NULL;\n            info.codecPrivateSize = 0;\n            const size_t buflen = static_cast<size_t>(size);\n            if (buflen)\n            {\n                typedef unsigned char* buf_t;\n                const buf_t buf = new (std::nothrow) unsigned char[buflen];\n                if (buf == NULL)\n                    return -1;\n                const int status = pReader->Read(pos, buflen, buf);\n                if (status)\n                {\n                    delete[] buf;\n                    return status;\n                }\n                info.codecPrivate = buf;\n                info.codecPrivateSize = buflen;\n            }\n        }\n        else if (id == 0x058688)  \/\/Codec Name\n        {\n            const long status = UnserializeString(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    info.codecNameAsUTF8);\n            if (status)\n                return status;\n        }\n        else if (id == 0x16AA)  \/\/Codec Delay\n        {\n            info.codecDelay = UnserializeUInt(pReader, pos, size);\n        }\n        else if (id == 0x16BB) \/\/Seek Pre Roll\n        {\n            info.seekPreRoll = UnserializeUInt(pReader, pos, size);\n        }\n        pos += size;  \/\/consume payload\n        assert(pos <= track_stop);\n    }\n    assert(pos == track_stop);\n    if (info.number <= 0)  \/\/not specified\n        return E_FILE_FORMAT_INVALID;\n    if (GetTrackByNumber(info.number))\n        return E_FILE_FORMAT_INVALID;\n    if (info.type <= 0)  \/\/not specified\n        return E_FILE_FORMAT_INVALID;\n    info.lacing = (lacing > 0) ? true : false;\n    if (info.type == Track::kVideo)\n    {\n        if (v.start < 0)\n            return E_FILE_FORMAT_INVALID;\n        if (a.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        info.settings = v;\n        VideoTrack* pTrack = NULL;\n        const long status = VideoTrack::Parse(m_pSegment,\n                                              info,\n                                              element_start,\n                                              element_size,\n                                              pTrack);\n        if (status)\n            return status;\n        pResult = pTrack;\n        assert(pResult);\n        if (e.start >= 0)\n            pResult->ParseContentEncodingsEntry(e.start, e.size);\n    }\n    else if (info.type == Track::kAudio)\n    {\n        if (a.start < 0)\n            return E_FILE_FORMAT_INVALID;\n        if (v.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        info.settings = a;\n        AudioTrack* pTrack = NULL;\n        const long status = AudioTrack::Parse(m_pSegment,\n                                              info,\n                                              element_start,\n                                              element_size,\n                                              pTrack);\n        if (status)\n            return status;\n        pResult = pTrack;\n        assert(pResult);\n        if (e.start >= 0)\n            pResult->ParseContentEncodingsEntry(e.start, e.size);\n    }\n    else\n    {\n        if (a.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        if (v.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        if (e.start >= 0)\n            return E_FILE_FORMAT_INVALID;\n        info.settings.start = -1;\n        info.settings.size = 0;\n        Track* pTrack = NULL;\n        const long status = Track::Create(m_pSegment,\n                                          info,\n                                          element_start,\n                                          element_size,\n                                          pTrack);\n        if (status)\n            return status;\n        pResult = pTrack;\n        assert(pResult);\n    }\n    return 0;  \/\/success\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Chapters::Display* Chapters::Atom::GetDisplay(int index) const\n{\n    if (index < 0)\n        return NULL;\n    if (index >= m_displays_count)\n        return NULL;\n    return m_displays + index;\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"PHPAPI char *php_pcre_replace(char *regex,   int regex_len,\n\t\t\t\t\t\t\t  char *subject, int subject_len,\n\t\t\t\t\t\t\t  zval *replace_val, int is_callable_replace,\n\t\t\t\t\t\t\t  int *result_len, int limit, int *replace_count TSRMLS_DC)\n{\n\tpcre_cache_entry\t*pce;\t\t\t    \/* Compiled regular expression *\/\n\n\t\/* Compile regex or get it from cache. *\/\n\tif ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {\n\t\treturn NULL;\n\t}\n\n\treturn php_pcre_replace_impl(pce, subject, subject_len, replace_val, \n\t\tis_callable_replace, result_len, limit, replace_count TSRMLS_CC);\n}\n","project":"php","target":0},{"commit_id":"c48ef757cc50906e8726a3bebc3b60716292cdba","func":"void SoftMPEG4::onQueueFilled(OMX_U32 \/* portIndex *\/) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n continue;\n }\n\n PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n ++mInputBufferCount;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n }\n return;\n }\n\n uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n uint32_t *start_code = (uint32_t *)bitstream;\n bool volHeader = *start_code == 0xB0010000;\n if (volHeader) {\n PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n }\n\n if (!mInitialized) {\n uint8_t *vol_data[1];\n int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n }\n\n            MP4DecodingMode mode =\n (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n bool hasFrameData = false;\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n } else if (volHeader) {\n                hasFrameData = true;\n }\n\n            mInitialized = true;\n\n if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n return;\n }\n\n if (!hasFrameData) {\n continue;\n }\n }\n\n if (!mFramesConfigured) {\n PortInfo *port = editPortInfo(1);\n            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n\n\n             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;\n             if ((outHeader->nAllocLen < yFrameSize) ||\n                     (outHeader->nAllocLen - yFrameSize < yFrameSize \/ 2)) {\n                ALOGE(\"Too small output buffer for reference frame: %zu bytes\",\n                        outHeader->nAllocLen);\n                 android_errorWriteLog(0x534e4554, \"30033990\");\n                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                 mSignalledError = true;\n return;\n }\n PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n            mFramesConfigured = true;\n }\n\n uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n uint32_t timestamp = 0xFFFFFFFF;\n if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n }\n\n int32_t bufferSize = inHeader->nFilledLen;\n int32_t tmp = bufferSize;\n\n        OMX_U32 frameSize;\n        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;\n if (yFrameSize > ((OMX_U64)UINT32_MAX \/ 3) * 2) {\n            ALOGE(\"Frame size too large\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n        frameSize = (OMX_U32)(yFrameSize + (yFrameSize \/ 2));\n\n if (outHeader->nAllocLen < frameSize) {\n            android_errorWriteLog(0x534e4554, \"27833616\");\n            ALOGE(\"Insufficient output buffer size\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n\n if (handlePortSettingsChange()) {\n return;\n }\n\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n } else {\n            outHeader->nFlags = 0;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n ++mInputBufferCount;\n\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = frameSize;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mNumSamplesOutput;\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Chapters::Atom::~Atom()\n{\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Segment::DoneParsing() const\n{\n    if (m_size < 0)\n    {\n        long long total, avail;\n \n        const int status = m_pReader->Length(&total, &avail);\n \n        if (status < 0)  \/\/error\n            return true;  \/\/must assume done\n \n        if (total < 0)\n            return false;  \/\/assume live stream\n \n        return (m_pos >= total);\n    }\n \n    const long long stop = m_start + m_size;\n \n    return (m_pos >= stop);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"unsigned long long Track::GetDefaultDuration() const\n{\n    return m_info.defaultDuration;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_new_icc_colorspace(fz_context *ctx, const char *name, int num, fz_buffer *buf)\n{\n#ifdef NO_ICC\n\tfz_throw(ctx, FZ_ERROR_GENERIC, \"ICC Profiles not supported in NO_ICC build\");\n#else\n\tfz_colorspace *cs = NULL;\n\tfz_iccprofile *profile;\n\tint is_lab = 0;\n\tenum fz_colorspace_type type = FZ_COLORSPACE_NONE;\n\tint flags = FZ_COLORSPACE_IS_ICC;\n\n\tprofile = fz_malloc_struct(ctx, fz_iccprofile);\n\tfz_try(ctx)\n\t{\n\t\tif (buf == NULL)\n\t\t{\n\t\t\tsize_t size;\n\t\t\tconst unsigned char *data;\n\t\t\tdata = fz_lookup_icc(ctx, name, &size);\n\t\t\tprofile->buffer = fz_new_buffer_from_shared_data(ctx, data, size);\n\t\t\tis_lab = (strcmp(name, FZ_ICC_PROFILE_LAB) == 0);\n\t\t\tprofile->bgr = (strcmp(name, FZ_ICC_PROFILE_BGR) == 0);\n\t\t\tflags |= FZ_COLORSPACE_IS_DEVICE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprofile->buffer = fz_keep_buffer(ctx, buf);\n\t\t}\n\n\t\tfz_cmm_init_profile(ctx, profile);\n\n\t\t\/* Check if correct type, if a particular type was expected *\/\n\t\tif (num != 0 && num != profile->num_devcomp)\n\t\t{\n\t\t\tfz_drop_buffer(ctx, profile->buffer);\n\t\t\tfz_cmm_fin_profile(ctx, profile);\n\t\t\tfz_free(ctx, profile);\n\t\t\tbreak;\n\t\t}\n\n\t\tfz_md5_icc(ctx, profile);\n\n\t\tswitch (profile->num_devcomp)\n\t\t{\n\t\tdefault:\n\t\t\ttype = FZ_COLORSPACE_SEPARATION;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttype = FZ_COLORSPACE_GRAY;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (is_lab)\n\t\t\t\ttype = FZ_COLORSPACE_LAB;\n\t\t\telse if (profile->bgr)\n\t\t\t\ttype = FZ_COLORSPACE_BGR;\n\t\t\telse\n\t\t\t\ttype = FZ_COLORSPACE_RGB;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttype = FZ_COLORSPACE_CMYK;\n\t\t\tbreak;\n\t\t}\n\n\t\tcs = fz_new_colorspace(ctx, name, type, flags, profile->num_devcomp, NULL, NULL, NULL, is_lab ? clamp_lab_icc : clamp_default_icc, free_icc, profile, sizeof(profile));\n\n\t\tswitch (profile->num_devcomp)\n\t\t{\n\t\tcase 1:\n\t\t\tfz_colorspace_name_colorant(ctx, cs, 0, \"Gray\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (is_lab)\n\t\t\t{\n\t\t\t\tfz_colorspace_name_colorant(ctx, cs, 0, \"L*\");\n\t\t\t\tfz_colorspace_name_colorant(ctx, cs, 1, \"a*\");\n\t\t\t\tfz_colorspace_name_colorant(ctx, cs, 2, \"b*\");\n\t\t\t} else {\n\t\t\t\tfz_colorspace_name_colorant(ctx, cs, profile->bgr ? 2 : 0, \"Red\");\n\t\t\t\tfz_colorspace_name_colorant(ctx, cs, 1, \"Green\");\n\t\t\t\tfz_colorspace_name_colorant(ctx, cs, profile->bgr ? 0 : 2, \"Blue\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tfz_colorspace_name_colorant(ctx, cs, 0, \"Cyan\");\n\t\t\tfz_colorspace_name_colorant(ctx, cs, 1, \"Magenta\");\n\t\t\tfz_colorspace_name_colorant(ctx, cs, 2, \"Yellow\");\n\t\t\tfz_colorspace_name_colorant(ctx, cs, 3, \"Black\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_buffer(ctx, profile->buffer);\n\t\tfz_cmm_fin_profile(ctx, profile);\n\t\tfz_free(ctx, profile);\n\t}\n\treturn cs;\n#endif\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* Track::GetNameAsUTF8() const\n{\n    return m_info.nameAsUTF8;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Chapters::Chapters(\n    Segment* pSegment,\n    long long payload_start,\n    long long payload_size,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_start(payload_start),\n    m_size(payload_size),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    m_editions(NULL),\n    m_editions_size(0),\n    m_editions_count(0)\n{\n}\n","project":"Android","target":1},{"commit_id":"866dc26ad4a98cc835d075b627326e7d7e52ffa1","func":"std::string utf16ToUtf8(const StringPiece16& utf16) {\n ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length());\n if (utf8Length <= 0) {\n return {};\n\n     }\n \n     std::string utf8;\n     utf8.resize(utf8Length);\n    utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin());\n     return utf8;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"indexed_to_alt(fz_context *ctx, const fz_colorspace *cs, const float *color, float *alt)\n{\n\tstruct indexed *idx = cs->data;\n\tint i, k;\n\tint n = idx->base->n;\n\n\ti = color[0] * 255;\n\ti = fz_clampi(i, 0, idx->high);\n\tfor (k = 0; k < n; k++)\n\t\talt[k] = idx->lookup[i * n + k] \/ 255.0f;\n}\n","project":"ghostscript","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static char **make_subpats_table(int num_subpats, pcre_cache_entry *pce TSRMLS_DC)\n{\n\tpcre_extra *extra = pce->extra;\n\tint name_cnt = 0, name_size, ni = 0;\n\tint rc;\n\tchar *name_table;\n\tunsigned short name_idx;\n\tchar **subpat_names = (char **)ecalloc(num_subpats, sizeof(char *));\n\n\trc = pcre_fullinfo(pce->re, extra, PCRE_INFO_NAMECOUNT, &name_cnt);\n\tif (rc < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Internal pcre_fullinfo() error %d\", rc);\n\t\tefree(subpat_names);\n\t\treturn NULL;\n\t}\n\tif (name_cnt > 0) {\n\t\tint rc1, rc2;\n\n\t\trc1 = pcre_fullinfo(pce->re, extra, PCRE_INFO_NAMETABLE, &name_table);\n\t\trc2 = pcre_fullinfo(pce->re, extra, PCRE_INFO_NAMEENTRYSIZE, &name_size);\n\t\trc = rc2 ? rc2 : rc1;\n\t\tif (rc < 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Internal pcre_fullinfo() error %d\", rc);\n\t\t\tefree(subpat_names);\n\t\t\treturn NULL;\n\t\t}\n\n\t\twhile (ni++ < name_cnt) {\n\t\t\tname_idx = 0xff * (unsigned char)name_table[0] + (unsigned char)name_table[1];\n\t\t\tsubpat_names[name_idx] = name_table + 2;\n\t\t\tif (is_numeric_string(subpat_names[name_idx], strlen(subpat_names[name_idx]), NULL, NULL, 0) > 0) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Numeric named subpatterns are not allowed\");\n\t\t\t\tefree(subpat_names);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tname_table += name_size;\n\t\t}\n\t}\n\n\treturn subpat_names;\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void RunMemCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j) {\n        input_block[j] = rnd.Rand8() - rnd.Rand8();\n        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;\n       }\n      if (i == 0)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = 255;\n      if (i == 1)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = -255;\n \n       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\n                                      output_block, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         EXPECT_EQ(output_block[j], output_ref_block[j]);\n        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))\n             << \"Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\";\n       }\n     }\n   }\n","project":"Android","target":1},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_expected_bytes (const char *s)\n{\n  wgint res;\n\n  while (1)\n    {\n      while (*s && *s != '(')\n        ++s;\n      if (!*s)\n        return 0;\n      ++s;                      \/* skip the '(' *\/\n      res = str_to_wgint (s, (char **) &s, 10);\n      if (!*s)\n        return 0;\n      while (*s && c_isspace (*s))\n        ++s;\n      if (!*s)\n        return 0;\n      if (c_tolower (*s) != 'b')\n        continue;\n      if (c_strncasecmp (s, \"byte\", 4))\n        continue;\n      else\n        break;\n    }\n  return res;\n}\n","project":"savannah","target":0},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"    BufferMeta(const sp<IMemory> &mem, OMX_U32 portIndex, bool is_backup = false)\n         : mMem(mem),\n          mIsBackup(is_backup),\n          mPortIndex(portIndex) {\n     }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const\n{\n    return GetTime(pChapters, m_stop_timecode);\n}\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::setParameter(\n        OMX_INDEXTYPE index, const void *params, size_t size) {\n Mutex::Autolock autoLock(mLock);\n\n     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;\n     CLOG_CONFIG(setParameter, \"%s(%#x), %zu@%p)\", asString(extIndex), index, size, params);\n \n     OMX_ERRORTYPE err = OMX_SetParameter(\n             mHandle, index, const_cast<void *>(params));\n     CLOG_IF_ERROR(setParameter, err, \"%s(%#x)\", asString(extIndex), index);\n return StatusFromOMXError(err);\n}\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":"status_t OMXNodeInstance::getConfig(\n\n         OMX_INDEXTYPE index, void *params, size_t \/* size *\/) {\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);\n     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;\n if (err != OMX_ErrorNoMore) {\n        CLOG_IF_ERROR(getConfig, err, \"%s(%#x)\", asString(extIndex), index);\n }\n return StatusFromOMXError(err);\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Cues::Find(\n    long long time_ns,\n    const Track* pTrack,\n    const CuePoint*& pCP,\n    const CuePoint::TrackPosition*& pTP) const\n{\n    assert(time_ns >= 0);\n    assert(pTrack);\n \n #if 0\n     LoadCuePoint();  \/\/establish invariant\n\n    assert(m_cue_points);\n    assert(m_count > 0);\n\n CuePoint** const ii = m_cue_points;\n CuePoint** i = ii;\n\n CuePoint** const jj = ii + m_count + m_preload_count;\n CuePoint** j = jj;\n\n    pCP = *i;\n    assert(pCP);\n\n if (time_ns <= pCP->GetTime(m_pSegment))\n {\n        pTP = pCP->Find(pTrack);\n return (pTP != NULL);\n }\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n while (i < j)\n {\n\n CuePoint** const k = i + (j - i) \/ 2;\n        assert(k < jj);\n\n CuePoint* const pCP = *k;\n        assert(pCP);\n\n        pCP->Load(pReader);\n\n const long long t = pCP->GetTime(m_pSegment);\n\n if (t <= time_ns)\n            i = k + 1;\n else\n            j = k;\n\n        assert(i <= j);\n }\n\n    assert(i == j);\n    assert(i <= jj);\n    assert(i > ii);\n\n    pCP = *--i;\n\n     assert(pCP);\n     assert(pCP->GetTime(m_pSegment) <= time_ns);\n #else\n    if (m_cue_points == NULL)\n        return false;\n \n    if (m_count == 0)\n        return false;\n \n    CuePoint** const ii = m_cue_points;\n    CuePoint** i = ii;\n \n    CuePoint** const jj = ii + m_count;\n    CuePoint** j = jj;\n \n    pCP = *i;\n    assert(pCP);\n \n    if (time_ns <= pCP->GetTime(m_pSegment))\n    {\n        pTP = pCP->Find(pTrack);\n        return (pTP != NULL);\n    }\n    while (i < j)\n    {\n        CuePoint** const k = i + (j - i) \/ 2;\n        assert(k < jj);\n        CuePoint* const pCP = *k;\n        assert(pCP);\n        const long long t = pCP->GetTime(m_pSegment);\n        if (t <= time_ns)\n            i = k + 1;\n        else\n            j = k;\n        assert(i <= j);\n    }\n    assert(i == j);\n    assert(i <= jj);\n    assert(i > ii);\n    pCP = *--i;\n    assert(pCP);\n    assert(pCP->GetTime(m_pSegment) <= time_ns);\n#endif\n     pTP = pCP->Find(pTrack);\n     return (pTP != NULL);\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_hash_cmp (const void *p1, const void *p2)\n{\n  const struct cluster_list * cluster1 = p1;\n  const struct cluster_list * cluster2 = p2;\n\n  return (cluster1->length == cluster2->length &&\n\t  memcmp (cluster1->list, cluster2->list, cluster1->length) == 0);\n}\n","project":"savannah","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_Q(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_grestore(ctx, pr);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":" ContentEncoding::ContentEncryption::ContentEncryption()\n : algo(0),\n      key_id(NULL),\n      key_id_len(0),\n      signature(NULL),\n      signature_len(0),\n\n       sig_key_id(NULL),\n       sig_key_id_len(0),\n       sig_algo(0),\n      sig_hash_algo(0) {\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_new_cmm_context(fz_context *ctx)\n{\n\tctx->cmm_instance = fz_cmm_new_instance(ctx);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_source_colorspace_cm(fz_context *ctx, const fz_colorspace *cs)\n{\n\twhile (cs)\n\t{\n\t\tif (fz_colorspace_is_icc(ctx, cs))\n\t\t\treturn cs;\n\t\tif (fz_colorspace_is_cal(ctx, cs))\n\t\t\treturn cs;\n\t\tcs = fz_colorspace_base(ctx, cs);\n\t}\n\treturn NULL;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_drop_link_imp(fz_context *ctx, fz_storable *storable)\n{\n\tfz_icclink *link = (fz_icclink *)storable;\n\tfz_cmm_fin_link(ctx, link);\n\tfz_free(ctx, link);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool BlockEntry::EOS() const\n{\n    return (GetKind() == kBlockEOS);\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_aggregate_intern (struct bgp *bgp, u_char origin,\n\t\t\t   struct aspath *aspath,\n\t\t\t   struct community *community, int as_set)\n{\n  struct attr attr;\n  struct attr *new;\n  struct attr_extra *attre;\n\n  memset (&attr, 0, sizeof (struct attr));\n  attre = bgp_attr_extra_get (&attr);\n  \n  \/* Origin attribute. *\/\n  attr.origin = origin;\n  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);\n\n  \/* AS path attribute. *\/\n  if (aspath)\n    attr.aspath = aspath_intern (aspath);\n  else\n    attr.aspath = aspath_empty ();\n  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);\n\n  \/* Next hop attribute.  *\/\n  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);\n\n  if (community)\n    {\n      attr.community = community;\n      attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);\n    }\n\n  attre->weight = BGP_ATTR_DEFAULT_WEIGHT;\n#ifdef HAVE_IPV6\n  attre->mp_nexthop_len = IPV6_MAX_BYTELEN;\n#endif\n  if (! as_set)\n    attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);\n  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR);\n  if (CHECK_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION))\n    attre->aggregator_as = bgp->confed_id;\n  else\n    attre->aggregator_as = bgp->as;\n  attre->aggregator_addr = bgp->router_id;\n\n  new = bgp_attr_intern (&attr);\n  bgp_attr_extra_free (&attr);\n  \n  aspath_unintern (&new->aspath);\n  return new;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fast_cmyk_to_rgb_ARM(unsigned char *dst, unsigned char *src, int n)\n{\n\tasm volatile(\n\tENTER_ARM\n\t\"stmfd\tr13!,{r4-r11,r14}\t\t\t\t\t\\n\"\n\t\"@ r0 = dst\t\t\t\t\t\t\t\\n\"\n\t\"@ r1 = src\t\t\t\t\t\t\t\\n\"\n\t\"@ r2 = n\t\t\t\t\t\t\t\\n\"\n\t\"mov\tr12, #0\t\t\t@ r12= CMYK = 0\t\t\t\\n\"\n\t\"b\t2f\t\t\t@ enter loop\t\t\t\\n\"\n\t\"1:\t\t\t\t@ White or Black\t\t\\n\"\n\t\"@ Cunning trick: On entry r11 = 0 if black, r11 = FF if white\t\\n\"\n\t\"eor    r12,r11,#0xFF           @ r12= FF if black, 0 if white  \\n\"\n\t\"ldrb\tr7, [r1],#1\t\t@ r8 = s[4]\t\t\t\\n\"\n\t\"strb\tr11,[r0],#1\t\t@ d[0] = r\t\t\t\\n\"\n\t\"strb\tr11,[r0],#1\t\t@ d[1] = g\t\t\t\\n\"\n\t\"strb\tr11,[r0],#1\t\t@ d[2] = b\t\t\t\\n\"\n\t\"strb\tr7, [r0],#1\t\t@ d[3] = s[4]\t\t\t\\n\"\n\t\"mov    r12,r12,LSL #24         @ r12 = CMYK                    \\n\"\n\t\"subs\tr2, r2, #1\t\t@ r2 = n--\t\t\t\\n\"\n\t\"beq\t9f\t\t\t\t\t\t\t\\n\"\n\t\"2:\t\t\t\t@ Main loop starts here\t\t\\n\"\n\t\"ldrb\tr3, [r1], #4\t\t@ r3 = c\t\t\t\\n\"\n\t\"ldrb\tr6, [r1, #-1]\t\t@ r6 = k\t\t\t\\n\"\n\t\"ldrb\tr5, [r1, #-2]\t\t@ r5 = y\t\t\t\\n\"\n\t\"ldrb\tr4, [r1, #-3]\t\t@ r4 = m\t\t\t\\n\"\n\t\"eors\tr11,r6, #0xFF\t\t@ if (k == 255)\t\t\t\\n\"\n\t\"beq\t1b\t\t\t@   goto black\t\t\t\\n\"\n\t\"orr\tr7, r3, r4, LSL #8\t\t\t\t\t\\n\"\n\t\"orr\tr14,r5, r6, LSL #8\t\t\t\t\t\\n\"\n\t\"orrs\tr7, r7, r14,LSL #16\t@ r7 = cmyk\t\t\t\\n\"\n\t\"beq\t1b\t\t\t@ if (cmyk == 0) white\t\t\\n\"\n\t\"@ At this point, we have to decode a new pixel\t\t\t\\n\"\n\t\"@ r0 = dst  r1 = src  r2 = n  r7 = cmyk\t\t\t\\n\"\n\t\"3:\t\t\t\t@ unmatched\t\t\t\\n\"\n\t\"stmfd\tr13!,{r0-r1,r7}\t\t@ stash regs for space\t\t\\n\"\n\t\"add\tr3, r3, r3, LSR #7\t@ r3 = c += c>>7\t\t\\n\"\n\t\"add\tr4, r4, r4, LSR #7\t@ r4 = m += m>>7\t\t\\n\"\n\t\"add\tr5, r5, r5, LSR #7\t@ r5 = y += y>>7\t\t\\n\"\n\t\"add\tr6, r6, r6, LSR #7\t@ r6 = k += k>>7\t\t\\n\"\n\t\"mov\tr5, r5, LSR #1\t\t@ sacrifice 1 bit of Y\t\t\\n\"\n\t\"mul\tr8, r3, r4\t\t@ r8 = cm     = c * m\t\t\\n\"\n\t\"rsb\tr9, r8, r4, LSL #8\t@ r9 = c1m    = (m<<8) - cm\t\\n\"\n\t\"rsb\tr3, r8, r3, LSL #8\t@ r3 = cm1    = (c<<8) - cm\t\\n\"\n\t\"rsb\tr4, r4, #0x100\t\t@ r4 = 256-m\t\t\t\\n\"\n\t\"rsb\tr4, r3, r4, LSL #8\t@ r4 = c1m1   =((256-m)<<8)-cm1\t\\n\"\n\t\"mul\tr7, r4, r5\t\t@ r7 = c1m1y  = c1m1 * y\t\\n\"\n\t\"rsb\tr4, r7, r4, LSL #7\t@ r4 = c1m1y1 = (c1m1<<7)-c1m1y\t\\n\"\n\t\"mul\tr10,r9, r5\t\t@ r10= c1my   = c1m * y\t\t\\n\"\n\t\"rsb\tr9, r10,r9, LSL #7\t@ r9 = c1my1  = (c1m<<7) - c1my \\n\"\n\t\"mul\tr11,r3, r5\t\t@ r11= cm1y   = cm1 * y\t\t\\n\"\n\t\"rsb\tr3, r11,r3, LSL #7\t@ r3 = cm1y1  = (cm1<<7) - cm1y\t\\n\"\n\t\"mul\tr5, r8, r5\t\t@ r5 = cmy    = cm * y\t\t\\n\"\n\t\"rsb\tr8, r5, r8, LSL #7\t@ r8 = cmy1   = (cm<<7) - cmy\t\\n\"\n\t\"@ Register recap:\t\t\t\t\t\t\\n\"\n\t\"@ r3 = cm1y1\t\t\t\t\t\t\t\\n\"\n\t\"@ r4 = c1m1y1\t\t\t\t\t\t\t\\n\"\n\t\"@ r5 = cmy\t\t\t\t\t\t\t\\n\"\n\t\"@ r6 = k\t\t\t\t\t\t\t\\n\"\n\t\"@ r7 = c1m1y\t\t\t\t\t\t\t\\n\"\n\t\"@ r8 = cmy1\t\t\t\t\t\t\t\\n\"\n\t\"@ r9 = c1my1\t\t\t\t\t\t\t\\n\"\n\t\"@ r10= c1my\t\t\t\t\t\t\t\\n\"\n\t\"@ r11= cm1y\t\t\t\t\t\t\t\\n\"\n\t\"@ The actual matrix multiplication\t\t\t\t\\n\"\n\t\"mul\tr14,r4, r6\t\t@ r14= x1 = c1m1y1 * k\t\t\\n\"\n\t\"rsb\tr4, r14,r4, LSL #8\t@ r4 = x0 = (c1m1y1<<8) - x1\t\\n\"\n\t\"add\tr4, r4, r14,LSR #8-5\t@ r4 = b = x0 + 32*(x1>>8)\t\\n\"\n\t\"sub\tr1, r4, r14,LSR #8\t@ r1 = g = x0 + 31*(x1>>8)\t\\n\"\n\t\"add\tr0, r1, r14,LSR #8-2\t@ r0 = r = x0 + 35*(x1>>8)\t\\n\"\n\t\"\t\t\t\t\t\t\t\t\\n\"\n\t\"mul\tr14,r7, r6\t\t@ r14= x1 = c1m1y * k\t\t\\n\"\n\t\"rsb\tr7, r14,r7, LSL #8\t@ r7 = x0 = (c1m1y<<8) - x1\t\\n\"\n\t\"add\tr0, r0, r7\t\t@ r0 = r += x0\t\t\t\\n\"\n\t\"add\tr1, r1, r7\t\t@ r1 = g += (x0>>8 * 256)\t\\n\"\n\t\"sub\tr1, r1, r7, LSR #8-3\t@                    248\t\\n\"\n\t\"sub\tr1, r1, r7, LSR #8-2\t@                    244\t\\n\"\n\t\"sub\tr1, r1, r7, LSR #8\t@                    243\t\\n\"\n\t\"sub\tr7, r14,r14,LSR #3\t@ r7 = 28*(x1>>5)\t\t\\n\"\n\t\"add\tr0, r0, r7, LSR #8-5\t@ r0 = r += 28 * x1\t\t\\n\"\n\t\"sub\tr7, r7, r14,LSR #4\t@ r7 = 26*(x1>>5)\t\t\\n\"\n\t\"add\tr1, r1, r7, LSR #8-5\t@ r1 = g += 26 * x1\t\t\\n\"\n\t\"\t\t\t\t\t\t\t\t\\n\"\n\t\"mul\tr14,r9, r6\t\t@ r14= x1 = c1my1 * k\t\t\\n\"\n\t\"sub\tr9, r9, r14,LSR #8\t@ r9 = x0>>8 = c1my1 - (x1>>8)\t\\n\"\n\t\"add\tr0, r0, r14,LSR #8-5\t@ r0 = r += (x1>>8)*32\t\t\\n\"\n\t\"add\tr0, r0, r14,LSR #8-2\t@ r0 = r += (x1>>8)*36\t\t\\n\"\n\t\"mov\tr14,#237\t\t@ r14= 237\t\t\t\\n\"\n\t\"mla\tr0,r14,r9,r0\t\t@ r14= r += x0*237\t\t\\n\"\n\t\"mov\tr14,#141\t\t@ r14= 141\t\t\t\\n\"\n\t\"mla\tr4,r14,r9,r4\t\t@ r14= b += x0*141\t\t\\n\"\n\t\"\t\t\t\t\t\t\t\t\\n\"\n\t\"mul\tr14,r10,r6\t\t@ r14= x1 = c1my * k\t\t\\n\"\n\t\"sub\tr10,r10,r14,LSR #8\t@ r10= x0>>8 = c1my - (x1>>8)\t\\n\"\n\t\"add\tr0, r0, r14,LSR #8-5\t@ r0 = r += 32 * x1\t\t\\n\"\n\t\"add\tr0, r0, r14,LSR #8-1\t@ r0 = r += 34 * x1\t\t\\n\"\n\t\"mov\tr14,#238\t\t@ r14= 238\t\t\t\\n\"\n\t\"mla\tr0,r14,r10,r0\t\t@ r0 = r += 238 * x0\t\t\\n\"\n\t\"mov\tr14,#28\t\t\t@ r14= 28\t\t\t\\n\"\n\t\"mla\tr1,r14,r10,r1\t\t@ r1 = g += 28 * x0\t\t\\n\"\n\t\"mov\tr14,#36\t\t\t@ r14= 36\t\t\t\\n\"\n\t\"mla\tr4,r14,r10,r4\t\t@ r4 = b += 36 * x0\t\t\\n\"\n\t\"\t\t\t\t\t\t\t\t\\n\"\n\t\"mul\tr14,r3, r6\t\t@ r14= x1 = cm1y1 * k\t\t\\n\"\n\t\"sub\tr3, r3, r14,LSR #8\t@ r3 = x1>>8 = cm1y1 - (x1>>8)\t\\n\"\n\t\"add\tr1, r1, r14,LSR #8-4\t@ r1 = g += 16*x1\t\t\\n\"\n\t\"sub\tr1, r1, r14,LSR #8\t@           15*x1\t\t\\n\"\n\t\"add\tr4, r4, r14,LSR #8-5\t@ r4 = b += 32*x1\t\t\\n\"\n\t\"add\tr4, r4, r14,LSR #8-2\t@           36*x1\t\t\\n\"\n\t\"mov\tr14,#174\t\t@ r14= 174\t\t\t\\n\"\n\t\"mla\tr1, r14,r3, r1\t\t@ r1 = g += 174 * x0\t\t\\n\"\n\t\"mov\tr14,#240\t\t@ r14= 240\t\t\t\\n\"\n\t\"mla\tr4, r14,r3, r4\t\t@ r4 = b += 240 * x0\t\t\\n\"\n\t\"\t\t\t\t\t\t\t\t\\n\"\n\t\"mul\tr14,r11,r6\t\t@ r14= x1 = cm1y * k\t\t\\n\"\n\t\"sub\tr11,r11,r14,LSR #8\t@ r11= x0>>8 = cm1y - (x1>>8)\t\\n\"\n\t\"add\tr1, r1, r14,LSR #8-4\t@ r1 = g += x1 * 16\t\t\\n\"\n\t\"add\tr1, r1, r14,LSR #8\t@           x1 * 17\t\t\\n\"\n\t\"add\tr1, r1, r14,LSR #8-1\t@           x1 * 19\t\t\\n\"\n\t\"mov\tr14,#167\t\t@ r14 = 167\t\t\t\\n\"\n\t\"mla\tr1, r14,r11,r1\t\t@ r1 = g += 167 * x0\t\t\\n\"\n\t\"mov\tr14,#80\t\t\t@ r14 = 80\t\t\t\\n\"\n\t\"mla\tr4, r14,r11,r4\t\t@ r4 = b += 80 * x0\t\t\\n\"\n\t\"\t\t\t\t\t\t\t\t\\n\"\n\t\"mul\tr14,r8, r6\t\t@ r14= x1 = cmy1 * k\t\t\\n\"\n\t\"sub\tr8, r8, r14,LSR #8\t@ r8 = x0>>8 = cmy1 - (x1>>8)\t\\n\"\n\t\"add\tr4, r4, r14,LSR #8-1\t@ r4 = b += x1 * 2\t\t\\n\"\n\t\"mov\tr14,#46\t\t\t@ r14=46\t\t\t\\n\"\n\t\"mla\tr0, r14,r8, r0\t\t@ r0 = r += 46 * x0\t\t\\n\"\n\t\"mov\tr14,#49\t\t\t@ r14=49\t\t\t\\n\"\n\t\"mla\tr1, r14,r8, r1\t\t@ r1 = g += 49 * x0\t\t\\n\"\n\t\"mov\tr14,#147\t\t@ r14=147\t\t\t\\n\"\n\t\"mla\tr4, r14,r8, r4\t\t@ r4 = b += 147 * x0\t\t\\n\"\n\t\"\t\t\t\t\t\t\t\t\\n\"\n\t\"rsb\tr6, r6, #256\t\t@ r6 = k = 256-k\t\t\\n\"\n\t\"mul\tr14,r5, r6\t\t@ r14= x0 = cmy * (256-k)\t\\n\"\n\t\"mov\tr11,#54\t\t\t@ r11= 54\t\t\t\\n\"\n\t\"mov\tr14,r14,LSR #8\t\t@ r14= (x0>>8)\t\t\t\\n\"\n\t\"mov\tr8,#57\t\t\t@ r8 = 57\t\t\t\\n\"\n\t\"mla\tr0,r14,r11,r0\t\t@ r0 = r += 54*x0\t\t\\n\"\n\t\"mla\tr1,r14,r11,r1\t\t@ r1 = g += 54*x0\t\t\\n\"\n\t\"mla\tr4,r14,r8, r4\t\t@ r4 = b += 57*x0\t\t\\n\"\n\t\"\t\t\t\t\t\t\t\t\\n\"\n\t\"sub\tr8, r0, r0, LSR #8\t@ r8 = r -= (r>>8)\t\t\\n\"\n\t\"sub\tr9, r1, r1, LSR #8\t@ r9 = g -= (r>>8)\t\t\\n\"\n\t\"sub\tr10,r4, r4, LSR #8\t@ r10= b -= (r>>8)\t\t\\n\"\n\t\"ldmfd\tr13!,{r0-r1,r12}\t\t\t\t\t\\n\"\n\t\"mov\tr8, r8, LSR #23\t\t@ r8 = r>>23\t\t\t\\n\"\n\t\"mov\tr9, r9, LSR #23\t\t@ r9 = g>>23\t\t\t\\n\"\n\t\"mov\tr10,r10,LSR #23\t\t@ r10= b>>23\t\t\t\\n\"\n\t\"ldrb\tr14,[r1],#1\t\t@ r8 = s[4]\t\t\t\\n\"\n\t\"strb\tr8, [r0],#1\t\t@ d[0] = r\t\t\t\\n\"\n\t\"strb\tr9, [r0],#1\t\t@ d[1] = g\t\t\t\\n\"\n\t\"strb\tr10,[r0],#1\t\t@ d[2] = b\t\t\t\\n\"\n\t\"strb\tr14,[r0],#1\t\t@ d[3] = s[4]\t\t\t\\n\"\n\t\"subs\tr2, r2, #1\t\t@ r2 = n--\t\t\t\\n\"\n\t\"beq\t9f\t\t\t\t\t\t\t\\n\"\n\t\"@ At this point, we've just decoded a pixel\t\t\t\\n\"\n\t\"@ r0 = dst  r1 = src  r2 = n  r8 = r  r9 = g  r10= b r12= CMYK \\n\"\n\t\"4:\t\t\t\t\t\t\t\t\\n\"\n\t\"ldrb\tr3, [r1], #4\t\t@ r3 = c\t\t\t\\n\"\n\t\"ldrb\tr6, [r1, #-1]\t\t@ r6 = k\t\t\t\\n\"\n\t\"ldrb\tr5, [r1, #-2]\t\t@ r5 = y\t\t\t\\n\"\n\t\"ldrb\tr4, [r1, #-3]\t\t@ r4 = m\t\t\t\\n\"\n\t\"eors\tr11,r6, #0xFF\t\t@ if (k == 255)\t\t\t\\n\"\n\t\"beq\t1b\t\t\t@   goto black\t\t\t\\n\"\n\t\"orr\tr7, r3, r4, LSL #8\t\t\t\t\t\\n\"\n\t\"orr\tr14,r5, r6, LSL #8\t\t\t\t\t\\n\"\n\t\"orrs\tr7, r7, r14,LSL #16\t@ r7 = cmyk\t\t\t\\n\"\n\t\"beq\t1b\t\t\t@ if (cmyk == 0) white\t\t\\n\"\n\t\"cmp\tr7, r12\t\t\t@ if (cmyk != CMYK)\t\t\\n\"\n\t\"bne\t3b\t\t\t@   not the same, loop\t\t\\n\"\n\t\"@ If we get here, we just matched a pixel we have just decoded \\n\"\n\t\"ldrb\tr3, [r1],#1\t\t@ r8 = s[4]\t\t\t\\n\"\n\t\"strb\tr8, [r0],#1\t\t@ d[0] = r\t\t\t\\n\"\n\t\"strb\tr9, [r0],#1\t\t@ d[1] = g\t\t\t\\n\"\n\t\"strb\tr10,[r0],#1\t\t@ d[2] = b\t\t\t\\n\"\n\t\"strb\tr3, [r0],#1\t\t@ d[3] = s[4]\t\t\t\\n\"\n\t\"subs\tr2, r2, #1\t\t@ r2 = n--\t\t\t\\n\"\n\t\"bne\t4b\t\t\t\t\t\t\t\\n\"\n\t\"9:\t\t\t\t\t\t\t\t\\n\"\n\t\"ldmfd\tr13!,{r4-r11,PC}\t@ pop, return to thumb\t\t\\n\"\n\tENTER_THUMB\n\t);\n}\n","project":"ghostscript","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"char * phar_compress_filter(phar_entry_info * entry, int return_unknown) \/* {{{ *\/\n{\n\tswitch (entry->flags & PHAR_ENT_COMPRESSION_MASK) {\n\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\treturn \"zlib.deflate\";\n\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\treturn \"bzip2.compress\";\n\tdefault:\n\t\treturn return_unknown ? \"unknown\" : NULL;\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void usage_exit() {\n   fprintf(stderr, \"Usage: %s <infile> <outfile>\\n\", exec_name);\n   exit(EXIT_FAILURE);\n }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_seek_efp(phar_entry_info *entry, off_t offset, int whence, off_t position, int follow_links TSRMLS_DC) \/* {{{ *\/\n{\n\tphp_stream *fp = phar_get_efp(entry, follow_links TSRMLS_CC);\n\toff_t temp, eoffset;\n\n\tif (!fp) {\n\t\treturn -1;\n\t}\n\n\tif (follow_links) {\n\t\tphar_entry_info *t;\n\t\tt = phar_get_link_source(entry TSRMLS_CC);\n\t\tif (t) {\n\t\t\tentry = t;\n\t\t}\n\t}\n\n\tif (entry->is_dir) {\n\t\treturn 0;\n\t}\n\n\teoffset = phar_get_fp_offset(entry TSRMLS_CC);\n\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\ttemp = eoffset + entry->uncompressed_filesize + offset;\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\ttemp = eoffset + position + offset;\n\t\t\tbreak;\n\t\tcase SEEK_SET:\n\t\t\ttemp = eoffset + offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttemp = 0;\n\t}\n\n\tif (temp > eoffset + (off_t) entry->uncompressed_filesize) {\n\t\treturn -1;\n\t}\n\n\tif (temp < eoffset) {\n\t\treturn -1;\n\t}\n\n\treturn php_stream_seek(fp, temp, SEEK_SET);\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_new_run_processor(fz_context *ctx, fz_device *dev, const fz_matrix *ctm, const char *usage, pdf_gstate *gstate, int nested, fz_default_colorspaces *default_cs)\n{\n\tpdf_run_processor *proc = pdf_new_processor(ctx, sizeof *proc);\n\t{\n\t\tproc->super.usage = usage;\n\n\t\tproc->super.drop_processor = pdf_drop_run_processor;\n\n\t\t\/* general graphics state *\/\n\t\tproc->super.op_w = pdf_run_w;\n\t\tproc->super.op_j = pdf_run_j;\n\t\tproc->super.op_J = pdf_run_J;\n\t\tproc->super.op_M = pdf_run_M;\n\t\tproc->super.op_d = pdf_run_d;\n\t\tproc->super.op_ri = pdf_run_ri;\n\t\tproc->super.op_i = pdf_run_i;\n\t\tproc->super.op_gs_begin = pdf_run_gs_begin;\n\t\tproc->super.op_gs_end = pdf_run_gs_end;\n\n\t\t\/* transparency graphics state *\/\n\t\tproc->super.op_gs_BM = pdf_run_gs_BM;\n\t\tproc->super.op_gs_CA = pdf_run_gs_CA;\n\t\tproc->super.op_gs_ca = pdf_run_gs_ca;\n\t\tproc->super.op_gs_SMask = pdf_run_gs_SMask;\n\n\t\t\/* special graphics state *\/\n\t\tproc->super.op_q = pdf_run_q;\n\t\tproc->super.op_Q = pdf_run_Q;\n\t\tproc->super.op_cm = pdf_run_cm;\n\n\t\t\/* path construction *\/\n\t\tproc->super.op_m = pdf_run_m;\n\t\tproc->super.op_l = pdf_run_l;\n\t\tproc->super.op_c = pdf_run_c;\n\t\tproc->super.op_v = pdf_run_v;\n\t\tproc->super.op_y = pdf_run_y;\n\t\tproc->super.op_h = pdf_run_h;\n\t\tproc->super.op_re = pdf_run_re;\n\n\t\t\/* path painting *\/\n\t\tproc->super.op_S = pdf_run_S;\n\t\tproc->super.op_s = pdf_run_s;\n\t\tproc->super.op_F = pdf_run_F;\n\t\tproc->super.op_f = pdf_run_f;\n\t\tproc->super.op_fstar = pdf_run_fstar;\n\t\tproc->super.op_B = pdf_run_B;\n\t\tproc->super.op_Bstar = pdf_run_Bstar;\n\t\tproc->super.op_b = pdf_run_b;\n\t\tproc->super.op_bstar = pdf_run_bstar;\n\t\tproc->super.op_n = pdf_run_n;\n\n\t\t\/* clipping paths *\/\n\t\tproc->super.op_W = pdf_run_W;\n\t\tproc->super.op_Wstar = pdf_run_Wstar;\n\n\t\t\/* text objects *\/\n\t\tproc->super.op_BT = pdf_run_BT;\n\t\tproc->super.op_ET = pdf_run_ET;\n\n\t\t\/* text state *\/\n\t\tproc->super.op_Tc = pdf_run_Tc;\n\t\tproc->super.op_Tw = pdf_run_Tw;\n\t\tproc->super.op_Tz = pdf_run_Tz;\n\t\tproc->super.op_TL = pdf_run_TL;\n\t\tproc->super.op_Tf = pdf_run_Tf;\n\t\tproc->super.op_Tr = pdf_run_Tr;\n\t\tproc->super.op_Ts = pdf_run_Ts;\n\n\t\t\/* text positioning *\/\n\t\tproc->super.op_Td = pdf_run_Td;\n\t\tproc->super.op_TD = pdf_run_TD;\n\t\tproc->super.op_Tm = pdf_run_Tm;\n\t\tproc->super.op_Tstar = pdf_run_Tstar;\n\n\t\t\/* text showing *\/\n\t\tproc->super.op_TJ = pdf_run_TJ;\n\t\tproc->super.op_Tj = pdf_run_Tj;\n\t\tproc->super.op_squote = pdf_run_squote;\n\t\tproc->super.op_dquote = pdf_run_dquote;\n\n\t\t\/* type 3 fonts *\/\n\t\tproc->super.op_d0 = pdf_run_d0;\n\t\tproc->super.op_d1 = pdf_run_d1;\n\n\t\t\/* color *\/\n\t\tproc->super.op_CS = pdf_run_CS;\n\t\tproc->super.op_cs = pdf_run_cs;\n\t\tproc->super.op_SC_color = pdf_run_SC_color;\n\t\tproc->super.op_sc_color = pdf_run_sc_color;\n\t\tproc->super.op_SC_pattern = pdf_run_SC_pattern;\n\t\tproc->super.op_sc_pattern = pdf_run_sc_pattern;\n\t\tproc->super.op_SC_shade = pdf_run_SC_shade;\n\t\tproc->super.op_sc_shade = pdf_run_sc_shade;\n\n\t\tproc->super.op_G = pdf_run_G;\n\t\tproc->super.op_g = pdf_run_g;\n\t\tproc->super.op_RG = pdf_run_RG;\n\t\tproc->super.op_rg = pdf_run_rg;\n\t\tproc->super.op_K = pdf_run_K;\n\t\tproc->super.op_k = pdf_run_k;\n\n\t\t\/* shadings, images, xobjects *\/\n\t\tproc->super.op_sh = pdf_run_sh;\n\t\tif (dev->fill_image || dev->fill_image_mask || dev->clip_image_mask)\n\t\t{\n\t\t\tproc->super.op_BI = pdf_run_BI;\n\t\t\tproc->super.op_Do_image = pdf_run_Do_image;\n\t\t}\n\t\tproc->super.op_Do_form = pdf_run_Do_form;\n\n\t\t\/* marked content *\/\n\t\tproc->super.op_MP = pdf_run_MP;\n\t\tproc->super.op_DP = pdf_run_DP;\n\t\tproc->super.op_BMC = pdf_run_BMC;\n\t\tproc->super.op_BDC = pdf_run_BDC;\n\t\tproc->super.op_EMC = pdf_run_EMC;\n\n\t\t\/* compatibility *\/\n\t\tproc->super.op_BX = pdf_run_BX;\n\t\tproc->super.op_EX = pdf_run_EX;\n\n\t\t\/* extgstate *\/\n\t\tproc->super.op_gs_OP = pdf_run_gs_OP;\n\t\tproc->super.op_gs_op = pdf_run_gs_op;\n\t\tproc->super.op_gs_OPM = pdf_run_gs_OPM;\n\t\tproc->super.op_gs_UseBlackPtComp = pdf_run_gs_UseBlackPtComp;\n\n\t\tproc->super.op_END = pdf_run_END;\n\t}\n\n\tproc->dev = dev;\n\n\tproc->default_cs = fz_keep_default_colorspaces(ctx, default_cs);\n\n\tproc->nested_depth = nested;\n\n\tproc->path = NULL;\n\tproc->clip = 0;\n\tproc->clip_even_odd = 0;\n\n\tproc->tos.text = NULL;\n\tproc->tos.tlm = fz_identity;\n\tproc->tos.tm = fz_identity;\n\tproc->tos.text_mode = 0;\n\n\tfz_try(ctx)\n\t{\n\t\tproc->path = fz_new_path(ctx);\n\n\t\tproc->gcap = 64;\n\t\tproc->gstate = fz_malloc_array(ctx, proc->gcap, sizeof(pdf_gstate));\n\n\t\tpdf_init_gstate(ctx, &proc->gstate[0], ctm);\n\t\tif (gstate)\n\t\t{\n\t\t\tpdf_copy_gstate(ctx, &proc->gstate[0], gstate);\n\t\t\tproc->gstate[0].clip_depth = 0;\n\t\t\tproc->gstate[0].ctm = *ctm;\n\t\t}\n\t\tproc->gtop = 0;\n\t\tproc->gbot = 0;\n\t\tproc->gparent = 0;\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_path(ctx, proc->path);\n\t\tfz_free(ctx, proc);\n\t\tfz_rethrow(ctx);\n\t}\n\n\t\/* We need to save an extra level to allow for level 0 to be the parent gstate level. *\/\n\tpdf_gsave(ctx, proc);\n\n\treturn (pdf_processor*)proc;\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkey_get_public)\n{\n\tzval **cert;\n\tEVP_PKEY *pkey;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &cert) == FAILURE) {\n\t\treturn;\n\t}\n\tZ_TYPE_P(return_value) = IS_RESOURCE;\n\tpkey = php_openssl_evp_from_zval(cert, 1, NULL, 1, &Z_LVAL_P(return_value) TSRMLS_CC);\n\n\tif (pkey == NULL) {\n\t\tRETURN_FALSE;\n\t}\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   static void SetUpTestCase() {\n    input_ = reinterpret_cast<uint8_t*>(\n\n         vpx_memalign(kDataAlignment, kInputBufferSize + 1)) + 1;\n     output_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kOutputBufferSize));\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"SeekHead::~SeekHead()\n{\n    delete[] m_entries;\n    delete[] m_void_elements;\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static STACK_OF(X509) * php_array_to_X509_sk(zval ** zcerts TSRMLS_DC) \/* {{{ *\/\n{\n\tHashPosition hpos;\n\tzval ** zcertval;\n\tSTACK_OF(X509) * sk = NULL;\n    X509 * cert;\n    long certresource;\n\n\tsk = sk_X509_new_null();\n\n\t\/* get certs *\/\n\tif (Z_TYPE_PP(zcerts) == IS_ARRAY) {\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(*zcerts), &hpos);\n\t\twhile(zend_hash_get_current_data_ex(HASH_OF(*zcerts), (void**)&zcertval, &hpos) == SUCCESS) {\n\n\t\t\tcert = php_openssl_x509_from_zval(zcertval, 0, &certresource TSRMLS_CC);\n\t\t\tif (cert == NULL) {\n\t\t\t\tgoto clean_exit;\n\t\t\t}\n\n\t\t\tif (certresource != -1) {\n\t\t\t\tcert = X509_dup(cert);\n\t\t\t\t\n\t\t\t\tif (cert == NULL) {\n\t\t\t\t\tgoto clean_exit;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tsk_X509_push(sk, cert);\n\n\t\t\tzend_hash_move_forward_ex(HASH_OF(*zcerts), &hpos);\n\t\t}\n\t} else {\n\t\t\/* a single certificate *\/\n\t\tcert = php_openssl_x509_from_zval(zcerts, 0, &certresource TSRMLS_CC);\n\t\t\n\t\tif (cert == NULL) {\n\t\t\tgoto clean_exit;\n\t\t}\n\n\t\tif (certresource != -1) {\n\t\t\tcert = X509_dup(cert);\n\t\t\tif (cert == NULL) {\n\t\t\t\tgoto clean_exit;\n\t\t\t}\n\t\t}\n\t\tsk_X509_push(sk, cert);\n\t}\n\n  clean_exit:\n    return sk;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Track::~Track()\n{\n    Info& info = const_cast<Info&>(m_info);\n    info.Clear();\n \n    ContentEncoding** i = content_encoding_entries_;\n    ContentEncoding** const j = content_encoding_entries_end_;\n \n    while (i != j) {\n        ContentEncoding* const encoding = *i++;\n        delete encoding;\n    }\n \n    delete [] content_encoding_entries_;\n }\n","project":"Android","target":1},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"static void walk_splay(cmap_splay *tree, unsigned int node, void (*fn)(cmap_splay *, void *), void *arg)\n{\n\tint from = TOP;\n\n\twhile (node != EMPTY)\n\t{\n\t\tswitch (from)\n\t\t{\n\t\tcase TOP:\n\t\t\tif (tree[node].left != EMPTY)\n\t\t\t{\n\t\t\t\tnode = tree[node].left;\n\t\t\t\tfrom = TOP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\/* fallthrough *\/\n\t\tcase LEFT:\n\t\t\tfn(&tree[node], arg);\n\t\t\tif (tree[node].right != EMPTY)\n\t\t\t{\n\t\t\t\tnode = tree[node].right;\n\t\t\t\tfrom = TOP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\/* fallthrough *\/\n\t\tcase RIGHT:\n\t\t\t{\n\t\t\t\tunsigned int parent = tree[node].parent;\n\t\t\t\tif (parent == EMPTY)\n\t\t\t\t\treturn;\n\t\t\t\tif (tree[parent].left == node)\n\t\t\t\t\tfrom = LEFT;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tassert(tree[parent].right == node);\n\t\t\t\t\tfrom = RIGHT;\n\t\t\t\t}\n\t\t\t\tnode = parent;\n\t\t\t}\n\t\t}\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video) {\n     frame_flags_ &= ~(VP8_EFLAG_NO_UPD_LAST |\n                       VP8_EFLAG_NO_UPD_GF |\n                       VP8_EFLAG_NO_UPD_ARF);\n    if (droppable_nframes_ > 0 &&\n        (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {\n       for (unsigned int i = 0; i < droppable_nframes_; ++i) {\n         if (droppable_frames_[i] == video->frame()) {\n          std::cout << \"             Encoding droppable frame: \"\n                     << droppable_frames_[i] << \"\\n\";\n          frame_flags_ |= (VP8_EFLAG_NO_UPD_LAST |\n                           VP8_EFLAG_NO_UPD_GF |\n                           VP8_EFLAG_NO_UPD_ARF);\n          return;\n         }\n       }\n     }\n   }\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAMRNBEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAMR;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            amrParams->nChannels = 1;\n            amrParams->nBitRate = mBitRate;\n            amrParams->eAMRBandMode = (OMX_AUDIO_AMRBANDMODETYPE)(mMode + 1);\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelCF;\n\n            pcmParams->nChannels = 1;\n            pcmParams->nSamplingRate = kSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Tracks::Tracks(\n    Segment* pSegment,\n    long long start,\n    long long size_,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_start(start),\n    m_size(size_),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    m_trackEntries(NULL),\n    m_trackEntriesEnd(NULL)\n{\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const BlockEntry* Track::GetEOS() const\n{\n    return &m_eos;\n}\n","project":"Android","target":1},{"commit_id":"d112f7d0c1dbaf0368365885becb11ca8d3f13a4","func":" status_t NuPlayer::GenericSource::setBuffers(\n         bool audio, Vector<MediaBuffer *> &buffers) {\n    if (mIsWidevine && !audio && mVideoTrack.mSource != NULL) {\n         return mVideoTrack.mSource->setBuffers(buffers);\n     }\n     return INVALID_OPERATION;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void reference_32x32_dct_1d(const double in[32], double out[32], int stride) {\n   const double kInvSqrt2 = 0.707106781186547524400844362104;\n   for (int k = 0; k < 32; k++) {\n     out[k] = 0.0;\n for (int n = 0; n < 32; n++)\n      out[k] += in[n] * cos(kPi * (2 * n + 1) * k \/ 64.0);\n if (k == 0)\n      out[k] = out[k] * kInvSqrt2;\n }\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 4;\n     fwd_txfm_ref = fht4x4_ref;\n   }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"static int phar_compare_dir_name(const void *a, const void *b TSRMLS_DC)  \/* {{{ *\/\n{\n\tBucket *f;\n\tBucket *s;\n\tint result;\n\n\tf = *((Bucket **) a);\n\ts = *((Bucket **) b);\n\tresult = zend_binary_strcmp(f->arKey, f->nKeyLength, s->arKey, s->nKeyLength);\n\n\tif (result < 0) {\n\t\treturn -1;\n\t} else if (result > 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Cues::PreloadCuePoint(\n    long& cue_points_size,\n    long long pos) const\n{\n    assert(m_count == 0);\n    if (m_preload_count >= cue_points_size)\n    {\n        const long n = (cue_points_size <= 0) ? 2048 : 2*cue_points_size;\n        CuePoint** const qq = new CuePoint*[n];\n        CuePoint** q = qq;  \/\/beginning of target\n        CuePoint** p = m_cue_points;                \/\/beginning of source\n        CuePoint** const pp = p + m_preload_count;  \/\/end of source\n        while (p != pp)\n            *q++ = *p++;\n        delete[] m_cue_points;\n        m_cue_points = qq;\n        cue_points_size = n;\n     }\n \n    CuePoint* const pCP = new CuePoint(m_preload_count, pos);\n    m_cue_points[m_preload_count++] = pCP;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n    if (video->frame() == 1) {\n       encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n     }\n     if (cfg_.ts_number_layers > 1) {\n      if (video->frame() == 1) {\n         encoder->Control(VP9E_SET_SVC, 1);\n       }\n      vpx_svc_layer_id_t layer_id = {0, 0};\n       layer_id.spatial_layer_id = 0;\n       frame_flags_ = SetFrameFlags(video->frame(), cfg_.ts_number_layers);\n       layer_id.temporal_layer_id = SetLayerId(video->frame(),\n                                               cfg_.ts_number_layers);\n      if (video->frame() > 0) {\n       encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);\n      }\n     }\n     const vpx_rational_t tb = video->timebase();\n     timebase_ = static_cast<double>(tb.num) \/ tb.den;\n    duration_ = 0;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Chapters::Atom::ExpandDisplaysArray()\n{\n    if (m_displays_size > m_displays_count)\n        return true;  \/\/ nothing else to do\n    const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;\n    Display* const displays = new (std::nothrow) Display[size];\n    if (displays == NULL)\n        return false;\n    for (int idx = 0; idx < m_displays_count; ++idx)\n    {\n        m_displays[idx].ShallowCopy(displays[idx]);\n    }\n    delete[] m_displays;\n    m_displays = displays;\n    m_displays_size = size;\n    return true;\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_private_encrypt)\n{\n\tzval **key, *crypted;\n\tEVP_PKEY *pkey;\n\tint cryptedlen;\n\tunsigned char *cryptedbuf = NULL;\n\tint successful = 0;\n\tlong keyresource = -1;\n\tchar * data;\n\tint data_len;\n\tlong padding = RSA_PKCS1_PADDING;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"szZ|l\", &data, &data_len, &crypted, &key, &padding) == FAILURE) { \n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tpkey = php_openssl_evp_from_zval(key, 0, \"\", 0, &keyresource TSRMLS_CC);\n\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key param is not a valid private key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcryptedlen = EVP_PKEY_size(pkey);\n\tcryptedbuf = emalloc(cryptedlen + 1);\n\n\tswitch (pkey->type) {\n\t\tcase EVP_PKEY_RSA:\n\t\tcase EVP_PKEY_RSA2:\n\t\t\tsuccessful =  (RSA_private_encrypt(data_len, \n\t\t\t\t\t\t(unsigned char *)data, \n\t\t\t\t\t\tcryptedbuf, \n\t\t\t\t\t\tpkey->pkey.rsa, \n\t\t\t\t\t\tpadding) == cryptedlen);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key type not supported in this PHP build!\");\n\t}\n\n\tif (successful) {\n\t\tzval_dtor(crypted);\n\t\tcryptedbuf[cryptedlen] = '\\0';\n\t\tZVAL_STRINGL(crypted, (char *)cryptedbuf, cryptedlen, 0);\n\t\tcryptedbuf = NULL;\n\t\tRETVAL_TRUE;\n\t}\n\tif (cryptedbuf) {\n\t\tefree(cryptedbuf);\n\t}\n\tif (keyresource == -1) { \n\t\tEVP_PKEY_free(pkey);\n\t}\n}\n","project":"php","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAMRWBEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.amrwb\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAMR)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (amrParams->nChannels != 1\n || amrParams->eAMRDTXMode != OMX_AUDIO_AMRDTXModeOff\n || amrParams->eAMRFrameFormat\n != OMX_AUDIO_AMRFrameFormatFSF\n || amrParams->eAMRBandMode < OMX_AUDIO_AMRBandModeWB0\n || amrParams->eAMRBandMode > OMX_AUDIO_AMRBandModeWB8) {\n return OMX_ErrorUndefined;\n }\n\n            mBitRate = amrParams->nBitRate;\n\n            mMode = (VOAMRWBMODE)(\n                    amrParams->eAMRBandMode - OMX_AUDIO_AMRBandModeWB0);\n\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n if (VO_ERR_NONE !=\n                    mApiHandle->SetParam(\n                        mEncoderHandle, VO_PID_AMRWB_MODE, &mMode)) {\n                ALOGE(\"Failed to set AMRWB encoder mode to %d\", mMode);\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (pcmParams->nChannels != 1\n || pcmParams->nSamplingRate != (OMX_U32)kSampleRate) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"icc_base_conv_pixmap(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tfz_colorspace *srcs = src->colorspace;\n\tfz_colorspace *base_cs = get_base_icc_space(ctx, srcs);\n\tint i, j;\n\tunsigned char *inputpos, *outputpos;\n\tfz_pixmap *base;\n\tfz_irect bbox;\n\tint h, len;\n\tfloat src_f[FZ_MAX_COLORS], des_f[FZ_MAX_COLORS];\n\tint sn = src->n;\n\tint sc = sn - src->alpha - src->s;\n\tint stride_src = src->stride - src->w * sn;\n\tint stride_base;\n\tint bn, bc;\n\n\tbase = fz_new_pixmap_with_bbox(ctx, base_cs, fz_pixmap_bbox(ctx, src, &bbox), src->seps, src->alpha);\n\tbn = base->n;\n\tbc = base->n - base->alpha - base->s;\n\tstride_base = base->stride - base->w * bn;\n\n\tinputpos = src->samples;\n\toutputpos = base->samples;\n\n\th = src->h;\n\twhile (h--)\n\t{\n\t\tlen = src->w;\n\t\twhile (len--)\n\t\t{\n\t\t\t\/* Convert the actual colors *\/\n\t\t\tfor (i = 0; i < sc; i++)\n\t\t\t\tsrc_f[i] = (float) inputpos[i] \/ 255.0f;\n\n\t\t\tconvert_to_icc_base(ctx, srcs, src_f, des_f);\n\t\t\tbase_cs->clamp(base_cs, des_f, des_f);\n\n\t\t\tfor (j = 0; j < bc; j++)\n\t\t\t\toutputpos[j] = des_f[j] * 255.0f;\n\t\t\t\/* Copy spots and alphas unchanged *\/\n\t\t\tfor (; i < sn; i++, j++)\n\t\t\t\toutputpos[j] = inputpos[i];\n\n\t\t\toutputpos += bn;\n\t\t\tinputpos += sn;\n\t\t}\n\t\toutputpos += stride_base;\n\t\tinputpos += stride_src;\n\t}\n\n\tfz_try(ctx)\n\t\ticc_conv_pixmap(ctx, dst, base, prf, default_cs, color_params, copy_spots);\n\tfz_always(ctx)\n\t\tfz_drop_pixmap(ctx, base);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Track::GetLacing() const\n{\n    return m_info.lacing;\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"transit_init (void)\n{\n  transit_hash = hash_create (transit_hash_key_make, transit_hash_cmp);\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const SeekHead::Entry* SeekHead::GetEntry(int idx) const\n{\n    if (idx < 0)\n        return 0;\n    if (idx >= m_entry_count)\n        return 0;\n    return m_entries + idx;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Chapters::Edition::ExpandAtomsArray()\n{\n    if (m_atoms_size > m_atoms_count)\n        return true;  \/\/ nothing else to do\n \n    const int size = (m_atoms_size == 0) ? 1 : 2 * m_atoms_size;\n \n    Atom* const atoms = new (std::nothrow) Atom[size];\n \n    if (atoms == NULL)\n        return false;\n \n    for (int idx = 0; idx < m_atoms_count; ++idx)\n    {\n        m_atoms[idx].ShallowCopy(atoms[idx]);\n     }\n \n    delete[] m_atoms;\n    m_atoms = atoms;\n \n    m_atoms_size = size;\n    return true;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_keep_link_key(fz_context *ctx, void *key_)\n{\n\tfz_link_key *key = (fz_link_key *)key_;\n\treturn fz_keep_imp(ctx, key, &key->refs);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  virtual uint8_t* GetReference(int block_idx) {\n     return reference_data_ + block_idx * kDataBlockSize;\n   }\n","project":"Android","target":1},{"commit_id":"94d9e646454f6246bf823b6897bd6aea5f08eda3","func":"status_t ACodec::setupAACCodec(\n bool encoder, int32_t numChannels, int32_t sampleRate,\n int32_t bitRate, int32_t aacProfile, bool isADTS, int32_t sbrMode,\n int32_t maxOutputChannelCount, const drcParams_t& drc,\n int32_t pcmLimiterEnable) {\n if (encoder && isADTS) {\n return -EINVAL;\n }\n\n status_t err = setupRawAudioFormat(\n            encoder ? kPortIndexInput : kPortIndexOutput,\n            sampleRate,\n            numChannels);\n\n if (err != OK) {\n return err;\n }\n\n if (encoder) {\n        err = selectAudioPortFormat(kPortIndexOutput, OMX_AUDIO_CodingAAC);\n\n if (err != OK) {\n return err;\n }\n\n        OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n        def.nPortIndex = kPortIndexOutput;\n\n        err = mOMX->getParameter(\n                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n        def.format.audio.bFlagErrorConcealment = OMX_TRUE;\n        def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;\n\n        err = mOMX->setParameter(\n                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n        OMX_AUDIO_PARAM_AACPROFILETYPE profile;\n InitOMXParams(&profile);\n        profile.nPortIndex = kPortIndexOutput;\n\n        err = mOMX->getParameter(\n                mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n        profile.nChannels = numChannels;\n\n        profile.eChannelMode =\n (numChannels == 1)\n ? OMX_AUDIO_ChannelModeMono: OMX_AUDIO_ChannelModeStereo;\n\n        profile.nSampleRate = sampleRate;\n        profile.nBitRate = bitRate;\n        profile.nAudioBandWidth = 0;\n        profile.nFrameLength = 0;\n        profile.nAACtools = OMX_AUDIO_AACToolAll;\n        profile.nAACERtools = OMX_AUDIO_AACERNone;\n        profile.eAACProfile = (OMX_AUDIO_AACPROFILETYPE) aacProfile;\n        profile.eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n switch (sbrMode) {\n case 0:\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case -1:\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n return BAD_VALUE;\n }\n\n\n        err = mOMX->setParameter(\n                mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n return err;\n }\n\n    OMX_AUDIO_PARAM_AACPROFILETYPE profile;\n InitOMXParams(&profile);\n    profile.nPortIndex = kPortIndexInput;\n\n    err = mOMX->getParameter(\n            mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n    profile.nChannels = numChannels;\n    profile.nSampleRate = sampleRate;\n\n    profile.eAACStreamFormat =\n        isADTS\n ? OMX_AUDIO_AACStreamFormatMP4ADTS\n\n             : OMX_AUDIO_AACStreamFormatMP4FF;\n \n     OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE presentation;\n     presentation.nMaxOutputChannels = maxOutputChannelCount;\n     presentation.nDrcCut = drc.drcCut;\n     presentation.nDrcBoost = drc.drcBoost;\n    presentation.nHeavyCompression = drc.heavyCompression;\n    presentation.nTargetReferenceLevel = drc.targetRefLevel;\n    presentation.nEncodedTargetLevel = drc.encodedTargetLevel;\n    presentation.nPCMLimiterEnable = pcmLimiterEnable;\n\n status_t res = mOMX->setParameter(mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n if (res == OK) {\n        mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAacPresentation,\n &presentation, sizeof(presentation));\n } else {\n        ALOGW(\"did not set AudioAndroidAacPresentation due to error %d when setting AudioAac\", res);\n }\n return res;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* SegmentInfo::GetWritingAppAsUTF8() const\n{\n    return m_pWritingAppAsUTF8;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const CuePoint* Cues::GetLast() const\n{\n    if (m_cue_points == NULL)\n        return NULL;\n    if (m_count <= 0)\n        return NULL;\n \n #if 0\n     LoadCuePoint();  \/\/init cues\n\n const size_t count = m_count + m_preload_count;\n\n if (count == 0) \/\/weird\n return NULL;\n\n const size_t index = count - 1;\n\n CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n\n CuePoint* const pCP = pp[index];\n    assert(pCP);\n\n\n     pCP->Load(m_pSegment->m_pReader);\n     assert(pCP->GetTimeCode() >= 0);\n #else\n    const long index = m_count - 1;\n \n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n \n    CuePoint* const pCP = pp[index];\n    assert(pCP);\n    assert(pCP->GetTimeCode() >= 0);\n #endif\n \n    return pCP;\n }\n","project":"Android","target":1},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"int show_line(FILE *stream, struct name_list **acl_names,  acl_t acl,\n              acl_entry_t *acl_ent, const char *acl_mask,\n              struct name_list **dacl_names, acl_t dacl,\n\t      acl_entry_t *dacl_ent, const char *dacl_mask)\n{\n\tacl_tag_t tag_type;\n\tconst char *tag, *name;\n\tchar acl_perm[ACL_PERMS+1], dacl_perm[ACL_PERMS+1];\n\n\tif (acl) {\n\t\tacl_get_tag_type(*acl_ent, &tag_type);\n\t\tname = (*acl_names)->name;\n\t} else {\n\t\tacl_get_tag_type(*dacl_ent, &tag_type);\n\t\tname = (*dacl_names)->name;\n\t}\n\n\tswitch(tag_type) {\n\t\tcase ACL_USER_OBJ:\n\t\t\ttag = \"USER\";\n\t\t\tbreak;\n\t\tcase ACL_USER:\n\t\t\ttag = \"user\";\n\t\t\tbreak;\n\t\tcase ACL_GROUP_OBJ:\n\t\t\ttag = \"GROUP\";\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\ttag = \"group\";\n\t\t\tbreak;\n\t\tcase ACL_MASK:\n\t\t\ttag = \"mask\";\n\t\t\tbreak;\n\t\tcase ACL_OTHER:\n\t\t\ttag = \"other\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\n\tmemset(acl_perm, ' ', ACL_PERMS);\n\tacl_perm[ACL_PERMS] = '\\0';\n\tif (acl_ent) {\n\t\tacl_perm_str(*acl_ent, acl_perm);\n\t\tif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&\n\t\t    tag_type != ACL_MASK)\n\t\t\tapply_mask(acl_perm, acl_mask);\n\t}\n\tmemset(dacl_perm, ' ', ACL_PERMS);\n\tdacl_perm[ACL_PERMS] = '\\0';\n\tif (dacl_ent) {\n\t\tacl_perm_str(*dacl_ent, dacl_perm);\n\t\tif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&\n\t\t    tag_type != ACL_MASK)\n\t\t\tapply_mask(dacl_perm, dacl_mask);\n\t}\n\n\tfprintf(stream, \"%-5s  %*s  %*s  %*s\\n\",\n\t        tag, -names_width, name,\n\t        -(int)ACL_PERMS, acl_perm,\n\t\t-(int)ACL_PERMS, dacl_perm);\n\n\tif (acl_names) {\n\t\tacl_get_entry(acl, ACL_NEXT_ENTRY, acl_ent);\n\t\t(*acl_names) = (*acl_names)->next;\n\t}\n\tif (dacl_names) {\n\t\tacl_get_entry(dacl, ACL_NEXT_ENTRY, dacl_ent);\n\t\t(*dacl_names) = (*dacl_names)->next;\n\t}\n\treturn 0;\n}\n","project":"savannah","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static inline void add_offset_pair(zval *result, char *str, int len, int offset, char *name)\n{\n\tzval *match_pair;\n\n\tALLOC_ZVAL(match_pair);\n\tarray_init(match_pair);\n\tINIT_PZVAL(match_pair);\n\n\t\/* Add (match, offset) to the return value *\/\n\tadd_next_index_stringl(match_pair, str, len, 1);\n\tadd_next_index_long(match_pair, offset);\n\t\n\tif (name) {\n\t\tzval_add_ref(&match_pair);\n\t\tzend_hash_update(Z_ARRVAL_P(result), name, strlen(name)+1, &match_pair, sizeof(zval *), NULL);\n\t}\n\tzend_hash_next_index_insert(Z_ARRVAL_P(result), &match_pair, sizeof(zval *), NULL);\n}\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_extra_get (struct attr *attr)\n{\n  if (!attr->extra)\n    attr->extra = bgp_attr_extra_new();\n  return attr->extra;\n}\n","project":"savannah","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_lookup_cmap(pdf_cmap *cmap, unsigned int cpt)\n{\n\tpdf_range *ranges = cmap->ranges;\n\tpdf_xrange *xranges = cmap->xranges;\n\tint l, r, m;\n\n\tl = 0;\n\tr = cmap->rlen - 1;\n\twhile (l <= r)\n\t{\n\t\tm = (l + r) >> 1;\n\t\tif (cpt < ranges[m].low)\n\t\t\tr = m - 1;\n\t\telse if (cpt > ranges[m].high)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn cpt - ranges[m].low + ranges[m].out;\n\t}\n\n\tl = 0;\n\tr = cmap->xlen - 1;\n\twhile (l <= r)\n\t{\n\t\tm = (l + r) >> 1;\n\t\tif (cpt < xranges[m].low)\n\t\t\tr = m - 1;\n\t\telse if (cpt > xranges[m].high)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn cpt - xranges[m].low + xranges[m].out;\n\t}\n\n\tif (cmap->usecmap)\n\t\treturn pdf_lookup_cmap(cmap->usecmap, cpt);\n\n\treturn -1;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_rgb(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && cs->type == FZ_COLORSPACE_RGB;\n}\n","project":"ghostscript","target":0},{"commit_id":"ca8ac8acdad662230ae37998c6c4091bb39402b6","func":"void SparseBitSet::initFromRanges(const uint32_t* ranges, size_t nRanges) {\n if (nRanges == 0) {\n        mMaxVal = 0;\n        mIndices.reset();\n        mBitmaps.reset();\n return;\n }\n    mMaxVal = ranges[nRanges * 2 - 1];\n size_t indexSize = (mMaxVal + kPageMask) >> kLogValuesPerPage;\n    mIndices.reset(new uint32_t[indexSize]);\n uint32_t nPages = calcNumPages(ranges, nRanges);\n    mBitmaps.reset(new element[nPages << (kLogValuesPerPage - kLogBitsPerEl)]);\n    memset(mBitmaps.get(), 0, nPages << (kLogValuesPerPage - 3));\n    mZeroPageIndex = noZeroPage;\n uint32_t nonzeroPageEnd = 0;\n uint32_t currentPage = 0;\n\n     for (size_t i = 0; i < nRanges; i++) {\n         uint32_t start = ranges[i * 2];\n         uint32_t end = ranges[i * 2 + 1];\n         uint32_t startPage = start >> kLogValuesPerPage;\n         uint32_t endPage = (end - 1) >> kLogValuesPerPage;\n         if (startPage >= nonzeroPageEnd) {\n if (startPage > nonzeroPageEnd) {\n if (mZeroPageIndex == noZeroPage) {\n                    mZeroPageIndex = (currentPage++) << (kLogValuesPerPage - kLogBitsPerEl);\n }\n for (uint32_t j = nonzeroPageEnd; j < startPage; j++) {\n                    mIndices[j] = mZeroPageIndex;\n }\n }\n            mIndices[startPage] = (currentPage++) << (kLogValuesPerPage - kLogBitsPerEl);\n }\n\n size_t index = ((currentPage - 1) << (kLogValuesPerPage - kLogBitsPerEl)) +\n ((start & kPageMask) >> kLogBitsPerEl);\n size_t nElements = (end - (start & ~kElMask) + kElMask) >> kLogBitsPerEl;\n if (nElements == 1) {\n            mBitmaps[index] |= (kElAllOnes >> (start & kElMask)) &\n (kElAllOnes << ((-end) & kElMask));\n } else {\n            mBitmaps[index] |= kElAllOnes >> (start & kElMask);\n for (size_t j = 1; j < nElements - 1; j++) {\n                mBitmaps[index + j] = kElAllOnes;\n }\n            mBitmaps[index + nElements - 1] |= kElAllOnes << ((-end) & kElMask);\n }\n for (size_t j = startPage + 1; j < endPage + 1; j++) {\n            mIndices[j] = (currentPage++) << (kLogValuesPerPage - kLogBitsPerEl);\n }\n        nonzeroPageEnd = endPage + 1;\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"std_conv_pixmap(fz_context *ctx, fz_pixmap *dst, fz_pixmap *src, fz_colorspace *prf, const fz_default_colorspaces *default_cs, const fz_color_params *color_params, int copy_spots)\n{\n\tfloat srcv[FZ_MAX_COLORS];\n\tfloat dstv[FZ_MAX_COLORS];\n\tint srcn, dstn;\n\tint k, i;\n\tsize_t w = src->w;\n\tint h = src->h;\n\tptrdiff_t d_line_inc = dst->stride - w * dst->n;\n\tptrdiff_t s_line_inc = src->stride - w * src->n;\n\tint da = dst->alpha;\n\tint sa = src->alpha;\n\n\tfz_colorspace *ss = src->colorspace;\n\tfz_colorspace *ds = dst->colorspace;\n\n\tunsigned char *s = src->samples;\n\tunsigned char *d = dst->samples;\n\n\tif ((int)w < 0 || h < 0)\n\t\treturn;\n\n\tif (color_params == NULL)\n\t\tcolor_params = fz_default_color_params(ctx);\n\n\tsrcn = ss->n;\n\tdstn = ds->n;\n\n\tassert(src->w == dst->w && src->h == dst->h);\n\tassert(src->n == srcn + sa);\n\tassert(dst->n == dstn + da);\n\n\tif (d_line_inc == 0 && s_line_inc == 0)\n\t{\n\t\tw *= h;\n\t\th = 1;\n\t}\n\n\t\/* Special case for Lab colorspace (scaling of components to float) *\/\n\tif ((fz_colorspace_is_lab(ctx, ss) || fz_colorspace_is_lab_icc(ctx, ss)) && srcn == 3)\n\t{\n\t\tfz_color_converter cc;\n\n\t\tfz_find_color_converter(ctx, &cc, NULL, ds, ss, color_params);\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tsrcv[0] = *s++ \/ 255.0f * 100;\n\t\t\t\tsrcv[1] = *s++ - 128;\n\t\t\t\tsrcv[2] = *s++ - 128;\n\n\t\t\t\tcc.convert(ctx, &cc, dstv, srcv);\n\n\t\t\t\tfor (k = 0; k < dstn; k++)\n\t\t\t\t\t*d++ = dstv[k] * 255;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = (sa ? *s : 255);\n\t\t\t\ts += sa;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t\tfz_drop_color_converter(ctx, &cc);\n\t}\n\n\t\/* Brute-force for small images *\/\n\telse if (w*h < 256)\n\t{\n\t\tfz_color_converter cc;\n\n\t\tfz_find_color_converter(ctx, &cc, NULL, ds, ss, color_params);\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\tfor (k = 0; k < srcn; k++)\n\t\t\t\t\tsrcv[k] = *s++ \/ 255.0f;\n\n\t\t\t\tcc.convert(ctx, &cc, dstv, srcv);\n\n\t\t\t\tfor (k = 0; k < dstn; k++)\n\t\t\t\t\t*d++ = dstv[k] * 255;\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = (sa ? *s : 255);\n\t\t\t\ts += sa;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t\tfz_drop_color_converter(ctx, &cc);\n\t}\n\n\t\/* 1-d lookup table for separation and similar colorspaces *\/\n\telse if (srcn == 1)\n\t{\n\t\tunsigned char lookup[FZ_MAX_COLORS * 256];\n\t\tfz_color_converter cc;\n\n\t\tfz_find_color_converter(ctx, &cc, NULL, ds, ss, color_params);\n\t\tfor (i = 0; i < 256; i++)\n\t\t{\n\t\t\tsrcv[0] = i \/ 255.0f;\n\t\t\tcc.convert(ctx, &cc, dstv, srcv);\n\t\t\tfor (k = 0; k < dstn; k++)\n\t\t\t\tlookup[i * dstn + k] = dstv[k] * 255;\n\t\t}\n\t\tfz_drop_color_converter(ctx, &cc);\n\n\t\twhile (h--)\n\t\t{\n\t\t\tsize_t ww = w;\n\t\t\twhile (ww--)\n\t\t\t{\n\t\t\t\ti = *s++;\n\t\t\t\tfor (k = 0; k < dstn; k++)\n\t\t\t\t\t*d++ = lookup[i * dstn + k];\n\t\t\t\tif (da)\n\t\t\t\t\t*d++ = (sa ? *s : 255);\n\t\t\t\ts += sa;\n\t\t\t}\n\t\t\td += d_line_inc;\n\t\t\ts += s_line_inc;\n\t\t}\n\t}\n\n\t\/* Memoize colors using a hash table for the general case *\/\n\telse\n\t{\n\t\tfz_hash_table *lookup;\n\t\tunsigned char *color;\n\t\tunsigned char dummy = s[0] ^ 255;\n\t\tunsigned char *sold = &dummy;\n\t\tunsigned char *dold;\n\t\tfz_color_converter cc;\n\n\t\tlookup = fz_new_hash_table(ctx, 509, srcn, -1, NULL);\n\t\tfz_find_color_converter(ctx, &cc, NULL, ds, ss, color_params);\n\n\t\tfz_try(ctx)\n\t\t{\n\t\t\twhile (h--)\n\t\t\t{\n\t\t\t\tsize_t ww = w;\n\t\t\t\twhile (ww--)\n\t\t\t\t{\n\t\t\t\t\tif (*s == *sold && memcmp(sold,s,srcn) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsold = s;\n\t\t\t\t\t\tmemcpy(d, dold, dstn);\n\t\t\t\t\t\td += dstn;\n\t\t\t\t\t\ts += srcn;\n\t\t\t\t\t\tif (da)\n\t\t\t\t\t\t\t*d++ = (sa ? *s : 255);\n\t\t\t\t\t\ts += sa;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsold = s;\n\t\t\t\t\t\tdold = d;\n\t\t\t\t\t\tcolor = fz_hash_find(ctx, lookup, s);\n\t\t\t\t\t\tif (color)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy(d, color, dstn);\n\t\t\t\t\t\t\ts += srcn;\n\t\t\t\t\t\t\td += dstn;\n\t\t\t\t\t\t\tif (da)\n\t\t\t\t\t\t\t\t*d++ = (sa ? *s : 255);\n\t\t\t\t\t\t\ts += sa;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (k = 0; k < srcn; k++)\n\t\t\t\t\t\t\t\tsrcv[k] = *s++ \/ 255.0f;\n\t\t\t\t\t\t\tcc.convert(ctx, &cc, dstv, srcv);\n\t\t\t\t\t\t\tfor (k = 0; k < dstn; k++)\n\t\t\t\t\t\t\t\t*d++ = dstv[k] * 255;\n\n\t\t\t\t\t\t\tfz_hash_insert(ctx, lookup, s - srcn, d - dstn);\n\n\t\t\t\t\t\t\tif (da)\n\t\t\t\t\t\t\t\t*d++ = (sa ? *s : 255);\n\t\t\t\t\t\t\ts += sa;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\td += d_line_inc;\n\t\t\t\ts += s_line_inc;\n\t\t\t}\n\t\t}\n\t\tfz_always(ctx)\n\t\t\tfz_drop_color_converter(ctx, &cc);\n\t\tfz_catch(ctx)\n\t\t\tfz_rethrow(ctx);\n\n\t\tfz_drop_hash_table(ctx, lookup);\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":" ContentEncoding::ContentEncoding()\n : compression_entries_(NULL),\n      compression_entries_end_(NULL),\n      encryption_entries_(NULL),\n\n       encryption_entries_end_(NULL),\n       encoding_order_(0),\n       encoding_scope_(1),\n      encoding_type_(0) {\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" static void unset_active_map(const vpx_codec_enc_cfg_t *cfg,\n                              vpx_codec_ctx_t *codec) {\n  vpx_active_map_t map = {0};\n \n   map.rows = (cfg->g_h + 15) \/ 16;\n   map.cols = (cfg->g_w + 15) \/ 16;\n map.active_map = NULL;\n\n if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))\n\n     die_codec(codec, \"Failed to set active map\");\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_default_output_intent(fz_context *ctx, const fz_default_colorspaces *default_cs)\n{\n\tif (default_cs)\n\t\treturn default_cs->oi;\n\telse\n\t\treturn NULL;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision)\n{\n    major = 1;\n    minor = 0;\n    build = 0;\n    revision = 27;\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_free_alias(phar_archive_data *phar, char *alias, int alias_len TSRMLS_DC) \/* {{{ *\/\n{\n\tif (phar->refcount || phar->is_persistent) {\n\t\treturn FAILURE;\n\t}\n\n\t\/* this archive has no open references, so emit an E_STRICT and remove it *\/\n\tif (zend_hash_del(&(PHAR_GLOBALS->phar_fname_map), phar->fname, phar->fname_len) != SUCCESS) {\n\t\treturn FAILURE;\n\t}\n\n\t\/* invalidate phar cache *\/\n\tPHAR_G(last_phar) = NULL;\n\tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;\n\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_write(SSL *s, const void *buf, int len)\n\t{\n\tint ret,n;\n\n#if 0\n\tif (s->shutdown & SSL_SEND_SHUTDOWN)\n\t\t{\n\t\ts->rwstate=SSL_NOTHING;\n\t\treturn(0);\n\t\t}\n#endif\n\tclear_sys_error();\n\tif (s->s3->renegotiate) ssl3_renegotiate_check(s);\n\n\t\/* This is an experimental flag that sends the\n\t * last handshake message in the same packet as the first\n\t * use data - used to see if it helps the TCP protocol during\n\t * session-id reuse *\/\n\t\/* The second test is because the buffer may have been removed *\/\n\tif ((s->s3->flags & SSL3_FLAGS_POP_BUFFER) && (s->wbio == s->bbio))\n\t\t{\n\t\t\/* First time through, we write into the buffer *\/\n\t\tif (s->s3->delay_buf_pop_ret == 0)\n\t\t\t{\n\t\t\tret=ssl3_write_bytes(s,SSL3_RT_APPLICATION_DATA,\n\t\t\t\t\t     buf,len);\n\t\t\tif (ret <= 0) return(ret);\n\n\t\t\ts->s3->delay_buf_pop_ret=ret;\n\t\t\t}\n\n\t\ts->rwstate=SSL_WRITING;\n\t\tn=BIO_flush(s->wbio);\n\t\tif (n <= 0) return(n);\n\t\ts->rwstate=SSL_NOTHING;\n\n\t\t\/* We have flushed the buffer, so remove it *\/\n\t\tssl_free_wbio_buffer(s);\n\t\ts->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\n\n\t\tret=s->s3->delay_buf_pop_ret;\n\t\ts->s3->delay_buf_pop_ret=0;\n\t\t}\n\telse\n\t\t{\n\t\tret=s->method->ssl_write_bytes(s,SSL3_RT_APPLICATION_DATA,\n\t\t\tbuf,len);\n\t\tif (ret <= 0) return(ret);\n\t\t}\n\n\treturn(ret);\n\t}\n","project":"openssl","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const BlockEntry* Cluster::GetEntry(\n    const Track* pTrack,\n    long long time_ns) const\n{\n    assert(pTrack);\n    if (m_pSegment == NULL)  \/\/this is the special EOS cluster\n        return pTrack->GetEOS();\n \n #if 0\n \n LoadBlockEntries();\n\n if ((m_entries == NULL) || (m_entries_count <= 0))\n return NULL; \/\/return EOS here?\n\n const BlockEntry* pResult = pTrack->GetEOS();\n\n BlockEntry** i = m_entries;\n    assert(i);\n\n BlockEntry** const j = i + m_entries_count;\n\n while (i != j)\n {\n const BlockEntry* const pEntry = *i++;\n        assert(pEntry);\n        assert(!pEntry->EOS());\n\n const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n\n if (pBlock->GetTrackNumber() != pTrack->GetNumber())\n continue;\n\n if (pTrack->VetEntry(pEntry))\n {\n if (time_ns < 0) \/\/just want first candidate block\n return pEntry;\n\n const long long ns = pBlock->GetTime(this);\n\n if (ns > time_ns)\n break;\n\n            pResult = pEntry;\n }\n else if (time_ns >= 0)\n {\n const long long ns = pBlock->GetTime(this);\n\n if (ns > time_ns)\n break;\n }\n }\n\n return pResult;\n\n \n #else\n \n    const BlockEntry* pResult = pTrack->GetEOS();\n \n    long index = 0;\n \n    for (;;)\n    {\n        if (index >= m_entries_count)\n        {\n            long long pos;\n            long len;\n \n            const long status = Parse(pos, len);\n            assert(status >= 0);\n \n            if (status > 0)  \/\/completely parsed, and no more entries\n                return pResult;\n \n            if (status < 0)  \/\/should never happen\n                return 0;\n \n            assert(m_entries);\n            assert(index < m_entries_count);\n        }\n        const BlockEntry* const pEntry = m_entries[index];\n        assert(pEntry);\n        assert(!pEntry->EOS());\n        const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n        if (pBlock->GetTrackNumber() != pTrack->GetNumber())\n        {\n            ++index;\n            continue;\n        }\n        if (pTrack->VetEntry(pEntry))\n        {\n            if (time_ns < 0)  \/\/just want first candidate block\n                return pEntry;\n            const long long ns = pBlock->GetTime(this);\n            if (ns > time_ns)\n                return pResult;\n            pResult = pEntry;  \/\/have a candidate\n        }\n        else if (time_ns >= 0)\n        {\n            const long long ns = pBlock->GetTime(this);\n            if (ns > time_ns)\n                return pResult;\n        }\n        ++index;\n     }\n \n #endif\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static X509_STORE * setup_verify(zval * calist TSRMLS_DC)\n{\n\tX509_STORE *store;\n\tX509_LOOKUP * dir_lookup, * file_lookup;\n\tHashPosition pos;\n\tint ndirs = 0, nfiles = 0;\n\n\tstore = X509_STORE_new();\n\n\tif (store == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (calist && (Z_TYPE_P(calist) == IS_ARRAY)) {\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(calist), &pos);\n\t\tfor (;; zend_hash_move_forward_ex(HASH_OF(calist), &pos)) {\n\t\t\tzval ** item;\n\t\t\tstruct stat sb;\n\n\t\t\tif (zend_hash_get_current_data_ex(HASH_OF(calist), (void**)&item, &pos) == FAILURE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconvert_to_string_ex(item);\n\n\t\t\tif (VCWD_STAT(Z_STRVAL_PP(item), &sb) == -1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"unable to stat %s\", Z_STRVAL_PP(item));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((sb.st_mode & S_IFREG) == S_IFREG) {\n\t\t\t\tfile_lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());\n\t\t\t\tif (file_lookup == NULL || !X509_LOOKUP_load_file(file_lookup, Z_STRVAL_PP(item), X509_FILETYPE_PEM)) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error loading file %s\", Z_STRVAL_PP(item));\n\t\t\t\t} else {\n\t\t\t\t\tnfiles++;\n\t\t\t\t}\n\t\t\t\tfile_lookup = NULL;\n\t\t\t} else {\n\t\t\t\tdir_lookup = X509_STORE_add_lookup(store, X509_LOOKUP_hash_dir());\n\t\t\t\tif (dir_lookup == NULL || !X509_LOOKUP_add_dir(dir_lookup, Z_STRVAL_PP(item), X509_FILETYPE_PEM)) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error loading directory %s\", Z_STRVAL_PP(item));\n\t\t\t\t} else { \n\t\t\t\t\tndirs++;\n\t\t\t\t}\n\t\t\t\tdir_lookup = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (nfiles == 0) {\n\t\tfile_lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());\n\t\tif (file_lookup) {\n\t\t\tX509_LOOKUP_load_file(file_lookup, NULL, X509_FILETYPE_DEFAULT);\n\t\t}\n\t}\n\tif (ndirs == 0) {\n\t\tdir_lookup = X509_STORE_add_lookup(store, X509_LOOKUP_hash_dir());\n\t\tif (dir_lookup) {\n\t\t\tX509_LOOKUP_add_dir(dir_lookup, NULL, X509_FILETYPE_DEFAULT);\n\t\t}\n\t}\n\treturn store;\n}\n","project":"php","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"end_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\n\tif (save->softmask == NULL)\n\t\treturn;\n\n\tgstate->softmask = save->softmask;\n\tgstate->softmask_resources = save->page_resources;\n\tgstate->softmask_ctm = save->ctm;\n\tfz_pop_clip(ctx, pr->dev);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"AudioTrack::AudioTrack(\n    Segment* pSegment,\n    long long element_start,\n    long long element_size) :\n    Track(pSegment, element_start, element_size)\n{\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"static int phar_hex_str(const char *digest, size_t digest_len, char **signature TSRMLS_DC) \/* {{{ *\/\n{\n\tint pos = -1;\n\tsize_t len = 0;\n\n\t*signature = (char*)safe_pemalloc(digest_len, 2, 1, PHAR_G(persist));\n\n\tfor (; len < digest_len; ++len) {\n\t\t(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] >> 4];\n\t\t(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] & 0x0F];\n\t}\n\t(*signature)[++pos] = '\\0';\n\treturn pos;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Cluster::Cluster(\n    Segment* pSegment,\n    long idx,\n    long long element_start\n    \/* long long element_size *\/ ) :\n    m_pSegment(pSegment),\n    m_element_start(element_start),\n    m_index(idx),\n    m_pos(element_start),\n    m_element_size(-1 \/* element_size *\/ ),\n    m_timecode(-1),\n    m_entries(NULL),\n    m_entries_size(0),\n    m_entries_count(-1)  \/\/means \"has not been parsed yet\"\n{\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_Do_image(fz_context *ctx, pdf_processor *proc, const char *name, fz_image *image)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_image(ctx, pr, image);\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_hash_alloc (void *p)\n{\n  struct attr * val = (struct attr *) p;\n  struct attr *attr;\n\n  attr = XMALLOC (MTYPE_ATTR, sizeof (struct attr));\n  *attr = *val;\n  if (val->extra)\n    {\n      attr->extra = bgp_attr_extra_new ();\n      *attr->extra = *val->extra;\n    }\n  attr->refcnt = 0;\n  return attr;\n}\n","project":"savannah","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_csr_sign)\n{\n\tzval ** zcert = NULL, **zcsr, **zpkey, *args = NULL;\n\tlong num_days;\n\tlong serial = 0L;\n\tX509 * cert = NULL, *new_cert = NULL;\n\tX509_REQ * csr;\n\tEVP_PKEY * key = NULL, *priv_key = NULL;\n\tlong csr_resource, certresource = 0, keyresource = -1;\n\tint i;\n\tstruct php_x509_request req;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ZZ!Zl|a!l\", &zcsr, &zcert, &zpkey, &num_days, &args, &serial) == FAILURE)\n\t\treturn;\n\n\tRETVAL_FALSE;\n\tPHP_SSL_REQ_INIT(&req);\n\t\n\tcsr = php_openssl_csr_from_zval(zcsr, 0, &csr_resource TSRMLS_CC);\n\tif (csr == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get CSR from parameter 1\");\n\t\treturn;\n\t}\n\tif (zcert) {\n\t\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\t\tif (cert == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get cert from parameter 2\");\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tpriv_key = php_openssl_evp_from_zval(zpkey, 0, \"\", 1, &keyresource TSRMLS_CC);\n\tif (priv_key == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get private key from parameter 3\");\n\t\tgoto cleanup;\n\t}\n\tif (cert && !X509_check_private_key(cert, priv_key)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"private key does not correspond to signing cert\");\n\t\tgoto cleanup;\n\t}\n\t\n\tif (PHP_SSL_REQ_PARSE(&req, args) == FAILURE) {\n\t\tgoto cleanup;\n\t}\n\t\/* Check that the request matches the signature *\/\n\tkey = X509_REQ_get_pubkey(csr);\n\tif (key == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error unpacking public key\");\n\t\tgoto cleanup;\n\t}\n\ti = X509_REQ_verify(csr, key);\n\n\tif (i < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Signature verification problems\");\n\t\tgoto cleanup;\n\t}\n\telse if (i == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Signature did not match the certificate request\");\n\t\tgoto cleanup;\n\t}\n\t\n\t\/* Now we can get on with it *\/\n\t\n\tnew_cert = X509_new();\n\tif (new_cert == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No memory\");\n\t\tgoto cleanup;\n\t}\n\t\/* Version 3 cert *\/\n\tif (!X509_set_version(new_cert, 2))\n\t\tgoto cleanup;\n\n\tASN1_INTEGER_set(X509_get_serialNumber(new_cert), serial);\n\t\n\tX509_set_subject_name(new_cert, X509_REQ_get_subject_name(csr));\n\n\tif (cert == NULL) {\n\t\tcert = new_cert;\n\t}\n\tif (!X509_set_issuer_name(new_cert, X509_get_subject_name(cert))) {\n\t\tgoto cleanup;\n\t}\n\tX509_gmtime_adj(X509_get_notBefore(new_cert), 0);\n\tX509_gmtime_adj(X509_get_notAfter(new_cert), (long)60*60*24*num_days);\n\ti = X509_set_pubkey(new_cert, key);\n\tif (!i) {\n\t\tgoto cleanup;\n\t}\n\tif (req.extensions_section) {\n\t\tX509V3_CTX ctx;\n\t\t\n\t\tX509V3_set_ctx(&ctx, cert, new_cert, csr, NULL, 0);\n\t\tX509V3_set_conf_lhash(&ctx, req.req_config);\n\t\tif (!X509V3_EXT_add_conf(req.req_config, &ctx, req.extensions_section, new_cert)) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t\/* Now sign it *\/\n\tif (!X509_sign(new_cert, priv_key, req.digest)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"failed to sign it\");\n\t\tgoto cleanup;\n\t}\n\t\n\t\/* Succeeded; lets return the cert *\/\n\tRETVAL_RESOURCE(zend_list_insert(new_cert, le_x509));\n\tnew_cert = NULL;\n\t\ncleanup:\n\n\tif (cert == new_cert) {\n\t\tcert = NULL;\n\t}\n\tPHP_SSL_REQ_DISPOSE(&req);\n\n\tif (keyresource == -1 && priv_key) {\n\t\tEVP_PKEY_free(priv_key);\n\t}\n\tif (key) {\n\t\tEVP_PKEY_free(key);\n\t}\n\tif (csr_resource == -1 && csr) {\n\t\tX509_REQ_free(csr);\n\t}\n\tif (certresource == -1 && cert) { \n\t\tX509_free(cert);\n\t}\n\tif (new_cert) {\n\t\tX509_free(new_cert);\n\t}\n}\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_aspath (struct bgp_attr_parser_args *args)\n{\n  struct attr *const attr = args->attr;\n  struct peer *const peer = args->peer; \n  const bgp_size_t length = args->length;\n  \n  \/*\n   * peer with AS4 => will get 4Byte ASnums\n   * otherwise, will get 16 Bit\n   *\/\n  attr->aspath = aspath_parse (peer->ibuf, length, \n                               CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV));\n\n  \/* In case of IBGP, length will be zero. *\/\n  if (! attr->aspath)\n    {\n      zlog (peer->log, LOG_ERR,\n            \"Malformed AS path from %s, length is %d\",\n            peer->host, length);\n      return bgp_attr_malformed (args, BGP_NOTIFY_UPDATE_MAL_AS_PATH, 0);\n    }\n\n  \/* Set aspath attribute flag. *\/\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_drop_color_converter(fz_context *ctx, fz_color_converter *cc)\n{\n\tfz_icclink *link = (fz_icclink *)cc->link;\n\tif (link)\n\t\tfz_drop_icclink(ctx, link);\n\tcc->link = NULL;\n\n}\n","project":"ghostscript","target":0},{"commit_id":"03a53d1c7765eeb3af0bc34c3dff02ada1953fbf","func":" bool InputWindowInfo::frameContainsPoint(int32_t x, int32_t y) const {\n    return x >= frameLeft && x <= frameRight\n            && y >= frameTop && y <= frameBottom;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n\n     video_->Init();\n     video_->Begin();\n \n    vpx_codec_dec_cfg_t cfg = {0};\n     decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n     ASSERT_TRUE(decoder_ != NULL);\n   }\n","project":"Android","target":1},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"freefileinfo (struct fileinfo *f)\n{\n  while (f)\n    {\n      struct fileinfo *next = f->next;\n      xfree (f->name);\n      if (f->linkto)\n        xfree (f->linkto);\n      xfree (f);\n      f = next;\n    }\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"mkvparser::IMkvReader::~IMkvReader()\n{\n\/\/\/\/ Disable MSVC warnings that suggest making code non-portable.\n }\n","project":"Android","target":1},{"commit_id":"8e3be529372892e20ccf196809bc73276c822189","func":"resetLppTransposer (HANDLE_SBR_LPP_TRANS hLppTrans, \/*!< Handle of lpp transposer  *\/\n                    UCHAR  highBandStartSb, \/*!< High band area: start subband *\/\n                    UCHAR *v_k_master, \/*!< Master table *\/\n                    UCHAR  numMaster, \/*!< Valid entries in master table *\/\n                    UCHAR *noiseBandTable, \/*!< Mapping of SBR noise bands to QMF bands *\/\n                    UCHAR  noNoiseBands, \/*!< Number of noise bands *\/\n                    UCHAR  usb, \/*!< High band area: stop subband *\/\n                    UINT   fs                        \/*!< SBR output sampling frequency *\/\n )\n{\n  TRANSPOSER_SETTINGS *pSettings = hLppTrans->pSettings;\n  PATCH_PARAM  *patchParam = pSettings->patchParam;\n\n int i, patch;\n int targetStopBand;\n int sourceStartBand;\n int patchDistance;\n int numBandsInPatch;\n\n int lsb = v_k_master[0]; \/* Start subband expressed in \"non-critical\" sampling terms*\/\n int xoverOffset = highBandStartSb - lsb; \/* Calculate distance in QMF bands between k0 and kx *\/\n int startFreqHz;\n\n int desiredBorder;\n\n  usb = fixMin(usb, v_k_master[numMaster]); \/* Avoid endless loops (compare with float code). *\/\n\n \/*\n   * Plausibility check\n   *\/\n\n if ( lsb - SHIFT_START_SB < 4 ) {\n return SBRDEC_UNSUPPORTED_CONFIG;\n }\n\n\n \/*\n   * Initialize the patching parameter\n   *\/\n \/* ISO\/IEC 14496-3 (Figure 4.48): goalSb = round( 2.048e6 \/ fs ) *\/\n  desiredBorder    = (((2048000*2) \/ fs) + 1) >> 1;\n\n  desiredBorder = findClosestEntry(desiredBorder, v_k_master, numMaster, 1); \/* Adapt region to master-table *\/\n\n \/* First patch *\/\n  sourceStartBand = SHIFT_START_SB + xoverOffset;\n  targetStopBand = lsb + xoverOffset; \/* upperBand *\/\n\n \/* Even (odd) numbered channel must be patched to even (odd) numbered channel *\/\n  patch = 0;\n while(targetStopBand < usb) {\n\n \/* Too many patches?\n       Allow MAX_NUM_PATCHES+1 patches here.\n       we need to check later again, since patch might be the highest patch\n       AND contain less than 3 bands => actual number of patches will be reduced by 1.\n    *\/\n if (patch > MAX_NUM_PATCHES) {\n return SBRDEC_UNSUPPORTED_CONFIG;\n }\n\n    patchParam[patch].guardStartBand = targetStopBand;\n    patchParam[patch].targetStartBand = targetStopBand;\n\n    numBandsInPatch = desiredBorder - targetStopBand; \/* Get the desired range of the patch *\/\n\n if ( numBandsInPatch >= lsb - sourceStartBand ) {\n \/* Desired number bands are not available -> patch whole source range *\/\n      patchDistance   = targetStopBand - sourceStartBand; \/* Get the targetOffset *\/\n      patchDistance   = patchDistance & ~1; \/* Rounding off odd numbers and make all even *\/\n      numBandsInPatch = lsb - (targetStopBand - patchDistance); \/* Update number of bands to be patched *\/\n      numBandsInPatch = findClosestEntry(targetStopBand + numBandsInPatch, v_k_master, numMaster, 0) -\n                        targetStopBand; \/* Adapt region to master-table *\/\n }\n\n \/* Desired number bands are available -> get the minimal even patching distance *\/\n    patchDistance   = numBandsInPatch + targetStopBand - lsb; \/* Get minimal distance *\/\n    patchDistance   = (patchDistance + 1) & ~1; \/* Rounding up odd numbers and make all even *\/\n\n if (numBandsInPatch > 0) {\n      patchParam[patch].sourceStartBand = targetStopBand - patchDistance;\n      patchParam[patch].targetBandOffs  = patchDistance;\n      patchParam[patch].numBandsInPatch = numBandsInPatch;\n      patchParam[patch].sourceStopBand  = patchParam[patch].sourceStartBand + numBandsInPatch;\n\n      targetStopBand += patchParam[patch].numBandsInPatch;\n      patch++;\n }\n\n \/* All patches but first *\/\n    sourceStartBand = SHIFT_START_SB;\n\n \/* Check if we are close to desiredBorder *\/\n if( desiredBorder - targetStopBand < 3) \/* MPEG doc *\/\n {\n      desiredBorder = usb;\n }\n\n }\n\n  patch--;\n\n \/* If highest patch contains less than three subband: skip it *\/\n if ( (patch>0) && (patchParam[patch].numBandsInPatch < 3) ) {\n    patch--;\n    targetStopBand = patchParam[patch].targetStartBand + patchParam[patch].numBandsInPatch;\n }\n\n \/* now check if we don't have one too many *\/\n if (patch >= MAX_NUM_PATCHES) {\n return SBRDEC_UNSUPPORTED_CONFIG;\n }\n\n  pSettings->noOfPatches = patch + 1;\n\n \/* Check lowest and highest source subband *\/\n  pSettings->lbStartPatching = targetStopBand;\n  pSettings->lbStopPatching  = 0;\n for ( patch = 0; patch < pSettings->noOfPatches; patch++ ) {\n    pSettings->lbStartPatching = fixMin( pSettings->lbStartPatching, patchParam[patch].sourceStartBand );\n    pSettings->lbStopPatching  = fixMax( pSettings->lbStopPatching, patchParam[patch].sourceStopBand );\n }\n\n\n   for(i = 0 ; i < noNoiseBands; i++){\n     pSettings->bwBorders[i] = noiseBandTable[i+1];\n   }\n \n   \/*\n    * Choose whitening factors\n   *\/\n\n  startFreqHz = ( (lsb + xoverOffset)*fs ) >> 7; \/* Shift does a division by 2*(64) *\/\n\n for( i = 1; i < NUM_WHFACTOR_TABLE_ENTRIES; i++ )\n {\n if( startFreqHz < FDK_sbrDecoder_sbr_whFactorsIndex[i])\n break;\n }\n  i--;\n\n  pSettings->whFactors.off = FDK_sbrDecoder_sbr_whFactorsTable[i][0];\n  pSettings->whFactors.transitionLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][1];\n  pSettings->whFactors.lowLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][2];\n  pSettings->whFactors.midLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][3];\n  pSettings->whFactors.highLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][4];\n\n return SBRDEC_OK;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Block::IsInvisible() const\n{\n    return bool(int(m_flags & 0x08) != 0);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const CuePoint* Cues::GetNext(const CuePoint* pCurr) const\n{\n    if (pCurr == NULL)\n        return NULL;\n    assert(pCurr->GetTimeCode() >= 0);\n    assert(m_cue_points);\n    assert(m_count >= 1);\n \n #if 0\n     const size_t count = m_count + m_preload_count;\n\n size_t index = pCurr->m_index;\n    assert(index < count);\n\n CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    assert(pp[index] == pCurr);\n\n ++index;\n\n if (index >= count)\n return NULL;\n\n CuePoint* const pNext = pp[index];\n    assert(pNext);\n\n \n     pNext->Load(m_pSegment->m_pReader);\n #else\n    long index = pCurr->m_index;\n    assert(index < m_count);\n \n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    assert(pp[index] == pCurr);\n \n    ++index;\n \n    if (index >= m_count)\n        return NULL;\n \n    CuePoint* const pNext = pp[index];\n    assert(pNext);\n    assert(pNext->GetTimeCode() >= 0);\n #endif\n \n    return pNext;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void usage_exit() {\n   fprintf(stderr, \"Usage: %s <width> <height> <infile> <outfile> <frame>\\n\",\n           exec_name);\n   exit(EXIT_FAILURE);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"int Chapters::GetEditionCount() const\n{\n    return m_editions_count;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  uint8_t* output() const {\n     return output_ + BorderTop() * kOuterBlockSize + BorderLeft();\n   }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"attr_count (void)\n{\n  return attrhash->count;\n}\n","project":"savannah","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_encrypt)\n{\n\tzend_bool raw_output = 0;\n\tchar *data, *method, *password, *iv = \"\";\n\tint data_len, method_len, password_len, iv_len = 0, max_iv_len;\n\tconst EVP_CIPHER *cipher_type;\n\tEVP_CIPHER_CTX cipher_ctx;\n\tint i = 0, outlen, keylen;\n\tunsigned char *outbuf, *key;\n\tzend_bool free_iv;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sss|bs\", &data, &data_len, &method, &method_len, &password, &password_len, &raw_output, &iv, &iv_len) == FAILURE) {\n\t\treturn;\n\t}\n\tcipher_type = EVP_get_cipherbyname(method);\n\tif (!cipher_type) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tkeylen = EVP_CIPHER_key_length(cipher_type);\n\tif (keylen > password_len) {\n\t\tkey = emalloc(keylen);\n\t\tmemset(key, 0, keylen);\n\t\tmemcpy(key, password, password_len);\n\t} else {\n\t\tkey = (unsigned char*)password;\n\t}\n\n\tmax_iv_len = EVP_CIPHER_iv_length(cipher_type);\n\tif (iv_len <= 0 && max_iv_len > 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Using an empty Initialization Vector (iv) is potentially insecure and not recommended\");\n\t}\n\tfree_iv = php_openssl_validate_iv(&iv, &iv_len, max_iv_len TSRMLS_CC);\n\n\toutlen = data_len + EVP_CIPHER_block_size(cipher_type);\n\toutbuf = emalloc(outlen + 1);\n\n\tEVP_EncryptInit(&cipher_ctx, cipher_type, NULL, NULL);\n\tif (password_len > keylen) {\n\t\tEVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len);\n\t}\n\tEVP_EncryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);\n\tif (data_len > 0) {\n\t\tEVP_EncryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);\n\t}\n\toutlen = i;\n\tif (EVP_EncryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {\n\t\toutlen += i;\n\t\tif (raw_output) {\n\t\t\toutbuf[outlen] = '\\0';\n\t\t\tRETVAL_STRINGL((char *)outbuf, outlen, 0);\n\t\t} else {\n\t\t\tint base64_str_len;\n\t\t\tchar *base64_str;\n\n\t\t\tbase64_str = (char*)php_base64_encode(outbuf, outlen, &base64_str_len);\n\t\t\tefree(outbuf);\n\t\t\tRETVAL_STRINGL(base64_str, base64_str_len, 0);\n\t\t}\n\t} else {\n\t\tefree(outbuf);\n\t\tRETVAL_FALSE;\n\t}\n\tif (key != (unsigned char*)password) {\n\t\tefree(key);\n\t}\n\tif (free_iv) {\n\t\tefree(iv);\n\t}\n\tEVP_CIPHER_CTX_cleanup(&cipher_ctx);\n}\n","project":"php","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_finish (void)\n{\n  hash_free (cluster_hash);\n  cluster_hash = NULL;\n}\n","project":"savannah","target":0},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_Tc(fz_context *ctx, pdf_processor *proc, float charspace)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tgstate->text.char_space = charspace;\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"cmyk2rgb(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n#ifdef SLOWCMYK\n\tcmyk_to_rgb(ctx, NULL, sv, dv);\n#else\n\tdv[0] = 1 - fz_min(sv[0] + sv[3], 1);\n\tdv[1] = 1 - fz_min(sv[1] + sv[3], 1);\n\tdv[2] = 1 - fz_min(sv[2] + sv[3], 1);\n#endif\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static X509_REQ * php_openssl_csr_from_zval(zval ** val, int makeresource, long * resourceval TSRMLS_DC)\n{\n\tX509_REQ * csr = NULL;\n\tchar * filename = NULL;\n\tBIO * in;\n\t\n\tif (resourceval) {\n\t\t*resourceval = -1;\n\t}\n\tif (Z_TYPE_PP(val) == IS_RESOURCE) {\n\t\tvoid * what;\n\t\tint type;\n\n\t\twhat = zend_fetch_resource(val TSRMLS_CC, -1, \"OpenSSL X.509 CSR\", &type, 1, le_csr);\n\t\tif (what) {\n\t\t\tif (resourceval) {\n\t\t\t\t*resourceval = Z_LVAL_PP(val);\n\t\t\t}\n\t\t\treturn (X509_REQ*)what;\n\t\t}\n\t\treturn NULL;\n\t} else if (Z_TYPE_PP(val) != IS_STRING) {\n\t\treturn NULL;\n\t}\n\n\tif (Z_STRLEN_PP(val) > 7 && memcmp(Z_STRVAL_PP(val), \"file:\/\/\", sizeof(\"file:\/\/\") - 1) == 0) {\n\t\tfilename = Z_STRVAL_PP(val) + (sizeof(\"file:\/\/\") - 1);\n\t}\n\tif (filename) {\n\t\tif (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tin = BIO_new_file(filename, \"r\");\n\t} else {\n\t\tin = BIO_new_mem_buf(Z_STRVAL_PP(val), Z_STRLEN_PP(val));\n\t}\n\tcsr = PEM_read_bio_X509_REQ(in, NULL,NULL,NULL);\n\tBIO_free(in);\n\n\treturn csr;\n}\n","project":"php","target":0},{"commit_id":"ca8ac8acdad662230ae37998c6c4091bb39402b6","func":"static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kNGroupsOffset = 12;\n const size_t kFirstGroupOffset = 16;\n const size_t kGroupSize = 12;\n const size_t kStartCharCodeOffset = 0;\n const size_t kEndCharCodeOffset = 4;\n const size_t kMaxNGroups = 0xfffffff0 \/ kGroupSize; \/\/ protection against overflow\n if (kFirstGroupOffset > size) {\n return false;\n }\n uint32_t nGroups = readU32(data, kNGroupsOffset);\n if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {\n return false;\n }\n for (uint32_t i = 0; i < nGroups; i++) {\n\n         uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n         uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n         uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n         addRange(coverage, start, end + 1);  \/\/ file is inclusive, vector is exclusive\n     }\n     return true;\n}\n","project":"Android","target":1},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"count_node_types(cmap_splay *node, void *arg)\n{\n\tint *counts = (int *)arg;\n\n\tif (node->many)\n\t\tcounts[2]++;\n\telse if (node->low <= 0xffff && node->high <= 0xFFFF && node->out <= 0xFFFF)\n\t\tcounts[0]++;\n\telse\n\t\tcounts[1]++;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::ParseBlockGroup(\n    long long payload_size,\n    long long& pos,\n    long& len)\n{\n    const long long payload_start = pos;\n    const long long payload_stop = pos + payload_size;\n \n    IMkvReader* const pReader = m_pSegment->m_pReader;\n \n    long long total, avail;\n \n    long status = pReader->Length(&total, &avail);\n \n    if (status < 0)  \/\/error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    if ((total >= 0) && (payload_stop > total))\n        return E_FILE_FORMAT_INVALID;\n \n    if (payload_stop > avail)\n    {\n         len = static_cast<long>(payload_size);\n         return E_BUFFER_NOT_FULL;\n     }\n \n    long long discard_padding = 0;\n \n    while (pos < payload_stop)\n    {\n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(pReader, pos, len);\n \n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n \n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n \n        if ((pos + len) > payload_stop)\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long id = ReadUInt(pReader, pos, len);\n \n        if (id < 0) \/\/error\n            return static_cast<long>(id);\n \n        if (id == 0)  \/\/not a value ID\n            return E_FILE_FORMAT_INVALID;\n \n        pos += len;  \/\/consume ID field\n \n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        result = GetUIntLength(pReader, pos, len);\n \n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n \n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n \n        if ((pos + len) > payload_stop)\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long size = ReadUInt(pReader, pos, len);\n \n        if (size < 0)  \/\/error\n            return static_cast<long>(size);\n \n        pos += len;  \/\/consume size field\n \n \n        if (pos > payload_stop)\n            return E_FILE_FORMAT_INVALID;\n \n        if (size == 0)  \/\/weird\n            continue;\n \n        const long long unknown_size = (1LL << (7 * len)) - 1;\n \n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;\n \n        if (id == 0x35A2)  \/\/DiscardPadding\n        {\n            result = GetUIntLength(pReader, pos, len);\n \n            if (result < 0)  \/\/error\n                return static_cast<long>(result);\n \n            status = UnserializeInt(pReader, pos, len, discard_padding);\n \n            if (status < 0)  \/\/error\n                return status;\n        }\n \n        if (id != 0x21)  \/\/sub-part of BlockGroup is not a Block\n        {\n            pos += size;  \/\/consume sub-part of block group\n \n            if (pos > payload_stop)\n                return E_FILE_FORMAT_INVALID;\n \n            continue;\n        }\n \n        const long long block_stop = pos + size;\n \n        if (block_stop > payload_stop)\n            return E_FILE_FORMAT_INVALID;\n \n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        result = GetUIntLength(pReader, pos, len);\n \n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n \n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n        if ((pos + len) > block_stop)\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long track = ReadUInt(pReader, pos, len);\n        if (track < 0) \/\/error\n            return static_cast<long>(track);\n        if (track == 0)\n            return E_FILE_FORMAT_INVALID;\n \n #if 0\n\n const Tracks* const pTracks = m_pSegment->GetTracks();\n        assert(pTracks);\n\n const long tn = static_cast<long>(track);\n\n const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n\n if (pTrack == NULL)\n\n             return E_FILE_FORMAT_INVALID;\n #endif\n \n        pos += len;  \/\/consume track number\n \n        if ((pos + 2) > block_stop)\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + 2) > avail)\n        {\n            len = 2;\n            return E_BUFFER_NOT_FULL;\n        }\n        pos += 2;  \/\/consume timecode\n        if ((pos + 1) > block_stop)\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        unsigned char flags;\n        status = pReader->Read(pos, 1, &flags);\n        if (status < 0)  \/\/error or underflow\n        {\n            len = 1;\n            return status;\n        }\n        ++pos;  \/\/consume flags byte\n        assert(pos <= avail);\n        if (pos >= block_stop)\n            return E_FILE_FORMAT_INVALID;\n        const int lacing = int(flags & 0x06) >> 1;\n        if ((lacing != 0) && (block_stop > avail))\n        {\n            len = static_cast<long>(block_stop - pos);\n            return E_BUFFER_NOT_FULL;\n        }\n        pos = block_stop;  \/\/consume block-part of block group\n        assert(pos <= payload_stop);\n     }\n \n    assert(pos == payload_stop);\n \n    status = CreateBlock(0x20,  \/\/BlockGroup ID\n                         payload_start, payload_size,\n                         discard_padding);\n    if (status != 0)\n        return status;\n \n    m_pos = payload_stop;\n    return 0;  \/\/success\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long VideoTrack::Parse(\n    Segment* pSegment,\n    const Info& info,\n    long long element_start,\n    long long element_size,\n    VideoTrack*& pResult)\n{\n    if (pResult)\n        return -1;\n \n    if (info.type != Track::kVideo)\n        return -1;\n \n    long long width = 0;\n    long long height = 0;\n    double rate = 0.0;\n \n    IMkvReader* const pReader = pSegment->m_pReader;\n \n    const Settings& s = info.settings;\n    assert(s.start >= 0);\n    assert(s.size >= 0);\n \n    long long pos = s.start;\n    assert(pos >= 0);\n \n    const long long stop = pos + s.size;\n \n    while (pos < stop)\n    {\n        long long id, size;\n \n        const long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n \n        if (status < 0)  \/\/error\n            return status;\n \n        if (id == 0x30)  \/\/pixel width\n        {\n            width = UnserializeUInt(pReader, pos, size);\n            if (width <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x3A)  \/\/pixel height\n        {\n            height = UnserializeUInt(pReader, pos, size);\n            if (height <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x0383E3)  \/\/frame rate\n        {\n            const long status = UnserializeFloat(\n                                    pReader,\n                                    pos,\n                                    size,\n                                    rate);\n            if (status < 0)\n                return status;\n            if (rate <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        pos += size;  \/\/consume payload\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    VideoTrack* const pTrack = new (std::nothrow) VideoTrack(pSegment,\n                                                             element_start,\n                                                             element_size);\n    if (pTrack == NULL)\n        return -1;  \/\/generic error\n    const int status = info.Copy(pTrack->m_info);\n    if (status)  \/\/ error\n    {\n        delete pTrack;\n        return status;\n    }\n    pTrack->m_width = width;\n    pTrack->m_height = height;\n    pTrack->m_rate = rate;\n    pResult = pTrack;\n    return 0;  \/\/success\n}\n","project":"Android","target":1},{"commit_id":"e8c62fb484151f76ab88b1d5130f38de24ac8c14","func":" native_handle_t* native_handle_create(int numFds, int numInts)\n {\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n \n     if (h) {\n         h->version = sizeof(native_handle_t);\n         h->numFds = numFds;\n        h->numInts = numInts;\n }\n return h;\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"transit_free (struct transit *transit)\n{\n  if (transit->val)\n    XFREE (MTYPE_TRANSIT_VAL, transit->val);\n  XFREE (MTYPE_TRANSIT, transit);\n}\n","project":"savannah","target":0},{"commit_id":"24d7c408c52143bce7b49de82f3913fd8d1219cf","func":"void WT_Interpolate (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 phaseFrac;\n    EAS_I32 acc0;\n const EAS_SAMPLE *pSamples;\n const EAS_SAMPLE *loopEnd;\n    EAS_I32 samp1;\n    EAS_I32 samp2;\n    EAS_I32 numSamples;\n\n \/* initialize some local variables *\/\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b\/26366256\");\n         return;\n     }\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n\n    loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;\n    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;\n \/*lint -e{713} truncation is OK *\/\n    phaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n\n \/* fetch adjacent samples *\/\n#if defined(_8_BIT_SAMPLES)\n \/*lint -e{701} <avoid multiply for performance>*\/\n    samp1 = pSamples[0] << 8;\n \/*lint -e{701} <avoid multiply for performance>*\/\n    samp2 = pSamples[1] << 8;\n#else\n    samp1 = pSamples[0];\n    samp2 = pSamples[1];\n#endif\n\n while (numSamples--) {\n\n \/* linear interpolation *\/\n        acc0 = samp2 - samp1;\n        acc0 = acc0 * phaseFrac;\n \/*lint -e{704} <avoid divide>*\/\n        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);\n\n \/* save new output sample in buffer *\/\n \/*lint -e{704} <avoid divide>*\/\n *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);\n\n \/* increment phase *\/\n        phaseFrac += phaseInc;\n \/*lint -e{704} <avoid divide>*\/\n        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;\n\n \/* next sample *\/\n if (acc0 > 0) {\n\n \/* advance sample pointer *\/\n            pSamples += acc0;\n            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);\n\n \/* check for loop end *\/\n            acc0 = (EAS_I32) (pSamples - loopEnd);\n if (acc0 >= 0)\n                pSamples = (const EAS_SAMPLE*) pWTVoice->loopStart + acc0;\n\n \/* fetch new samples *\/\n#if defined(_8_BIT_SAMPLES)\n \/*lint -e{701} <avoid multiply for performance>*\/\n            samp1 = pSamples[0] << 8;\n \/*lint -e{701} <avoid multiply for performance>*\/\n            samp2 = pSamples[1] << 8;\n#else\n            samp1 = pSamples[0];\n            samp2 = pSamples[1];\n#endif\n }\n }\n\n \/* save pointer and phase *\/\n    pWTVoice->phaseAccum = (EAS_U32) pSamples;\n    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;\n}\n","project":"Android","target":1},{"commit_id":"918eeaa29d99d257282fafec931b4bda0e3bae12","func":"void SoftHEVC::setDecodeArgs(ivd_video_decode_ip_t *ps_dec_ip,\n         ivd_video_decode_op_t *ps_dec_op,\n         OMX_BUFFERHEADERTYPE *inHeader,\n         OMX_BUFFERHEADERTYPE *outHeader,\n         size_t timeStampIx) {\n     size_t sizeY = outputBufferWidth() * outputBufferHeight();\n     size_t sizeUV;\n    uint8_t *pBuf;\n \n     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);\n     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n\n    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;\n\n \/* When in flush and after EOS with zero byte input,\n     * inHeader is set to zero. Hence check for non-null *\/\n if (inHeader) {\n        ps_dec_ip->u4_ts = timeStampIx;\n        ps_dec_ip->pv_stream_buffer = inHeader->pBuffer\n + inHeader->nOffset;\n        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;\n } else {\n        ps_dec_ip->u4_ts = 0;\n        ps_dec_ip->pv_stream_buffer = NULL;\n\n         ps_dec_ip->u4_num_Bytes = 0;\n     }\n \n    if (outHeader) {\n        pBuf = outHeader->pBuffer;\n    } else {\n        pBuf = mFlushOutBuffer;\n    }\n     sizeUV = sizeY \/ 4;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;\n \n     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;\n     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;\n     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;\n     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;\n    return;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n\n     inv_txfm_ = GET_PARAM(1);\n     version_  = GET_PARAM(2);  \/\/ 0: high precision forward transform\n   }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void usage_exit() {\n   fprintf(stderr, \"Usage: %s <codec> <width> <height> <infile> <outfile>\\n\",\n           exec_name);\n   exit(EXIT_FAILURE);\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static EVP_MD * php_openssl_get_evp_md_from_algo(long algo) { \/* {{{ *\/\n\tEVP_MD *mdtype;\n\n\tswitch (algo) {\n\t\tcase OPENSSL_ALGO_SHA1:\n\t\t\tmdtype = (EVP_MD *) EVP_sha1();\n\t\t\tbreak;\n\t\tcase OPENSSL_ALGO_MD5:\n\t\t\tmdtype = (EVP_MD *) EVP_md5();\n\t\t\tbreak;\n\t\tcase OPENSSL_ALGO_MD4:\n\t\t\tmdtype = (EVP_MD *) EVP_md4();\n\t\t\tbreak;\n#ifdef HAVE_OPENSSL_MD2_H\n\t\tcase OPENSSL_ALGO_MD2:\n\t\t\tmdtype = (EVP_MD *) EVP_md2();\n\t\t\tbreak;\n#endif\n\t\tcase OPENSSL_ALGO_DSS1:\n\t\t\tmdtype = (EVP_MD *) EVP_dss1();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t}\n\treturn mdtype;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunFwdTxfm(const int16_t *in, int16_t *out, int stride) {\n     fwd_txfm_(in, out, stride);\n   }\n","project":"Android","target":1},{"commit_id":"58a6822d7140137ce957c6d2fc20bae1374186c1","func":"void impeg2d_dec_pnb_mb_params(dec_state_t *ps_dec)\n {\n     stream_t *ps_stream = &ps_dec->s_bit_stream;\n     UWORD16 u2_mb_addr_incr;\n    UWORD16 u2_total_len;\n    UWORD16 u2_len;\n    UWORD16 u2_mb_type;\n    UWORD32 u4_next_word;\n const dec_mb_params_t *ps_dec_mb_params;\n if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n {\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n }\n else\n {\n        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);\n\n if(ps_dec->u2_first_mb)\n {\n \/****************************************************************\/\n \/* Section 6.3.17                                               *\/\n \/* The first MB of a slice cannot be skipped                    *\/\n \/* But the mb_addr_incr can be > 1, because at the beginning of *\/\n \/* a slice, it indicates the offset from the last MB in the     *\/\n \/* previous row. Hence for the first slice in a row, the        *\/\n \/* mb_addr_incr needs to be 1.                                  *\/\n \/****************************************************************\/\n \/* MB_x is set to zero whenever MB_y changes.                   *\/\n            ps_dec->u2_mb_x = u2_mb_addr_incr - 1;\n \/* For error resilience *\/\n            ps_dec->u2_mb_x = MIN(ps_dec->u2_mb_x, (ps_dec->u2_num_horiz_mb - 1));\n\n \/****************************************************************\/\n \/* mb_addr_incr is forced to 1 because in this decoder it is used *\/\n \/* more as an indicator of the number of MBs skipped than the   *\/\n \/* as defined by the standard (Section 6.3.17)                  *\/\n \/****************************************************************\/\n            u2_mb_addr_incr = 1;\n            ps_dec->u2_first_mb = 0;\n }\n else\n {\n \/****************************************************************\/\n \/* In MPEG-2, the last MB of the row cannot be skipped and the  *\/\n \/* mb_addr_incr cannot be such that it will take the current MB   *\/\n \/* beyond the current row                                       *\/\n \/* In MPEG-1, the slice could start and end anywhere and is not *\/\n \/* restricted to a row like in MPEG-2. Hence this check should  *\/\n \/* not be done for MPEG-1 streams.                              *\/\n \/****************************************************************\/\n if(ps_dec->u2_is_mpeg2 &&\n ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb))\n {\n                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;\n }\n\n\n            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));\n }\n\n }\n    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);\n \/*-----------------------------------------------------------------------*\/\n \/* MB type                                                               *\/\n \/*-----------------------------------------------------------------------*\/\n {\n        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];\n        u2_len      = BITS(u2_mb_type,15,8);\n        u2_total_len = u2_len;\n        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);\n }\n \/*-----------------------------------------------------------------------*\/\n \/* motion type                                                           *\/\n \/*-----------------------------------------------------------------------*\/\n {\n        WORD32 i4_motion_type = ps_dec->u2_motion_type;\n\n if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)\n {\n            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);\n            u2_total_len += MB_MOTION_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);\n            i4_motion_type     = ps_dec->u2_motion_type;\n\n }\n\n\n if ((u2_mb_type & MB_FORW_OR_BACK) &&\n ((i4_motion_type == 0) ||\n (i4_motion_type == 3) ||\n (i4_motion_type == 4) ||\n (i4_motion_type >= 7)))\n {\n            i4_motion_type = 1;\n }\n\n }\n \/*-----------------------------------------------------------------------*\/\n \/* dct type                                                              *\/\n \/*-----------------------------------------------------------------------*\/\n {\n if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)\n {\n            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);\n            u2_total_len += MB_DCT_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);\n }\n }\n \/*-----------------------------------------------------------------------*\/\n \/* Quant scale code                                                      *\/\n \/*-----------------------------------------------------------------------*\/\n if(u2_mb_type & MB_QUANT)\n {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);\n\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n        u2_total_len += MB_QUANT_SCALE_CODE_LEN;\n }\n    impeg2d_bit_stream_flush(ps_stream,u2_total_len);\n \/*-----------------------------------------------------------------------*\/\n \/* Set the function pointers                                             *\/\n \/*-----------------------------------------------------------------------*\/\n    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);\n\n if(u2_mb_type & MB_BIDRECT)\n {\n        UWORD16 u2_index       = (ps_dec->u2_motion_type);\n\n        ps_dec->u2_prev_intra_mb    = 0;\n\n         ps_dec->e_mb_pred         = BIDIRECT;\n         ps_dec_mb_params = &ps_dec->ps_func_bi_direct[u2_index];\n         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n         ps_dec_mb_params->pf_func_mb_params(ps_dec);\n     }\n     else if(u2_mb_type & MB_FORW_OR_BACK)\n {\n\n        UWORD16 u2_refPic      = !(u2_mb_type & MB_MV_FORW);\n        UWORD16 u2_index       = (ps_dec->u2_motion_type);\n        ps_dec->u2_prev_intra_mb    = 0;\n\n         ps_dec->e_mb_pred         = (e_pred_direction_t)u2_refPic;\n         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[u2_index];\n         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n         ps_dec_mb_params->pf_func_mb_params(ps_dec);\n \n     }\n else if(u2_mb_type & MB_TYPE_INTRA)\n {\n        ps_dec->u2_prev_intra_mb    = 1;\n        impeg2d_dec_intra_mb(ps_dec);\n\n }\n else\n {\n        ps_dec->u2_prev_intra_mb =0;\n        ps_dec->e_mb_pred = FORW;\n        ps_dec->u2_motion_type = 0;\n        impeg2d_dec_0mv_coded_mb(ps_dec);\n }\n\n \/*-----------------------------------------------------------------------*\/\n \/* decode cbp                                                            *\/\n \/*-----------------------------------------------------------------------*\/\n if((u2_mb_type & MB_TYPE_INTRA))\n {\n        ps_dec->u2_cbp  = 0x3f;\n        ps_dec->u2_prev_intra_mb    = 1;\n }\n else\n {\n        ps_dec->u2_prev_intra_mb  = 0;\n        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n if((ps_dec->u2_coded_mb))\n {\n            UWORD16 cbpValue;\n            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];\n            ps_dec->u2_cbp  = cbpValue & 0xFF;\n            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);\n }\n else\n {\n\n             ps_dec->u2_cbp  = 0;\n         }\n     }\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long CuePoint::GetTimeCode() const\n{\n    return m_timecode;\n }\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftVideoDecoderOMXComponent::getConfig(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexConfigCommonOutputCrop:\n\n         {\n             OMX_CONFIG_RECTTYPE *rectParams = (OMX_CONFIG_RECTTYPE *)params;\n \n             if (rectParams->nPortIndex != kOutputPortIndex) {\n                 return OMX_ErrorUndefined;\n             }\n\n            rectParams->nLeft = mCropLeft;\n            rectParams->nTop = mCropTop;\n            rectParams->nWidth = mCropWidth;\n            rectParams->nHeight = mCropHeight;\n\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n","project":"Android","target":1},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAMRNBEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.amrnb\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAMR)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (amrParams->nChannels != 1\n || amrParams->eAMRDTXMode != OMX_AUDIO_AMRDTXModeOff\n || amrParams->eAMRFrameFormat\n != OMX_AUDIO_AMRFrameFormatFSF\n || amrParams->eAMRBandMode < OMX_AUDIO_AMRBandModeNB0\n || amrParams->eAMRBandMode > OMX_AUDIO_AMRBandModeNB7) {\n return OMX_ErrorUndefined;\n }\n\n            mBitRate = amrParams->nBitRate;\n            mMode = amrParams->eAMRBandMode - 1;\n\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (pcmParams->nChannels != 1\n || pcmParams->nSamplingRate != (OMX_U32)kSampleRate) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"24d7c408c52143bce7b49de82f3913fd8d1219cf","func":"void WT_InterpolateMono (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n const EAS_I8 *pLoopEnd;\n const EAS_I8 *pCurrentPhaseInt;\n    EAS_I32 numSamples;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 currentPhaseFrac;\n    EAS_I32 phaseInc;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I8 *pLoopStart;\n\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b\/26366256\");\n         return;\n     }\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n\n \/* calculate gain increment *\/\n    gainIncrement = (pWTIntFrame->gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n    gain = pWTIntFrame->prevGain << 16;\n\n    pCurrentPhaseInt = pWTVoice->pPhaseAccum;\n    currentPhaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->phaseIncrement;\n\n    pLoopStart = pWTVoice->pLoopStart;\n    pLoopEnd = pWTVoice->pLoopEnd + 1;\n\nInterpolationLoop:\n    tmp0 = (EAS_I32)(pCurrentPhaseInt - pLoopEnd);\n if (tmp0 >= 0)\n        pCurrentPhaseInt = pLoopStart + tmp0;\n\n    tmp0 = *pCurrentPhaseInt;\n    tmp1 = *(pCurrentPhaseInt + 1);\n\n    tmp2 = phaseInc + currentPhaseFrac;\n\n    tmp1 = tmp1 - tmp0;\n    tmp1 = tmp1 * currentPhaseFrac;\n\n    tmp1 = tmp0 + (tmp1 >> NUM_EG1_FRAC_BITS);\n\n    pCurrentPhaseInt += (tmp2 >> NUM_PHASE_FRAC_BITS);\n    currentPhaseFrac = tmp2 & PHASE_FRAC_MASK;\n\n    gain += gainIncrement;\n    tmp2 = (gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n\n    tmp0 = *pMixBuffer;\n    tmp2 = tmp1 * tmp2;\n    tmp2 = (tmp2 >> 9);\n    tmp0 = tmp2 + tmp0;\n *pMixBuffer++ = tmp0;\n\n    numSamples--;\n if (numSamples > 0)\n goto InterpolationLoop;\n\n    pWTVoice->pPhaseAccum = pCurrentPhaseInt;\n    pWTVoice->phaseFrac = currentPhaseFrac;\n \/*lint -e{702} <avoid divide>*\/\n    pWTVoice->gain = (EAS_I16)(gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Chapters::Atom* Chapters::Edition::GetAtom(int index) const\n{\n    if (index < 0)\n        return NULL;\n \n    if (index >= m_atoms_count)\n        return NULL;\n \n    return m_atoms + index;\n }\n","project":"Android","target":1},{"commit_id":"ca8ac8acdad662230ae37998c6c4091bb39402b6","func":" static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n     const size_t kSegCountOffset = 6;\n     const size_t kEndCountOffset = 14;\n const size_t kHeaderSize = 16;\n const size_t kSegmentSize = 8; \/\/ total size of array elements for one segment\n if (kEndCountOffset > size) {\n return false;\n }\n size_t segCount = readU16(data, kSegCountOffset) >> 1;\n if (kHeaderSize + segCount * kSegmentSize > size) {\n\n         return false;\n     }\n     for (size_t i = 0; i < segCount; i++) {\n        int end = readU16(data, kEndCountOffset + 2 * i);\n        int start = readU16(data, kHeaderSize + 2 * (segCount + i));\n        int rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));\n         if (rangeOffset == 0) {\n            int delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));\n             if (((end + delta) & 0xffff) > end - start) {\n                 addRange(coverage, start, end + 1);\n             } else {\n                for (int j = start; j < end + 1; j++) {\n                     if (((j + delta) & 0xffff) != 0) {\n                         addRange(coverage, j, j + 1);\n                     }\n                 }\n             }\n         } else {\n            for (int j = start; j < end + 1; j++) {\n                 uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset +\n                     (i + j - start) * 2;\n                 if (actualRangeOffset + 2 > size) {\n                     return false;\n                 }\n                int glyphId = readU16(data, actualRangeOffset);\n                 if (glyphId != 0) {\n                     addRange(coverage, j, j + 1);\n                 }\n }\n }\n }\n return true;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const SeekHead* Segment::GetSeekHead() const\n{\n    return m_pSeekHead;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_indexed(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->type == FZ_COLORSPACE_INDEXED);\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static void openssl_add_method_or_alias(const OBJ_NAME *name, void *arg) \/* {{{ *\/\n{\n\tadd_next_index_string((zval*)arg, (char*)name->name, 1);\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int php_openssl_load_rand_file(const char * file, int *egdsocket, int *seeded) \/* {{{ *\/\n{\n\tchar buffer[MAXPATHLEN];\n\n\tTSRMLS_FETCH();\n\n\t*egdsocket = 0;\n\t*seeded = 0;\n\n\tif (file == NULL) {\n\t\tfile = RAND_file_name(buffer, sizeof(buffer));\n\t} else if (RAND_egd(file) > 0) {\n\t\t\/* if the given filename is an EGD socket, don't\n\t\t * write anything back to it *\/\n\t\t*egdsocket = 1;\n\t\treturn SUCCESS;\n\t}\n\tif (file == NULL || !RAND_load_file(file, -1)) {\n\t\tif (RAND_status() == 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"unable to load random state; not enough random data!\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\treturn FAILURE;\n\t}\n\t*seeded = 1;\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" void VarianceTest<VarianceFunctionType>::RefTest() {\n   for (int i = 0; i < 10; ++i) {\n     for (int j = 0; j < block_size_; j++) {\n      src_[j] = rnd.Rand8();\n      ref_[j] = rnd.Rand8();\n     }\n     unsigned int sse1, sse2;\n     unsigned int var1;\n    REGISTER_STATE_CHECK(var1 = variance_(src_, width_, ref_, width_, &sse1));\n     const unsigned int var2 = variance_ref(src_, ref_, log2width_,\n                                           log2height_, &sse2);\n     EXPECT_EQ(sse1, sse2);\n     EXPECT_EQ(var1, var2);\n   }\n}\n","project":"Android","target":1},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_prim_group_set(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t rid;\n\n\trid = ldb_msg_find_attr_as_uint(ac->msg, \"primaryGroupID\", (uint32_t) -1);\n\tif (rid == (uint32_t) -1) {\n\t\t\/* we aren't affected of any primary group set *\/\n\t\treturn LDB_SUCCESS;\n\n\t} else if (!ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"The primary group isn't settable on add operations!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\treturn samldb_prim_group_tester(ac, rid);\n}\n","project":"samba","target":0},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"ftp_do_port (int csock, int *local_sock)\n{\n  uerr_t err;\n  ip_address cip;\n\n  if (!socket_ip_address (csock, &cip, ENDPOINT_PEER))\n    abort ();\n\n  \/* If our control connection is over IPv6, then we first try EPRT and then\n   * LPRT if the former is not supported. If the control connection is over\n   * IPv4, we simply issue the good old PORT request. *\/\n  switch (cip.family)\n    {\n    case AF_INET:\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, \"==> PORT ... \");\n      err = ftp_port (csock, local_sock);\n      break;\n    case AF_INET6:\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, \"==> EPRT ... \");\n      err = ftp_eprt (csock, local_sock);\n\n      \/* If EPRT is not supported try LPRT *\/\n      if (err == FTPPORTERR)\n        {\n          if (!opt.server_response)\n            logputs (LOG_VERBOSE, \"==> LPRT ... \");\n          err = ftp_lprt (csock, local_sock);\n        }\n      break;\n    default:\n      abort ();\n    }\n  return err;\n}\n","project":"savannah","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"static void encode_frame(vpx_codec_ctx_t *ctx,\n                         const vpx_image_t *img,\n                         vpx_codec_pts_t pts,\n                         unsigned int duration,\n                         vpx_enc_frame_flags_t flags,\n                         unsigned int deadline,\n                         VpxVideoWriter *writer) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,\n                                               deadline);\n if (res != VPX_CODEC_OK)\n\n     die_codec(ctx, \"Failed to encode frame.\");\n \n   while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {\n       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;\n \n if (!vpx_video_writer_write_frame(writer, pkt->data.frame.buf,\n                                                pkt->data.frame.sz,\n                                                pkt->data.frame.pts))\n        die_codec(ctx, \"Failed to write compressed frame.\");\n      printf(keyframe ? \"K\" : \".\");\n\n       fflush(stdout);\n     }\n   }\n }\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_dump_routes_attr (struct stream *s, struct attr *attr, \n                      struct prefix *prefix)\n{\n  unsigned long cp;\n  unsigned long len;\n  size_t aspath_lenp;\n  struct aspath *aspath;\n\n  \/* Remember current pointer. *\/\n  cp = stream_get_endp (s);\n\n  \/* Place holder of length. *\/\n  stream_putw (s, 0);\n\n  \/* Origin attribute. *\/\n  stream_putc (s, BGP_ATTR_FLAG_TRANS);\n  stream_putc (s, BGP_ATTR_ORIGIN);\n  stream_putc (s, 1);\n  stream_putc (s, attr->origin);\n\n  aspath = attr->aspath;\n  \n  stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);\n  stream_putc (s, BGP_ATTR_AS_PATH);\n  aspath_lenp = stream_get_endp (s);\n  stream_putw (s, 0);\n  \n  stream_putw_at (s, aspath_lenp, aspath_put (s, aspath, 1));\n\n  \/* Nexthop attribute. *\/\n  \/* If it's an IPv6 prefix, don't dump the IPv4 nexthop to save space *\/\n  if(prefix != NULL\n#ifdef HAVE_IPV6\n     && prefix->family != AF_INET6\n#endif \/* HAVE_IPV6 *\/\n     )\n    {\n      stream_putc (s, BGP_ATTR_FLAG_TRANS);\n      stream_putc (s, BGP_ATTR_NEXT_HOP);\n      stream_putc (s, 4);\n      stream_put_ipv4 (s, attr->nexthop.s_addr);\n    }\n\n  \/* MED attribute. *\/\n  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))\n    {\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc (s, BGP_ATTR_MULTI_EXIT_DISC);\n      stream_putc (s, 4);\n      stream_putl (s, attr->med);\n    }\n\n  \/* Local preference. *\/\n  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))\n    {\n      stream_putc (s, BGP_ATTR_FLAG_TRANS);\n      stream_putc (s, BGP_ATTR_LOCAL_PREF);\n      stream_putc (s, 4);\n      stream_putl (s, attr->local_pref);\n    }\n\n  \/* Atomic aggregate. *\/\n  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE))\n    {\n      stream_putc (s, BGP_ATTR_FLAG_TRANS);\n      stream_putc (s, BGP_ATTR_ATOMIC_AGGREGATE);\n      stream_putc (s, 0);\n    }\n\n  \/* Aggregator. *\/\n  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR))\n    {\n      assert (attr->extra);\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);\n      stream_putc (s, BGP_ATTR_AGGREGATOR);\n      stream_putc (s, 8);\n      stream_putl (s, attr->extra->aggregator_as);\n      stream_put_ipv4 (s, attr->extra->aggregator_addr.s_addr);\n    }\n\n  \/* Community attribute. *\/\n  if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES))\n    {\n      if (attr->community->size * 4 > 255)\n\t{\n\t  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);\n\t  stream_putc (s, BGP_ATTR_COMMUNITIES);\n\t  stream_putw (s, attr->community->size * 4);\n\t}\n      else\n\t{\n\t  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);\n\t  stream_putc (s, BGP_ATTR_COMMUNITIES);\n\t  stream_putc (s, attr->community->size * 4);\n\t}\n      stream_put (s, attr->community->val, attr->community->size * 4);\n    }\n\n#ifdef HAVE_IPV6\n  \/* Add a MP_NLRI attribute to dump the IPv6 next hop *\/\n  if (prefix != NULL && prefix->family == AF_INET6 && attr->extra &&\n     (attr->extra->mp_nexthop_len == 16 || attr->extra->mp_nexthop_len == 32) )\n    {\n      int sizep;\n      struct attr_extra *attre = attr->extra;\n      \n      stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc(s, BGP_ATTR_MP_REACH_NLRI);\n      sizep = stream_get_endp (s);\n\n      \/* MP header *\/\n      stream_putc (s, 0);\t\t\/* Marker: Attribute length. *\/\n      stream_putw(s, AFI_IP6);\t\t\/* AFI *\/\n      stream_putc(s, SAFI_UNICAST);\t\/* SAFI *\/\n\n      \/* Next hop *\/\n      stream_putc(s, attre->mp_nexthop_len);\n      stream_put(s, &attre->mp_nexthop_global, 16);\n      if (attre->mp_nexthop_len == 32)\n        stream_put(s, &attre->mp_nexthop_local, 16);\n\n      \/* SNPA *\/\n      stream_putc(s, 0);\n\n      \/* Prefix *\/\n      stream_put_prefix(s, prefix);\n\n      \/* Set MP attribute length. *\/\n      stream_putc_at (s, sizep, (stream_get_endp (s) - sizep) - 1);\n    }\n#endif \/* HAVE_IPV6 *\/\n\n  \/* Return total size of attribute. *\/\n  len = stream_get_endp (s) - cp - 2;\n  stream_putw_at (s, cp, len);\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Cluster* Segment::FindCluster(long long time_ns) const\n{\n    if ((m_clusters == NULL) || (m_clusterCount <= 0))\n        return &m_eos;\n \n    {\n        Cluster* const pCluster = m_clusters[0];\n        assert(pCluster);\n        assert(pCluster->m_index == 0);\n \n        if (time_ns <= pCluster->GetTime())\n            return pCluster;\n    }\n \n \n    long i = 0;\n    long j = m_clusterCount;\n \n    while (i < j)\n    {\n        const long k = i + (j - i) \/ 2;\n        assert(k < m_clusterCount);\n        Cluster* const pCluster = m_clusters[k];\n        assert(pCluster);\n        assert(pCluster->m_index == k);\n        const long long t = pCluster->GetTime();\n        if (t <= time_ns)\n            i = k + 1;\n        else\n            j = k;\n        assert(i <= j);\n    }\n    assert(i == j);\n    assert(i > 0);\n    assert(i <= m_clusterCount);\n    const long k = i - 1;\n \n     Cluster* const pCluster = m_clusters[k];\n     assert(pCluster);\n     assert(pCluster->m_index == k);\n    assert(pCluster->GetTime() <= time_ns);\n \n    return pCluster;\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void SetUp() {\n    full_itxfm_ = GET_PARAM(0);\n    partial_itxfm_ = GET_PARAM(1);\n    tx_size_  = GET_PARAM(2);\n    last_nonzero_ = GET_PARAM(3);\n   }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_clone_default_colorspaces(fz_context *ctx, fz_default_colorspaces *base)\n{\n\tfz_default_colorspaces *default_cs = fz_malloc_struct(ctx, fz_default_colorspaces);\n\tdefault_cs->refs = 1;\n\tdefault_cs->gray = fz_keep_colorspace(ctx, base->gray);\n\tdefault_cs->rgb = fz_keep_colorspace(ctx, base->rgb);\n\tdefault_cs->cmyk = fz_keep_colorspace(ctx, base->cmyk);\n\tdefault_cs->oi = fz_keep_colorspace(ctx, base->oi);\n\treturn default_cs;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Track::GetContentEncodingByIndex(unsigned long idx) const {\n   const ptrdiff_t count =\n       content_encoding_entries_end_ - content_encoding_entries_;\n   assert(count >= 0);\n\n if (idx >= static_cast<unsigned long>(count))\n return NULL;\n\n return content_encoding_entries_[idx];\n}\n","project":"Android","target":1},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"void ssl3_clear(SSL *s)\n\t{\n\tunsigned char *rp,*wp;\n\tsize_t rlen, wlen;\n\tint init_extra;\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tif (s->s3->client_opaque_prf_input != NULL)\n\t\tOPENSSL_free(s->s3->client_opaque_prf_input);\n\ts->s3->client_opaque_prf_input = NULL;\n\tif (s->s3->server_opaque_prf_input != NULL)\n\t\tOPENSSL_free(s->s3->server_opaque_prf_input);\n\ts->s3->server_opaque_prf_input = NULL;\n#endif\n\n\tssl3_cleanup_key_block(s);\n\tif (s->s3->tmp.ca_names != NULL)\n\t\tsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\n\n\tif (s->s3->rrec.comp != NULL)\n\t\t{\n\t\tOPENSSL_free(s->s3->rrec.comp);\n\t\ts->s3->rrec.comp=NULL;\n\t\t}\n#ifndef OPENSSL_NO_DH\n\tif (s->s3->tmp.dh != NULL)\n\t\t{\n\t\tDH_free(s->s3->tmp.dh);\n\t\ts->s3->tmp.dh = NULL;\n\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tif (s->s3->tmp.ecdh != NULL)\n\t\t{\n\t\tEC_KEY_free(s->s3->tmp.ecdh);\n\t\ts->s3->tmp.ecdh = NULL;\n\t\t}\n#endif\n#ifndef OPENSSL_NO_TLSEXT\n#ifndef OPENSSL_NO_EC\n\ts->s3->is_probably_safari = 0;\n#endif \/* !OPENSSL_NO_EC *\/\n#endif \/* !OPENSSL_NO_TLSEXT *\/\n\n\trp = s->s3->rbuf.buf;\n\twp = s->s3->wbuf.buf;\n\trlen = s->s3->rbuf.len;\n \twlen = s->s3->wbuf.len;\n\tinit_extra = s->s3->init_extra;\n\tif (s->s3->handshake_buffer) {\n\t\tBIO_free(s->s3->handshake_buffer);\n\t\ts->s3->handshake_buffer = NULL;\n\t}\n\tif (s->s3->handshake_dgst) {\n\t\tssl3_free_digest_list(s);\n\t}\t\n\tmemset(s->s3,0,sizeof *s->s3);\n\ts->s3->rbuf.buf = rp;\n\ts->s3->wbuf.buf = wp;\n\ts->s3->rbuf.len = rlen;\n \ts->s3->wbuf.len = wlen;\n\ts->s3->init_extra = init_extra;\n\n\tssl_free_wbio_buffer(s);\n\n\ts->packet_length=0;\n\ts->s3->renegotiate=0;\n\ts->s3->total_renegotiations=0;\n\ts->s3->num_renegotiations=0;\n\ts->s3->in_read_app_data=0;\n\ts->version=SSL3_VERSION;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\tif (s->next_proto_negotiated)\n\t\t{\n\t\tOPENSSL_free(s->next_proto_negotiated);\n\t\ts->next_proto_negotiated = NULL;\n\t\ts->next_proto_negotiated_len = 0;\n\t\t}\n#endif\n\t}\n","project":"openssl","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  LosslessTestLarge()\n       : EncoderTest(GET_PARAM(0)),\n         psnr_(kMaxPsnr),\n         nframes_(0),\n         encoding_mode_(GET_PARAM(1)) {\n   }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void filter_average_block2d_8_c(const uint8_t *src_ptr,\n const unsigned int src_stride,\n const int16_t *HFilter,\n const int16_t *VFilter,\n uint8_t *dst_ptr,\n\n                                 unsigned int dst_stride,\n                                 unsigned int output_width,\n                                 unsigned int output_height) {\n  uint8_t tmp[64 * 64];\n \n  assert(output_width <= 64);\n  assert(output_height <= 64);\n   filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter, tmp, 64,\n                      output_width, output_height);\n   block2d_average_c(tmp, 64, dst_ptr, dst_stride,\n                     output_width, output_height);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Chapters::Atom::GetTime(\n    const Chapters* pChapters,\n    long long timecode)\n{\n    if (pChapters == NULL)\n        return -1;\n    Segment* const pSegment = pChapters->m_pSegment;\n    if (pSegment == NULL)  \/\/ weird\n        return -1;\n    const SegmentInfo* const pInfo = pSegment->GetInfo();\n    if (pInfo == NULL)\n        return -1;\n    const long long timecode_scale = pInfo->GetTimeCodeScale();\n    if (timecode_scale < 1)  \/\/ weird\n        return -1;\n    if (timecode < 0)\n        return -1;\n    const long long result = timecode_scale * timecode;\n    return result;\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"static size_t phar_dir_read(php_stream *stream, char *buf, size_t count TSRMLS_DC) \/* {{{ *\/\n{\n\tsize_t to_read;\n\tHashTable *data = (HashTable *)stream->abstract;\n\tphar_zstr key;\n\tchar *str_key;\n\tuint keylen;\n\tulong unused;\n\n\tif (FAILURE == zend_hash_has_more_elements(data)) {\n\t\treturn 0;\n\t}\n\n\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(data, &key, &keylen, &unused, 0, NULL)) {\n\t\treturn 0;\n\t}\n\n\tPHAR_STR(key, str_key);\n\tzend_hash_move_forward(data);\n\tto_read = MIN(keylen, count);\n\n\tif (to_read == 0 || count < keylen) {\n\t\tPHAR_STR_FREE(str_key);\n\t\treturn 0;\n\t}\n\n\tmemset(buf, 0, sizeof(php_stream_dirent));\n\tmemcpy(((php_stream_dirent *) buf)->d_name, str_key, to_read);\n\tPHAR_STR_FREE(str_key);\n\t((php_stream_dirent *) buf)->d_name[to_read + 1] = '\\0';\n\n\treturn sizeof(php_stream_dirent);\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_csr_get_public_key)\n{\n\tzval ** zcsr;\n\tzend_bool use_shortnames = 1;\n\tlong csr_resource;\n\n\tX509_REQ * csr;\n\tEVP_PKEY *tpubkey;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z|b\", &zcsr, &use_shortnames) == FAILURE) {\n\t\treturn;\n\t}\n\n\tcsr = php_openssl_csr_from_zval(zcsr, 0, &csr_resource TSRMLS_CC);\n\n\tif (csr == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\ttpubkey=X509_REQ_get_pubkey(csr);\n\tRETVAL_RESOURCE(zend_list_insert(tpubkey, le_key));\n\treturn;\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"cmyk2g(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tfloat c = sv[0] * 0.3f;\n\tfloat m = sv[1] * 0.59f;\n\tfloat y = sv[2] * 0.11f;\n\tdv[0] = 1 - fz_min(c + m + y + sv[3], 1);\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_seal)\n{\n\tzval *pubkeys, **pubkey, *sealdata, *ekeys;\n\tHashTable *pubkeysht;\n\tHashPosition pos;\n\tEVP_PKEY **pkeys;\n\tlong * key_resources;\t\/* so we know what to cleanup *\/\n\tint i, len1, len2, *eksl, nkeys;\n\tunsigned char *buf = NULL, **eks;\n\tchar * data; int data_len;\n\tchar *method =NULL;\n\tint method_len = 0;\n\tconst EVP_CIPHER *cipher;\n\tEVP_CIPHER_CTX ctx;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"szza\/|s\", &data, &data_len, &sealdata, &ekeys, &pubkeys, &method, &method_len) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tpubkeysht = HASH_OF(pubkeys);\n\tnkeys = pubkeysht ? zend_hash_num_elements(pubkeysht) : 0;\n\tif (!nkeys) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Fourth argument to openssl_seal() must be a non-empty array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (method) {\n\t\tcipher = EVP_get_cipherbyname(method);\n\t\tif (!cipher) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm.\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tcipher = EVP_rc4();\n\t}\n\n\tpkeys = safe_emalloc(nkeys, sizeof(*pkeys), 0);\n\teksl = safe_emalloc(nkeys, sizeof(*eksl), 0);\n\teks = safe_emalloc(nkeys, sizeof(*eks), 0);\n\tmemset(eks, 0, sizeof(*eks) * nkeys);\n\tkey_resources = safe_emalloc(nkeys, sizeof(long), 0);\n\tmemset(key_resources, 0, sizeof(*key_resources) * nkeys);\n\n\t\/* get the public keys we are using to seal this data *\/\n\tzend_hash_internal_pointer_reset_ex(pubkeysht, &pos);\n\ti = 0;\n\twhile (zend_hash_get_current_data_ex(pubkeysht, (void **) &pubkey,\n\t\t\t\t&pos) == SUCCESS) {\n\t\tpkeys[i] = php_openssl_evp_from_zval(pubkey, 1, NULL, 0, &key_resources[i] TSRMLS_CC);\n\t\tif (pkeys[i] == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"not a public key (%dth member of pubkeys)\", i+1);\n\t\t\tRETVAL_FALSE;\n\t\t\tgoto clean_exit;\n\t\t}\n\t\teks[i] = emalloc(EVP_PKEY_size(pkeys[i]) + 1);\n\t\tzend_hash_move_forward_ex(pubkeysht, &pos);\n\t\ti++;\n\t}\n\n\tif (!EVP_EncryptInit(&ctx,cipher,NULL,NULL)) {\n\t\tRETVAL_FALSE;\n\t\tgoto clean_exit;\n\t}\n\n#if 0\n\t\/* Need this if allow ciphers that require initialization vector *\/\n\tivlen = EVP_CIPHER_CTX_iv_length(&ctx);\n\tiv = ivlen ? emalloc(ivlen + 1) : NULL;\n#endif\n\t\/* allocate one byte extra to make room for \\0 *\/\n\tbuf = emalloc(data_len + EVP_CIPHER_CTX_block_size(&ctx));\n\n\tif (!EVP_SealInit(&ctx, cipher, eks, eksl, NULL, pkeys, nkeys) || !EVP_SealUpdate(&ctx, buf, &len1, (unsigned char *)data, data_len)) {\n\t\tRETVAL_FALSE;\n\t\tefree(buf);\n\t\tgoto clean_exit;\n\t}\n\n\tEVP_SealFinal(&ctx, buf + len1, &len2);\n\n\tif (len1 + len2 > 0) {\n\t\tzval_dtor(sealdata);\n\t\tbuf[len1 + len2] = '\\0';\n\t\tbuf = erealloc(buf, len1 + len2 + 1);\n\t\tZVAL_STRINGL(sealdata, (char *)buf, len1 + len2, 0);\n\n\t\tzval_dtor(ekeys);\n\t\tarray_init(ekeys);\n\t\tfor (i=0; i<nkeys; i++) {\n\t\t\teks[i][eksl[i]] = '\\0';\n\t\t\tadd_next_index_stringl(ekeys, erealloc(eks[i], eksl[i] + 1), eksl[i], 0);\n\t\t\teks[i] = NULL;\n\t\t}\n#if 0\n\t\t\/* If allow ciphers that need IV, we need this *\/\n\t\tzval_dtor(*ivec);\n\t\tif (ivlen) {\n\t\t\tiv[ivlen] = '\\0';\n\t\t\tZVAL_STRINGL(*ivec, erealloc(iv, ivlen + 1), ivlen, 0);\n\t\t} else {\n\t\t\tZVAL_EMPTY_STRING(*ivec);\n\t\t}\n#endif\n\t} else {\n\t\tefree(buf);\n\t}\n\tRETVAL_LONG(len1 + len2);\n\nclean_exit:\n\tfor (i=0; i<nkeys; i++) {\n\t\tif (key_resources[i] == -1) {\n\t\t\tEVP_PKEY_free(pkeys[i]);\n\t\t}\n\t\tif (eks[i]) { \n\t\t\tefree(eks[i]);\n\t\t}\n\t}\n\tefree(eks);\n\tefree(eksl);\n\tefree(pkeys);\n\tefree(key_resources);\n}\n","project":"php","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)\n\t{\n\tint ret;\n\t\n\tclear_sys_error();\n\tif (s->s3->renegotiate) ssl3_renegotiate_check(s);\n\ts->s3->in_read_app_data=1;\n\tret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\n\tif ((ret == -1) && (s->s3->in_read_app_data == 2))\n\t\t{\n\t\t\/* ssl3_read_bytes decided to call s->handshake_func, which\n\t\t * called ssl3_read_bytes to read handshake data.\n\t\t * However, ssl3_read_bytes actually found application data\n\t\t * and thinks that application data makes sense here; so disable\n\t\t * handshake processing and try to read application data again. *\/\n\t\ts->in_handshake++;\n\t\tret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\n\t\ts->in_handshake--;\n\t\t}\n\telse\n\t\ts->s3->in_read_app_data=0;\n\n\treturn(ret);\n\t}\n","project":"openssl","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_FUNCTION(preg_replace)\n{\n\tpreg_replace_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"get_base_icc_space(fz_context *ctx, fz_colorspace *srcs)\n{\n\twhile (1)\n\t{\n\t\tsrcs = srcs->get_base(srcs);\n\t\tif (srcs == NULL)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Final color space should be icc or pdf-cal or lab\");\n\n\t\tif (fz_colorspace_is_icc(ctx, srcs) || fz_colorspace_is_cal(ctx, srcs) || fz_colorspace_is_lab(ctx, srcs))\n\t\t\treturn srcs;\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"static void fz_cached_color_convert(fz_context *ctx, fz_color_converter *cc_, float *ds, const float *ss)\n{\n\tfz_cached_color_converter *cc = cc_->opaque;\n\tvoid *val = fz_hash_find(ctx, cc->hash, ss);\n\tint n = cc->base.ds->n * sizeof(float);\n\tfz_color_converter *base_cc = &cc->base;\n\n\tif (val)\n\t{\n\t\tmemcpy(ds, val, n);\n\t\treturn;\n\t}\n\n\tbase_cc->convert(ctx, base_cc, ds, ss);\n\tval = fz_malloc(ctx, n);\n\tmemcpy(val, ds, n);\n\tfz_try(ctx)\n\t{\n\t\tfz_hash_insert(ctx, cc->hash, ss, val);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_free(ctx, val);\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   static void TearDownTestCase() {\n     vpx_free(input_ - 1);\n     input_ = NULL;\n     vpx_free(output_);\n     output_ = NULL;\n   }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"clamp_indexed(const fz_colorspace *cs, const float *in, float *out)\n{\n\tstruct indexed *idx = cs->data;\n\n\t*out = fz_clamp(*in, 0, idx->high) \/ 255.0f; \/* To do, avoid 255 divide *\/\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_keep_cmap(fz_context *ctx, pdf_cmap *cmap)\n{\n\treturn fz_keep_storable(ctx, &cmap->storable);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::Parse(long long& pos, long& len) const\n{\n    long status = Load(pos, len);\n    if (status < 0)\n        return status;\n    assert(m_pos >= m_element_start);\n    assert(m_timecode >= 0);\n    const long long cluster_stop =\n        (m_element_size < 0) ? -1 : m_element_start + m_element_size;\n    if ((cluster_stop >= 0) && (m_pos >= cluster_stop))\n        return 1;  \/\/nothing else to do\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long total, avail;\n    status = pReader->Length(&total, &avail);\n    if (status < 0)  \/\/error\n        return status;\n    assert((total < 0) || (avail <= total));\n    pos = m_pos;\n    for (;;)\n    {\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            break;\n        if ((total >= 0) && (pos >= total))\n        {\n            if (m_element_size < 0)\n                m_element_size = pos - m_element_start;\n            break;\n        }\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0) \/\/error\n            return static_cast<long>(id);\n        if (id == 0)  \/\/weird\n            return E_FILE_FORMAT_INVALID;\n        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) \/\/Cluster or Cues ID\n        {\n            if (m_element_size < 0)\n                m_element_size = pos - m_element_start;\n            break;\n        }\n        pos += len;  \/\/consume ID field\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  \/\/error\n            return static_cast<long>(result);\n        if (result > 0)  \/\/weird\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  \/\/error\n            return static_cast<long>(size);\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;\n        pos += len;  \/\/consume size field\n        if ((cluster_stop >= 0) && (pos > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (size == 0)  \/\/weird\n            continue;\n        const long long block_stop = pos + size;\n        if (cluster_stop >= 0)\n        {\n            if (block_stop > cluster_stop)\n            {\n                if ((id == 0x20) || (id == 0x23))\n                    return E_FILE_FORMAT_INVALID;\n                pos = cluster_stop;\n                break;\n            }\n        }\n        else if ((total >= 0) && (block_stop > total))\n        {\n            m_element_size = total - m_element_start;\n            pos = total;\n            break;\n        }\n        else if (block_stop > avail)\n        {\n            len = static_cast<long>(size);\n            return E_BUFFER_NOT_FULL;\n        }\n        Cluster* const this_ = const_cast<Cluster*>(this);\n        if (id == 0x20)  \/\/BlockGroup\n            return this_->ParseBlockGroup(size, pos, len);\n        if (id == 0x23)  \/\/SimpleBlock\n            return this_->ParseSimpleBlock(size, pos, len);\n        pos += size;  \/\/consume payload\n        assert((cluster_stop < 0) || (pos <= cluster_stop));\n    }\n    assert(m_element_size > 0);\n    m_pos = pos;\n    assert((cluster_stop < 0) || (m_pos <= cluster_stop));\n    if (m_entries_count > 0)\n    {\n        const long idx = m_entries_count - 1;\n        const BlockEntry* const pLast = m_entries[idx];\n        assert(pLast);\n        const Block* const pBlock = pLast->GetBlock();\n        assert(pBlock);\n        const long long start = pBlock->m_start;\n        if ((total >= 0) && (start > total))\n            return -1;  \/\/defend against trucated stream\n        const long long size = pBlock->m_size;\n        const long long stop = start + size;\n        assert((cluster_stop < 0) || (stop <= cluster_stop));\n        if ((total >= 0) && (stop > total))\n            return -1;  \/\/defend against trucated stream\n    }\n    return 1;  \/\/no more entries\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_aspath_check (struct peer *const peer, struct attr *const attr)\n{\n  \/* These checks were part of bgp_attr_aspath, but with\n   * as4 we should to check aspath things when\n   * aspath synthesizing with as4_path has already taken place.\n   * Otherwise we check ASPATH and use the synthesized thing, and that is\n   * not right.\n   * So do the checks later, i.e. here\n   *\/\n  struct bgp *bgp = peer->bgp;\n  struct aspath *aspath;\n\n  bgp = peer->bgp;\n    \n  \/* Confederation sanity check. *\/\n  if ((peer_sort (peer) == BGP_PEER_CONFED && ! aspath_left_confed_check (attr->aspath)) ||\n     (peer_sort (peer) == BGP_PEER_EBGP && aspath_confed_check (attr->aspath)))\n    {\n      zlog (peer->log, LOG_ERR, \"Malformed AS path from %s\", peer->host);\n      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR,\n                       BGP_NOTIFY_UPDATE_MAL_AS_PATH);\n      return BGP_ATTR_PARSE_ERROR;\n    }\n\n  \/* First AS check for EBGP. *\/\n  if (bgp != NULL && bgp_flag_check (bgp, BGP_FLAG_ENFORCE_FIRST_AS))\n    {\n      if (peer_sort (peer) == BGP_PEER_EBGP \n\t  && ! aspath_firstas_check (attr->aspath, peer->as))\n \t{\n \t  zlog (peer->log, LOG_ERR,\n \t\t\"%s incorrect first AS (must be %u)\", peer->host, peer->as);\n          bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR,\n                           BGP_NOTIFY_UPDATE_MAL_AS_PATH);\n          return BGP_ATTR_PARSE_ERROR;\n \t}\n    }\n\n  \/* local-as prepend *\/\n  if (peer->change_local_as &&\n      ! CHECK_FLAG (peer->flags, PEER_FLAG_LOCAL_AS_NO_PREPEND))\n    {\n      aspath = aspath_dup (attr->aspath);\n      aspath = aspath_add_seq (aspath, peer->change_local_as);\n      aspath_unintern (&attr->aspath);\n      attr->aspath = aspath_intern (aspath);\n    }\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Track::GetNext(\n    const BlockEntry* pCurrEntry,\n    const BlockEntry*& pNextEntry) const\n{\n    assert(pCurrEntry);\n    assert(!pCurrEntry->EOS());  \/\/?\n \n    const Block* const pCurrBlock = pCurrEntry->GetBlock();\n    assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);\n    if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)\n        return -1;\n \n    const Cluster* pCluster = pCurrEntry->GetCluster();\n    assert(pCluster);\n    assert(!pCluster->EOS());\n \n    long status = pCluster->GetNext(pCurrEntry, pNextEntry);\n \n    if (status < 0)  \/\/error\n         return status;\n \n    for (int i = 0; ; )\n    {\n        while (pNextEntry)\n        {\n            const Block* const pNextBlock = pNextEntry->GetBlock();\n            assert(pNextBlock);\n \n            if (pNextBlock->GetTrackNumber() == m_info.number)\n                return 0;\n \n            pCurrEntry = pNextEntry;\n \n            status = pCluster->GetNext(pCurrEntry, pNextEntry);\n \n            if (status < 0) \/\/error\n                return status;\n        }\n \n        pCluster = m_pSegment->GetNext(pCluster);\n \n        if (pCluster == NULL)\n        {\n            pNextEntry = GetEOS();\n            return 1;\n        }\n \n        if (pCluster->EOS())\n        {\n #if 0\n             if (m_pSegment->Unparsed() <= 0)   \/\/all clusters have been loaded\n             {\n                pNextEntry = GetEOS();\n\n                 return 1;\n             }\n #else\n            if (m_pSegment->DoneParsing())\n            {\n                pNextEntry = GetEOS();\n                return 1;\n            }\n #endif\n \n \n            pNextEntry = NULL;\n            return E_BUFFER_NOT_FULL;\n        }\n        status = pCluster->GetFirst(pNextEntry);\n        if (status < 0)  \/\/error\n            return status;\n        if (pNextEntry == NULL)  \/\/empty cluster\n            continue;\n        ++i;\n        if (i >= 100)\n            break;\n     }\n \n \n    pNextEntry = GetEOS();  \/\/so we can return a non-NULL value\n    return 1;\n }\n","project":"Android","target":1},{"commit_id":"65c49d5b382de4085ee5668732bcb0f6ecaf7148","func":"long ParseElementHeader(IMkvReader* pReader, long long& pos,\n long long stop, long long& id,\n long long& size) {\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n long len;\n\n  id = ReadID(pReader, pos, len);\n\n if (id < 0)\n return E_FILE_FORMAT_INVALID;\n\n  pos += len; \/\/ consume id\n\n if (stop >= 0 && pos >= stop)\n return E_FILE_FORMAT_INVALID;\n\n  size = ReadUInt(pReader, pos, len);\n\n if (size < 0 || len < 1 || len > 8) {\n return E_FILE_FORMAT_INVALID;\n }\n\n const unsigned long long rollover_check =\n static_cast<unsigned long long>(pos) + len;\n if (rollover_check > LONG_LONG_MAX)\n return E_FILE_FORMAT_INVALID;\n\n  pos += len; \/\/ consume length of size\n\n \n \n  if (stop >= 0 && pos >= stop)\n     return E_FILE_FORMAT_INVALID;\n \n   return 0;  \/\/ success\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_lab(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && cs->type == FZ_COLORSPACE_LAB;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Cluster::GetFirst(const BlockEntry*& pFirst) const\n{\n    if (m_entries_count <= 0)\n    {\n        long long pos;\n        long len;\n        const long status = Parse(pos, len);\n        if (status < 0)  \/\/error\n        {\n            pFirst = NULL;\n            return status;\n        }\n        if (m_entries_count <= 0)  \/\/empty cluster\n        {\n            pFirst = NULL;\n            return 0;\n        }\n    }\n    assert(m_entries);\n    pFirst = m_entries[0];\n    assert(pFirst);\n    return 0;  \/\/success\n}\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_x509_read)\n{\n\tzval **cert;\n\tX509 *x509;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &cert) == FAILURE) {\n\t\treturn;\n\t}\n\tZ_TYPE_P(return_value) = IS_RESOURCE;\n\tx509 = php_openssl_x509_from_zval(cert, 1, &Z_LVAL_P(return_value) TSRMLS_CC);\n\n\tif (x509 == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"supplied parameter cannot be coerced into an X509 certificate!\");\n\t\tRETURN_FALSE;\n\t}\n}\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static EVP_PKEY * php_openssl_generate_private_key(struct php_x509_request * req TSRMLS_DC)\n{\n\tchar * randfile = NULL;\n\tint egdsocket, seeded;\n\tEVP_PKEY * return_val = NULL;\n\t\n\tif (req->priv_key_bits < MIN_KEY_LENGTH) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"private key length is too short; it needs to be at least %d bits, not %d\",\n\t\t\t\tMIN_KEY_LENGTH, req->priv_key_bits);\n\t\treturn NULL;\n\t}\n\n\trandfile = CONF_get_string(req->req_config, req->section_name, \"RANDFILE\");\n\tphp_openssl_load_rand_file(randfile, &egdsocket, &seeded);\n\t\n\tif ((req->priv_key = EVP_PKEY_new()) != NULL) {\n\t\tswitch(req->priv_key_type) {\n\t\t\tcase OPENSSL_KEYTYPE_RSA:\n\t\t\t\tif (EVP_PKEY_assign_RSA(req->priv_key, RSA_generate_key(req->priv_key_bits, 0x10001, NULL, NULL))) {\n\t\t\t\t\treturn_val = req->priv_key;\n\t\t\t\t}\n\t\t\t\tbreak;\n#if !defined(NO_DSA) && defined(HAVE_DSA_DEFAULT_METHOD)\n\t\t\tcase OPENSSL_KEYTYPE_DSA:\n\t\t\t\t{\n\t\t\t\t\tDSA *dsapar = DSA_generate_parameters(req->priv_key_bits, NULL, 0, NULL, NULL, NULL, NULL);\n\t\t\t\t\tif (dsapar) {\n\t\t\t\t\t\tDSA_set_method(dsapar, DSA_get_default_method());\n\t\t\t\t\t\tif (DSA_generate_key(dsapar)) {\n\t\t\t\t\t\t\tif (EVP_PKEY_assign_DSA(req->priv_key, dsapar)) {\n\t\t\t\t\t\t\t\treturn_val = req->priv_key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDSA_free(dsapar);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n#if !defined(NO_DH)\n\t\t\tcase OPENSSL_KEYTYPE_DH:\n\t\t\t\t{\n\t\t\t\t\tDH *dhpar = DH_generate_parameters(req->priv_key_bits, 2, NULL, NULL);\n\t\t\t\t\tint codes = 0;\n\n\t\t\t\t\tif (dhpar) {\n\t\t\t\t\t\tDH_set_method(dhpar, DH_get_default_method());\n\t\t\t\t\t\tif (DH_check(dhpar, &codes) && codes == 0 && DH_generate_key(dhpar)) {\n\t\t\t\t\t\t\tif (EVP_PKEY_assign_DH(req->priv_key, dhpar)) {\n\t\t\t\t\t\t\t\treturn_val = req->priv_key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDH_free(dhpar);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unsupported private key type\");\n\t\t}\n\t}\n\n\tphp_openssl_write_rand_file(randfile, egdsocket, seeded);\n\t\n\tif (return_val == NULL) {\n\t\tEVP_PKEY_free(req->priv_key);\n\t\treq->priv_key = NULL;\n\t\treturn NULL;\n\t}\n\t\n\treturn return_val;\n}\n","project":"php","target":0},{"commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","func":"acl_get_file_mode(const char *path_p)\n{\n\tstruct stat st;\n\n\tif (stat(path_p, &st) != 0)\n\t\treturn NULL;\n\treturn acl_from_mode(st.st_mode);\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"int Chapters::Atom::GetDisplayCount() const\n{\n    return m_displays_count;\n}\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_grestore(fz_context *ctx, pdf_run_processor *pr)\n{\n\tpdf_gstate *gs = pr->gstate + pr->gtop;\n\tint clip_depth = gs->clip_depth;\n\n\tif (pr->gtop <= pr->gbot)\n\t{\n\t\tfz_warn(ctx, \"gstate underflow in content stream\");\n\t\treturn;\n\t}\n\n\tpdf_drop_gstate(ctx, gs);\n\tpr->gtop --;\n\n\tgs = pr->gstate + pr->gtop;\n\twhile (clip_depth > gs->clip_depth)\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\t\/* Silently swallow the problem - restores must\n\t\t\t * never throw! *\/\n\t\t}\n\t\tclip_depth--;\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n     const vpx_rational_t tb = video->timebase();\n     timebase_ = static_cast<double>(tb.num) \/ tb.den;\n     duration_ = 0;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Chapters::Atom::ShallowCopy(Atom& rhs) const\n{\n    rhs.m_string_uid = m_string_uid;\n    rhs.m_uid = m_uid;\n    rhs.m_start_timecode = m_start_timecode;\n    rhs.m_stop_timecode = m_stop_timecode;\n    rhs.m_displays = m_displays;\n    rhs.m_displays_size = m_displays_size;\n    rhs.m_displays_count = m_displays_count;\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static PHP_FUNCTION(preg_match)\n{\n\tphp_do_pcre_match(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n","project":"php","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftAACEncoder2::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            aacParams->nBitRate = mBitRate;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = (OMX_AUDIO_AACPROFILETYPE) mAACProfile;\n            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n            aacParams->nChannels = mNumChannels;\n            aacParams->nSampleRate = mSampleRate;\n            aacParams->nFrameLength = 0;\n\n switch (mSBRMode) {\n case 1: \/\/ sbr on\n switch (mSBRRatio) {\n case 0:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                    ALOGE(\"invalid SBR ratio %d\", mSBRRatio);\n                    TRESPASS();\n }\n break;\n case 0: \/\/ sbr off\n case -1: \/\/ sbr undefined\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                ALOGE(\"invalid SBR mode %d\", mSBRMode);\n                TRESPASS();\n }\n\n\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"BlockGroup::BlockGroup(\n    Cluster* pCluster,\n    long idx,\n    long long block_start,\n    long long block_size,\n    long long prev,\n    long long next,\n    long long duration,\n    long long discard_padding) :\n    BlockEntry(pCluster, idx),\n    m_block(block_start, block_size, discard_padding),\n    m_prev(prev),\n    m_next(next),\n    m_duration(duration)\n{\n}\n","project":"Android","target":1},{"commit_id":"24d7c408c52143bce7b49de82f3913fd8d1219cf","func":" void WT_NoiseGenerator (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n {\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 nInterpolatedSample;\n    EAS_I32 numSamples;\n\n \/* initialize some local variables *\/\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b\/26366256\");\n         return;\n     }\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n\n \/* get last two samples generated *\/\n \/*lint -e{704} <avoid divide for performance>*\/\n    tmp0 = (EAS_I32) (pWTVoice->phaseAccum) >> 18;\n \/*lint -e{704} <avoid divide for performance>*\/\n    tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;\n\n \/* generate a buffer of noise *\/\n while (numSamples--) {\n        nInterpolatedSample = MULT_AUDIO_COEF( tmp0, (PHASE_ONE - pWTVoice->phaseFrac));\n        nInterpolatedSample += MULT_AUDIO_COEF( tmp1, pWTVoice->phaseFrac);\n *pOutputBuffer++ = (EAS_PCM) nInterpolatedSample;\n\n \/* update PRNG *\/\n        pWTVoice->phaseFrac += (EAS_U32) phaseInc;\n if (GET_PHASE_INT_PART(pWTVoice->phaseFrac)) {\n            tmp0 = tmp1;\n            pWTVoice->phaseAccum = pWTVoice->loopEnd;\n            pWTVoice->loopEnd = (5 * pWTVoice->loopEnd + 1);\n            tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;\n            pWTVoice->phaseFrac = GET_PHASE_FRAC_PART(pWTVoice->phaseFrac);\n }\n\n }\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_flags_diagnose (struct bgp_attr_parser_args *args,\n                         u_int8_t desired_flags \/* how RFC says it must be *\/\n)\n{\n  u_char seen = 0, i;\n  u_char real_flags = args->flags;\n  const u_int8_t attr_code = args->type;\n  \n  desired_flags &= ~BGP_ATTR_FLAG_EXTLEN;\n  real_flags &= ~BGP_ATTR_FLAG_EXTLEN;\n  for (i = 0; i <= 2; i++) \/* O,T,P, but not E *\/\n    if\n    (\n      CHECK_FLAG (desired_flags, attr_flag_str[i].key) !=\n      CHECK_FLAG (real_flags,    attr_flag_str[i].key)\n    )\n    {\n      zlog (args->peer->log, LOG_ERR, \"%s attribute must%s be flagged as \\\"%s\\\"\",\n            LOOKUP (attr_str, attr_code),\n            CHECK_FLAG (desired_flags, attr_flag_str[i].key) ? \"\" : \" not\",\n            attr_flag_str[i].str);\n      seen = 1;\n    }\n  if (!seen)\n    {\n      zlog (args->peer->log, LOG_DEBUG,\n            \"Strange, %s called for attr %s, but no problem found with flags\"\n            \" (real flags 0x%x, desired 0x%x)\",\n            __func__, LOOKUP (attr_str, attr_code),\n            real_flags, desired_flags);\n    }\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_drop_colorspace(fz_context *ctx, fz_colorspace *cs)\n{\n\tfz_drop_key_storable(ctx, &cs->key_storable);\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Chapters::Atom::Init()\n{\n    m_string_uid = NULL;\n    m_uid = 0;\n    m_start_timecode = -1;\n    m_stop_timecode = -1;\n    m_displays = NULL;\n    m_displays_size = 0;\n    m_displays_count = 0;\n}\n","project":"Android","target":1},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"static void preg_replace_impl(INTERNAL_FUNCTION_PARAMETERS, int is_callable_replace, int is_filter)\n{\n\tzval\t\t   **regex,\n\t\t\t\t   **replace,\n\t\t\t\t   **subject,\n\t\t\t\t   **subject_entry,\n\t\t\t\t   **zcount = NULL;\n\tchar\t\t\t*result;\n\tint\t\t\t\t result_len;\n\tint\t\t\t\t limit_val = -1;\n\tlong\t\t\tlimit = -1;\n\tchar\t\t\t*string_key;\n\tulong\t\t\t num_key;\n\tchar\t\t\t*callback_name;\n\tint\t\t\t\t replace_count=0, old_replace_count;\n\t\n\t\/* Get function parameters and do error-checking. *\/\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ZZZ|lZ\", &regex, &replace, &subject, &limit, &zcount) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (!is_callable_replace && Z_TYPE_PP(replace) == IS_ARRAY && Z_TYPE_PP(regex) != IS_ARRAY) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Parameter mismatch, pattern is a string while replacement is an array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tSEPARATE_ZVAL(replace);\n\tif (Z_TYPE_PP(replace) != IS_ARRAY && (Z_TYPE_PP(replace) != IS_OBJECT || !is_callable_replace)) {\n\t\tconvert_to_string_ex(replace);\n\t}\n\tif (is_callable_replace) {\n\t\tif (!zend_is_callable(*replace, 0, &callback_name TSRMLS_CC)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Requires argument 2, '%s', to be a valid callback\", callback_name);\n\t\t\tefree(callback_name);\n\t\t\tMAKE_COPY_ZVAL(subject, return_value);\n\t\t\treturn;\n\t\t}\n\t\tefree(callback_name);\n\t}\n\n\tSEPARATE_ZVAL(regex);\n\tSEPARATE_ZVAL(subject);\n\n\tif (ZEND_NUM_ARGS() > 3) {\n\t\tlimit_val = limit;\n\t}\n\t\t\n\tif (Z_TYPE_PP(regex) != IS_ARRAY)\n\t\tconvert_to_string_ex(regex);\n\t\n\t\/* if subject is an array *\/\n\tif (Z_TYPE_PP(subject) == IS_ARRAY) {\n\t\tarray_init(return_value);\n\t\tzend_hash_internal_pointer_reset(Z_ARRVAL_PP(subject));\n\n\t\t\/* For each subject entry, convert it to string, then perform replacement\n\t\t   and add the result to the return_value array. *\/\n\t\twhile (zend_hash_get_current_data(Z_ARRVAL_PP(subject), (void **)&subject_entry) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL(subject_entry);\n\t\t\told_replace_count = replace_count;\n\t\t\tif ((result = php_replace_in_subject(*regex, *replace, subject_entry, &result_len, limit_val, is_callable_replace, &replace_count TSRMLS_CC)) != NULL) {\n\t\t\t\tif (!is_filter || replace_count > old_replace_count) {\n\t\t\t\t\t\/* Add to return array *\/\n\t\t\t\t\tswitch(zend_hash_get_current_key(Z_ARRVAL_PP(subject), &string_key, &num_key, 0))\n\t\t\t\t\t{\n\t\t\t\t\tcase HASH_KEY_IS_STRING:\n\t\t\t\t\t\tadd_assoc_stringl(return_value, string_key, result, result_len, 0);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HASH_KEY_IS_LONG:\n\t\t\t\t\t\tadd_index_stringl(return_value, num_key, result, result_len, 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tefree(result);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tzend_hash_move_forward(Z_ARRVAL_PP(subject));\n\t\t}\n\t} else {\t\/* if subject is not an array *\/\n\t\told_replace_count = replace_count;\n\t\tif ((result = php_replace_in_subject(*regex, *replace, subject, &result_len, limit_val, is_callable_replace, &replace_count TSRMLS_CC)) != NULL) {\n\t\t\tif (!is_filter || replace_count > old_replace_count) {\n\t\t\t\tRETVAL_STRINGL(result, result_len, 0);\n\t\t\t} else {\n\t\t\t\tefree(result);\n\t\t\t}\n\t\t}\n\t}\n\tif (ZEND_NUM_ARGS() > 4) {\n\t\tzval_dtor(*zcount);\n\t\tZVAL_LONG(*zcount, replace_count);\n\t}\n    \t\n}\n","project":"php","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkey_free)\n{\n\tzval *key;\n\tEVP_PKEY *pkey;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &key) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(pkey, EVP_PKEY *, &key, -1, \"OpenSSL key\", le_key);\n\tzend_list_delete(Z_LVAL_P(key));\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"VideoTrack::VideoTrack(\n    Segment* pSegment,\n    long long element_start,\n    long long element_size) :\n    Track(pSegment, element_start, element_size)\n{\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_lookup_rendering_intent(const char *name)\n{\n\tint i;\n\tfor (i = 0; i < nelem(fz_intent_names); i++)\n\t\tif (!strcmp(name, fz_intent_names[i]))\n\t\t\treturn i;\n\treturn FZ_RI_RELATIVE_COLORIMETRIC;\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"BlockEntry::BlockEntry(Cluster* p, long idx) :\n    m_pCluster(p),\n    m_index(idx)\n{\n }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"static void pdf_run_TD(fz_context *ctx, pdf_processor *proc, float tx, float ty)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tgstate->text.leading = -ty;\n\tpdf_tos_translate(&pr->tos, tx, ty);\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" string DecodeFile(const string& filename, int num_threads) {\n   libvpx_test::WebMVideoSource video(filename);\n   video.Init();\n \n  vpx_codec_dec_cfg_t cfg = {0};\n   cfg.threads = num_threads;\n   libvpx_test::VP9Decoder decoder(cfg, 0);\n \n  libvpx_test::MD5 md5;\n for (video.Begin(); video.cxdata(); video.Next()) {\n const vpx_codec_err_t res =\n        decoder.DecodeFrame(video.cxdata(), video.frame_size());\n if (res != VPX_CODEC_OK) {\n      EXPECT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();\n break;\n }\n\n    libvpx_test::DxDataIterator dec_iter = decoder.GetDxData();\n const vpx_image_t *img = NULL;\n\n while ((img = dec_iter.Next())) {\n      md5.Add(img);\n }\n }\n\n   return string(md5.Get());\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Track::GetType() const\n{\n    return m_info.type;\n}\n","project":"Android","target":1},{"commit_id":"630ed150f7201ddadb00b8b8ce0c55c4cc6e8742","func":"bool SoftVPX::outputBuffers(bool flushDecoder, bool display, bool eos, bool *portWillReset) {\n List<BufferInfo *> &outQueue = getPortQueue(1);\n BufferInfo *outInfo = NULL;\n    OMX_BUFFERHEADERTYPE *outHeader = NULL;\n vpx_codec_iter_t iter = NULL;\n\n if (flushDecoder && mFrameParallelMode) {\n if (vpx_codec_decode((vpx_codec_ctx_t *)mCtx, NULL, 0, NULL, 0)) {\n            ALOGE(\"Failed to flush on2 decoder.\");\n return false;\n }\n }\n\n if (!display) {\n if (!flushDecoder) {\n            ALOGE(\"Invalid operation.\");\n return false;\n }\n while ((mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter))) {\n }\n return true;\n }\n\n while (!outQueue.empty()) {\n if (mImg == NULL) {\n            mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter);\n if (mImg == NULL) {\n break;\n }\n }\n uint32_t width = mImg->d_w;\n uint32_t height = mImg->d_h;\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        CHECK_EQ(mImg->fmt, VPX_IMG_FMT_I420);\n        handlePortSettingsChange(portWillReset, width, height);\n if (*portWillReset) {\n return true;\n }\n\n        outHeader->nOffset = 0;\n\n         outHeader->nFlags = 0;\n         outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) \/ 2;\n         outHeader->nTimeStamp = *(OMX_TICKS *)mImg->user_priv;\n        if (outHeader->nAllocLen >= outHeader->nFilledLen) {\n             uint8_t *dst = outHeader->pBuffer;\n             const uint8_t *srcY = (const uint8_t *)mImg->planes[VPX_PLANE_Y];\n             const uint8_t *srcU = (const uint8_t *)mImg->planes[VPX_PLANE_U];\n const uint8_t *srcV = (const uint8_t *)mImg->planes[VPX_PLANE_V];\n size_t srcYStride = mImg->stride[VPX_PLANE_Y];\n size_t srcUStride = mImg->stride[VPX_PLANE_U];\n\n             size_t srcVStride = mImg->stride[VPX_PLANE_V];\n             copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);\n         } else {\n            ALOGE(\"b\/27597103, buffer too small\");\n            android_errorWriteLog(0x534e4554, \"27597103\");\n             outHeader->nFilledLen = 0;\n         }\n \n        mImg = NULL;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n\n if (!eos) {\n return true;\n }\n\n if (!outQueue.empty()) {\n        outInfo = *outQueue.begin();\n        outQueue.erase(outQueue.begin());\n        outHeader = outInfo->mHeader;\n        outHeader->nTimeStamp = 0;\n        outHeader->nFilledLen = 0;\n        outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n        outInfo->mOwnedByUs = false;\n        notifyFillBufferDone(outHeader);\n        mEOSStatus = OUTPUT_FRAMES_FLUSHED;\n }\n\n     return true;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Track::Create(\n    Segment* pSegment,\n    const Info& info,\n    long long element_start,\n    long long element_size,\n    Track*& pResult)\n{\n    if (pResult)\n        return -1;\n \n    Track* const pTrack = new (std::nothrow) Track(pSegment,\n                                                   element_start,\n                                                   element_size);\n \n    if (pTrack == NULL)\n        return -1;  \/\/generic error\n \n    const int status = info.Copy(pTrack->m_info);\n \n    if (status)  \/\/ error\n    {\n        delete pTrack;\n        return status;\n    }\n \n    pResult = pTrack;\n    return 0;  \/\/success\n }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" int main(int argc, char **argv) {\n FILE *infile = NULL;\n vpx_codec_ctx_t codec = {0};\n vpx_codec_enc_cfg_t cfg = {0};\n int frame_count = 0;\n vpx_image_t raw;\n vpx_codec_err_t res;\n VpxVideoInfo info = {0};\n VpxVideoWriter *writer = NULL;\n const VpxInterface *encoder = NULL;\n int update_frame_num = 0;\n const int fps = 30; \/\/ TODO(dkovalev) add command line argument\n const int bitrate = 200; \/\/ kbit\/s TODO(dkovalev) add command line argument\n\n  exec_name = argv[0];\n\n if (argc != 6)\n    die(\"Invalid number of arguments\");\n\n  encoder = get_vpx_encoder_by_name(\"vp8\");\n if (!encoder)\n    die(\"Unsupported codec.\");\n\n  update_frame_num = atoi(argv[5]);\n if (!update_frame_num)\n    die(\"Couldn't parse frame number '%s'\\n\", argv[5]);\n\n  info.codec_fourcc = encoder->fourcc;\n  info.frame_width = strtol(argv[1], NULL, 0);\n  info.frame_height = strtol(argv[2], NULL, 0);\n  info.time_base.numerator = 1;\n  info.time_base.denominator = fps;\n\n if (info.frame_width <= 0 ||\n      info.frame_height <= 0 ||\n (info.frame_width % 2) != 0 ||\n (info.frame_height % 2) != 0) {\n    die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);\n }\n\n if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n                                             info.frame_height, 1)) {\n\n     die(\"Failed to allocate image.\");\n   }\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));\n \n  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \"Failed to get default codec config.\");\n \n  cfg.g_w = info.frame_width;\n  cfg.g_h = info.frame_height;\n  cfg.g_timebase.num = info.time_base.numerator;\n  cfg.g_timebase.den = info.time_base.denominator;\n  cfg.rc_target_bitrate = bitrate;\n\n  writer = vpx_video_writer_open(argv[4], kContainerIVF, &info);\n if (!writer)\n    die(\"Failed to open %s for writing.\", argv[4]);\n\n\n   if (!(infile = fopen(argv[3], \"rb\")))\n     die(\"Failed to open %s for reading.\", argv[3]);\n \n  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n     die_codec(&codec, \"Failed to initialize encoder\");\n \n   while (vpx_img_read(&raw, infile)) {\n     if (frame_count + 1 == update_frame_num) {\n       vpx_ref_frame_t ref;\n      ref.frame_type = VP8_LAST_FRAME;\n      ref.img = raw;\n if (vpx_codec_control(&codec, VP8_SET_REFERENCE, &ref))\n        die_codec(&codec, \"Failed to set reference frame\");\n }\n\n \n     encode_frame(&codec, &raw, frame_count++, writer);\n   }\n  encode_frame(&codec, NULL, -1, writer);\n \n   printf(\"\\n\");\n   fclose(infile);\n  printf(\"Processed %d frames.\\n\", frame_count);\n\n  vpx_img_free(&raw);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_writer_close(writer);\n\n return EXIT_SUCCESS;\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"bgr2cmyk(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tfloat c = 1 - sv[2];\n\tfloat m = 1 - sv[1];\n\tfloat y = 1 - sv[0];\n\tfloat k = fz_min(c, fz_min(m, y));\n\tdv[0] = c - k;\n\tdv[1] = m - k;\n\tdv[2] = y - k;\n\tdv[3] = k;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  unsigned int ReferenceSAD(unsigned int max_sad, int block_idx = 0) {\n     unsigned int sad = 0;\n    const uint8_t* const reference = GetReference(block_idx);\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n        sad += abs(source_data_[h * source_stride_ + w]\n               - reference[h * reference_stride_ + w]);\n      }\n      if (sad > max_sad) {\n        break;\n       }\n     }\n     return sad;\n   }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Cluster* Segment::GetNext(const Cluster* pCurr)\n{\n    assert(pCurr);\n    assert(pCurr != &m_eos);\n    assert(m_clusters);\n \n    long idx =  pCurr->m_index;\n \n    if (idx >= 0)\n    {\n        assert(m_clusterCount > 0);\n        assert(idx < m_clusterCount);\n        assert(pCurr == m_clusters[idx]);\n \n        ++idx;\n        if (idx >= m_clusterCount)\n            return &m_eos;  \/\/caller will LoadCluster as desired\n        Cluster* const pNext = m_clusters[idx];\n        assert(pNext);\n        assert(pNext->m_index >= 0);\n        assert(pNext->m_index == idx);\n        return pNext;\n    }\n    assert(m_clusterPreloadCount > 0);\n    long long pos = pCurr->m_element_start;\n    assert(m_size >= 0);  \/\/TODO\n    const long long stop = m_start + m_size;  \/\/end of segment\n    {\n        long len;\n        long long result = GetUIntLength(m_pReader, pos, len);\n        assert(result == 0);\n        assert((pos + len) <= stop);  \/\/TODO\n        if (result != 0)\n            return NULL;\n        const long long id = ReadUInt(m_pReader, pos, len);\n        assert(id == 0x0F43B675);  \/\/Cluster ID\n        if (id != 0x0F43B675)\n            return NULL;\n        pos += len;  \/\/consume ID\n        result = GetUIntLength(m_pReader, pos, len);\n        assert(result == 0);  \/\/TODO\n        assert((pos + len) <= stop);  \/\/TODO\n        const long long size = ReadUInt(m_pReader, pos, len);\n        assert(size > 0);  \/\/TODO\n        pos += len;  \/\/consume length of size of element\n        assert((pos + size) <= stop);  \/\/TODO\n        pos += size;  \/\/consume payload\n    }\n    long long off_next = 0;\n    while (pos < stop)\n    {\n        long len;\n        long long result = GetUIntLength(m_pReader, pos, len);\n        assert(result == 0);\n        assert((pos + len) <= stop);  \/\/TODO\n        if (result != 0)\n            return NULL;\n        const long long idpos = pos;  \/\/pos of next (potential) cluster\n        const long long id = ReadUInt(m_pReader, idpos, len);\n        assert(id > 0);  \/\/TODO\n        pos += len;  \/\/consume ID\n        result = GetUIntLength(m_pReader, pos, len);\n        assert(result == 0);  \/\/TODO\n        assert((pos + len) <= stop);  \/\/TODO\n        const long long size = ReadUInt(m_pReader, pos, len);\n        assert(size >= 0);  \/\/TODO\n        pos += len;  \/\/consume length of size of element\n        assert((pos + size) <= stop);  \/\/TODO\n        if (size == 0)  \/\/weird\n            continue;\n        if (id == 0x0F43B675)  \/\/Cluster ID\n        {\n            const long long off_next_ = idpos - m_start;\n            long long pos_;\n            long len_;\n            const long status = Cluster::HasBlockEntries(\n                                    this,\n                                    off_next_,\n                                    pos_,\n                                    len_);\n            assert(status >= 0);\n            if (status > 0)\n            {\n                off_next = off_next_;\n                break;\n            }\n        }\n        pos += size;  \/\/consume payload\n    }\n    if (off_next <= 0)\n        return 0;\n    Cluster** const ii = m_clusters + m_clusterCount;\n    Cluster** i = ii;\n    Cluster** const jj = ii + m_clusterPreloadCount;\n    Cluster** j = jj;\n    while (i < j)\n    {\n        Cluster** const k = i + (j - i) \/ 2;\n        assert(k < jj);\n        Cluster* const pNext = *k;\n        assert(pNext);\n        assert(pNext->m_index < 0);\n        pos = pNext->GetPosition();\n        if (pos < off_next)\n            i = k + 1;\n        else if (pos > off_next)\n            j = k;\n        else\n            return pNext;\n    }\n    assert(i == j);\n    Cluster* const pNext = Cluster::Create(this,\n                                          -1,\n                                          off_next);\n     assert(pNext);\n    const ptrdiff_t idx_next = i - m_clusters;  \/\/insertion position\n    PreloadCluster(pNext, idx_next);\n    assert(m_clusters);\n    assert(idx_next < m_clusterSize);\n    assert(m_clusters[idx_next] == pNext);\n \n     return pNext;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Block::GetDiscardPadding() const\n{\n    return m_discard_padding;\n}\n","project":"Android","target":1},{"commit_id":"918eeaa29d99d257282fafec931b4bda0e3bae12","func":"void SoftHEVC::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mSignalledError) {\n return;\n }\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (NULL == mCodecCtx) {\n if (OK != initDecoder()) {\n return;\n }\n }\n if (outputBufferWidth() != mStride) {\n \/* Set the run-time (dynamic) parameters *\/\n        mStride = outputBufferWidth();\n        setParams(mStride);\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n \/* If input EOS is seen and decoder is not in flush mode,\n     * set the decoder in flush mode.\n     * There can be a case where EOS is sent along with last picture data\n     * In that case, only after decoding that input data, decoder has to be\n     * put in flush. This case is handled here  *\/\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL && (inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n            mReceivedEOS = true;\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n                setFlushMode();\n }\n }\n\n \/* Get a free slot in timestamp array to hold input timestamp *\/\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n\n             WORD32 timeDelay, timeTaken;\n             size_t sizeY, sizeUV;\n \n            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n \n             GETTIME(&mTimeStart, NULL);\n             \/* Compute time elapsed between end of previous decode()\n             * to start of current decode() *\/\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n            IV_API_CALL_STATUS_T status;\n            status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n\n bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n\n            GETTIME(&mTimeEnd, NULL);\n \/* Compute time taken for decode() *\/\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            ALOGV(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n \/* If the input did not contain picture data, then ignore\n                 * the associated timestamp *\/\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n                outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) \/ 2;\n\n                outHeader->nTimeStamp = mTimeStamps[s_dec_op.u4_ts];\n                mTimeStampsValid[s_dec_op.u4_ts] = false;\n\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(outQueue.begin());\n                outInfo = NULL;\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n } else {\n \/* If in flush mode and no output is returned by the codec,\n                 * then come out of flush mode *\/\n                mIsInFlush = false;\n\n \/* If EOS was recieved on input port and there is no output\n                 * from the codec, then signal EOS on output port *\/\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}\n","project":"Android","target":1},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"long ssl3_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)\n\t{\n\tCERT *cert;\n\n\tcert=ctx->cert;\n\n\tswitch (cmd)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\tcase SSL_CTRL_NEED_TMP_RSA:\n\t\tif (\t(cert->rsa_tmp == NULL) &&\n\t\t\t((cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\n\t\t\t (EVP_PKEY_size(cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) > (512\/8)))\n\t\t\t)\n\t\t\treturn(1);\n\t\telse\n\t\t\treturn(0);\n\t\t\/* break; *\/\n\tcase SSL_CTRL_SET_TMP_RSA:\n\t\t{\n\t\tRSA *rsa;\n\t\tint i;\n\n\t\trsa=(RSA *)parg;\n\t\ti=1;\n\t\tif (rsa == NULL)\n\t\t\ti=0;\n\t\telse\n\t\t\t{\n\t\t\tif ((rsa=RSAPrivateKey_dup(rsa)) == NULL)\n\t\t\t\ti=0;\n\t\t\t}\n\t\tif (!i)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_RSA_LIB);\n\t\t\treturn(0);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (cert->rsa_tmp != NULL)\n\t\t\t\tRSA_free(cert->rsa_tmp);\n\t\t\tcert->rsa_tmp=rsa;\n\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\t\/* break; *\/\n\tcase SSL_CTRL_SET_TMP_RSA_CB:\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\treturn(0);\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DH\n\tcase SSL_CTRL_SET_TMP_DH:\n\t\t{\n\t\tDH *new=NULL,*dh;\n\n\t\tdh=(DH *)parg;\n\t\tif ((new=DHparams_dup(dh)) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_DH_LIB);\n\t\t\treturn 0;\n\t\t\t}\n\t\tif (!(ctx->options & SSL_OP_SINGLE_DH_USE))\n\t\t\t{\n\t\t\tif (!DH_generate_key(new))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_DH_LIB);\n\t\t\t\tDH_free(new);\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\tif (cert->dh_tmp != NULL)\n\t\t\tDH_free(cert->dh_tmp);\n\t\tcert->dh_tmp=new;\n\t\treturn 1;\n\t\t}\n\t\t\/*break; *\/\n\tcase SSL_CTRL_SET_TMP_DH_CB:\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\treturn(0);\n\t\t}\n\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tcase SSL_CTRL_SET_TMP_ECDH:\n\t\t{\n\t\tEC_KEY *ecdh = NULL;\n \t\t\t\n\t\tif (parg == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_ECDH_LIB);\n\t\t\treturn 0;\n\t\t\t}\n\t\tecdh = EC_KEY_dup((EC_KEY *)parg);\n\t\tif (ecdh == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_EC_LIB);\n\t\t\treturn 0;\n\t\t\t}\n\t\tif (!(ctx->options & SSL_OP_SINGLE_ECDH_USE))\n\t\t\t{\n\t\t\tif (!EC_KEY_generate_key(ecdh))\n\t\t\t\t{\n\t\t\t\tEC_KEY_free(ecdh);\n\t\t\t\tSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_ECDH_LIB);\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif (cert->ecdh_tmp != NULL)\n\t\t\t{\n\t\t\tEC_KEY_free(cert->ecdh_tmp);\n\t\t\t}\n\t\tcert->ecdh_tmp = ecdh;\n\t\treturn 1;\n\t\t}\n\t\t\/* break; *\/\n\tcase SSL_CTRL_SET_TMP_ECDH_CB:\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n\t\treturn(0);\n\t\t}\n\t\tbreak;\n#endif \/* !OPENSSL_NO_ECDH *\/\n#ifndef OPENSSL_NO_TLSEXT\n\tcase SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG:\n\t\tctx->tlsext_servername_arg=parg;\n\t\tbreak;\n\tcase SSL_CTRL_SET_TLSEXT_TICKET_KEYS:\n\tcase SSL_CTRL_GET_TLSEXT_TICKET_KEYS:\n\t\t{\n\t\tunsigned char *keys = parg;\n\t\tif (!keys)\n\t\t\treturn 48;\n\t\tif (larg != 48)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTX_CTRL, SSL_R_INVALID_TICKET_KEYS_LENGTH);\n\t\t\treturn 0;\n\t\t\t}\n\t\tif (cmd == SSL_CTRL_SET_TLSEXT_TICKET_KEYS)\n\t\t\t{\n\t\t\tmemcpy(ctx->tlsext_tick_key_name, keys, 16);\n\t\t\tmemcpy(ctx->tlsext_tick_hmac_key, keys + 16, 16);\n\t\t\tmemcpy(ctx->tlsext_tick_aes_key, keys + 32, 16);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tmemcpy(keys, ctx->tlsext_tick_key_name, 16);\n\t\t\tmemcpy(keys + 16, ctx->tlsext_tick_hmac_key, 16);\n\t\t\tmemcpy(keys + 32, ctx->tlsext_tick_aes_key, 16);\n\t\t\t}\n\t\treturn 1;\n\t\t}\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tcase SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG:\n\t\tctx->tlsext_opaque_prf_input_callback_arg = parg;\n\t\treturn 1;\n#endif\n\n\tcase SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG:\n\t\tctx->tlsext_status_arg=parg;\n\t\treturn 1;\n\t\tbreak;\n\n#ifndef OPENSSL_NO_SRP\n\tcase SSL_CTRL_SET_TLS_EXT_SRP_USERNAME:\n\t\tctx->srp_ctx.srp_Mask|=SSL_kSRP;\n\t\tif (ctx->srp_ctx.login != NULL)\n\t\t\tOPENSSL_free(ctx->srp_ctx.login);\n\t\tctx->srp_ctx.login = NULL;\n\t\tif (parg == NULL)\n\t\t\tbreak;\n\t\tif (strlen((const char *)parg) > 255 || strlen((const char *)parg) < 1)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTX_CTRL, SSL_R_INVALID_SRP_USERNAME);\n\t\t\treturn 0;\n\t\t\t} \n\t\tif ((ctx->srp_ctx.login = BUF_strdup((char *)parg)) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_INTERNAL_ERROR);\n\t\t\treturn 0;\n\t\t\t}\n\t\tbreak;\n\tcase SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD:\n\t\tctx->srp_ctx.SRP_give_srp_client_pwd_callback=srp_password_from_info_cb;\n\t\tctx->srp_ctx.info=parg;\n\t\tbreak;\n\tcase SSL_CTRL_SET_SRP_ARG:\n\t\tctx->srp_ctx.srp_Mask|=SSL_kSRP;\n\t\tctx->srp_ctx.SRP_cb_arg=parg;\n\t\tbreak;\n\n\tcase SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH:\n\t\tctx->srp_ctx.strength=larg;\n\t\tbreak;\n#endif\n#endif \/* !OPENSSL_NO_TLSEXT *\/\n\n\t\/* A Thawte special :-) *\/\n\tcase SSL_CTRL_EXTRA_CHAIN_CERT:\n\t\tif (ctx->extra_certs == NULL)\n\t\t\t{\n\t\t\tif ((ctx->extra_certs=sk_X509_new_null()) == NULL)\n\t\t\t\treturn(0);\n\t\t\t}\n\t\tsk_X509_push(ctx->extra_certs,(X509 *)parg);\n\t\tbreak;\n\n\tcase SSL_CTRL_GET_EXTRA_CHAIN_CERTS:\n\t\t*(STACK_OF(X509) **)parg =  ctx->extra_certs;\n\t\tbreak;\n\n\tcase SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS:\n\t\tif (ctx->extra_certs)\n\t\t\t{\n\t\t\tsk_X509_pop_free(ctx->extra_certs, X509_free);\n\t\t\tctx->extra_certs = NULL;\n\t\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn(0);\n\t\t}\n\treturn(1);\n\t}\n","project":"openssl","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   void RunAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n uint32_t max_error = 0;\n\n     int64_t total_error = 0;\n     const int count_test_block = 10000;\n     for (int i = 0; i < count_test_block; ++i) {\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        test_input_block[j] = src[j] - dst[j];\n       }\n \n      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,\n                                      test_temp_block, pitch_));\n      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n        total_error += error;\n\n       }\n     }\n \n    EXPECT_GE(1u, max_error)\n         << \"Error: 16x16 FHT\/IHT has an individual round trip error > 1\";\n \n    EXPECT_GE(count_test_block , total_error)\n         << \"Error: 16x16 FHT\/IHT has average round trip error > 1 per block\";\n   }\n","project":"Android","target":1},{"commit_id":"0f177948ae2640bfe4d70f8e4248e106406b3b0a","func":" status_t OMXNodeInstance::getParameter(\n         OMX_INDEXTYPE index, void *params, size_t \/* size *\/) {\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_ERRORTYPE err = OMX_GetParameter(mHandle, index, params);\n     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;\n if (err != OMX_ErrorNoMore) {\n        CLOG_IF_ERROR(getParameter, err, \"%s(%#x)\", asString(extIndex), index);\n }\n return StatusFromOMXError(err);\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_get_entry_data(phar_entry_data **ret, char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_archive_data *phar;\n\tphar_entry_info *entry;\n\tint for_write  = mode[0] != 'r' || mode[1] == '+';\n\tint for_append = mode[0] == 'a';\n\tint for_create = mode[0] != 'r';\n\tint for_trunc  = mode[0] == 'w';\n\n\tif (!ret) {\n\t\treturn FAILURE;\n\t}\n\n\t*ret = NULL;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (for_write && PHAR_G(readonly) && !phar->is_data) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for writing, disabled by ini setting\", path, fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (!path_len) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"\\\" in phar \\\"%s\\\" cannot be empty\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\nreally_get_entry:\n\tif (allow_dir) {\n\t\tif ((entry = phar_get_entry_info_dir(phar, path, path_len, allow_dir, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {\n\t\t\tif (for_create && (!PHAR_G(readonly) || phar->is_data)) {\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\tif ((entry = phar_get_entry_info(phar, path, path_len, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {\n\t\t\tif (for_create && (!PHAR_G(readonly) || phar->is_data)) {\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (for_write && phar->is_persistent) {\n\t\tif (FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for writing, could not make cached phar writeable\", path, fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t} else {\n\t\t\tgoto really_get_entry;\n\t\t}\n\t}\n\n\tif (entry->is_modified && !for_write) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for reading, writable file pointers are open\", path, fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->fp_refcount && for_write) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for writing, readable file pointers are open\", path, fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->is_deleted) {\n\t\tif (!for_create) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tentry->is_deleted = 0;\n\t}\n\n\tif (entry->is_dir) {\n\t\t*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));\n\t\t(*ret)->position = 0;\n\t\t(*ret)->fp = NULL;\n\t\t(*ret)->phar = phar;\n\t\t(*ret)->for_write = for_write;\n\t\t(*ret)->internal_file = entry;\n\t\t(*ret)->is_zip = entry->is_zip;\n\t\t(*ret)->is_tar = entry->is_tar;\n\n\t\tif (!phar->is_persistent) {\n\t\t\t++(entry->phar->refcount);\n\t\t\t++(entry->fp_refcount);\n\t\t}\n\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->fp_type == PHAR_MOD) {\n\t\tif (for_trunc) {\n\t\t\tif (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t} else if (for_append) {\n\t\t\tphar_seek_efp(entry, 0, SEEK_END, 0, 0 TSRMLS_CC);\n\t\t}\n\t} else {\n\t\tif (for_write) {\n\t\t\tif (entry->link) {\n\t\t\t\tefree(entry->link);\n\t\t\t\tentry->link = NULL;\n\t\t\t\tentry->tar_type = (entry->is_tar ? TAR_FILE : '\\0');\n\t\t\t}\n\n\t\t\tif (for_trunc) {\n\t\t\t\tif (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (FAILURE == phar_separate_entry_fp(entry, error TSRMLS_CC)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\t*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));\n\t(*ret)->position = 0;\n\t(*ret)->phar = phar;\n\t(*ret)->for_write = for_write;\n\t(*ret)->internal_file = entry;\n\t(*ret)->is_zip = entry->is_zip;\n\t(*ret)->is_tar = entry->is_tar;\n\t(*ret)->fp = phar_get_efp(entry, 1 TSRMLS_CC);\n\tif (entry->link) {\n\t\tphar_entry_info *link = phar_get_link_source(entry TSRMLS_CC);\n\t\tif(!link) {\n\t\t\tefree(*ret);\n\t\t\treturn FAILURE;\n\t\t}\n\t\t(*ret)->zero = phar_get_fp_offset(link TSRMLS_CC);\n\t} else {\n\t\t(*ret)->zero = phar_get_fp_offset(entry TSRMLS_CC);\n\t}\n\n\tif (!phar->is_persistent) {\n\t\t++(entry->fp_refcount);\n\t\t++(entry->phar->refcount);\n\t}\n\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"PHPAPI pcre* pcre_get_compiled_regex(char *regex, pcre_extra **extra, int *preg_options TSRMLS_DC)\n{\n\tpcre_cache_entry * pce = pcre_get_compiled_regex_cache(regex, strlen(regex) TSRMLS_CC);\n\n\tif (extra) {\n\t\t*extra = pce ? pce->extra : NULL;\n\t}\n\tif (preg_options) {\n\t\t*preg_options = pce ? pce->preg_options : 0;\n\t}\n\t\n\treturn pce ? pce->re : NULL;\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void EBMLHeader::Init()\n{\n    m_version = 1;\n    m_readVersion = 1;\n    m_maxIdLength = 4;\n    m_maxSizeLength = 8;\n \n    if (m_docType)\n    {\n        delete[] m_docType;\n        m_docType = NULL;\n    }\n \n    m_docTypeVersion = 1;\n    m_docTypeReadVersion = 1;\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"static int phar_add_empty(HashTable *ht, char *arKey, uint nKeyLength)  \/* {{{ *\/\n{\n\tvoid *dummy = (char *) 1;\n\n\treturn zend_hash_update(ht, arKey, nKeyLength, (void *) &dummy, sizeof(void *), NULL);\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"d72ea85c78a1a68bf99fd5804ad9784b4102fe57","func":"int equalizer_get_parameter(effect_context_t *context, effect_param_t *p,\n uint32_t *size)\n{\n equalizer_context_t *eq_ctxt = (equalizer_context_t *)context;\n int voffset = ((p->psize - 1) \/ sizeof(int32_t) + 1) * sizeof(int32_t);\n int32_t *param_tmp = (int32_t *)p->data;\n int32_t param = *param_tmp++;\n int32_t param2;\n char *name;\n void *value = p->data + voffset;\n int i;\n\n    ALOGV(\"%s\", __func__);\n\n    p->status = 0;\n\n switch (param) {\n case EQ_PARAM_NUM_BANDS:\n case EQ_PARAM_CUR_PRESET:\n case EQ_PARAM_GET_NUM_OF_PRESETS:\n case EQ_PARAM_BAND_LEVEL:\n case EQ_PARAM_GET_BAND:\n if (p->vsize < sizeof(int16_t))\n           p->status = -EINVAL;\n        p->vsize = sizeof(int16_t);\n break;\n\n case EQ_PARAM_LEVEL_RANGE:\n if (p->vsize < 2 * sizeof(int16_t))\n            p->status = -EINVAL;\n        p->vsize = 2 * sizeof(int16_t);\n break;\n case EQ_PARAM_BAND_FREQ_RANGE:\n if (p->vsize < 2 * sizeof(int32_t))\n            p->status = -EINVAL;\n        p->vsize = 2 * sizeof(int32_t);\n break;\n\n case EQ_PARAM_CENTER_FREQ:\n if (p->vsize < sizeof(int32_t))\n            p->status = -EINVAL;\n        p->vsize = sizeof(int32_t);\n break;\n\n case EQ_PARAM_GET_PRESET_NAME:\n break;\n\n case EQ_PARAM_PROPERTIES:\n if (p->vsize < (2 + NUM_EQ_BANDS) * sizeof(uint16_t))\n            p->status = -EINVAL;\n        p->vsize = (2 + NUM_EQ_BANDS) * sizeof(uint16_t);\n break;\n\n default:\n        p->status = -EINVAL;\n }\n\n *size = sizeof(effect_param_t) + voffset + p->vsize;\n\n if (p->status != 0)\n return 0;\n\n switch (param) {\n case EQ_PARAM_NUM_BANDS:\n\tALOGV(\"%s: EQ_PARAM_NUM_BANDS\", __func__);\n *(uint16_t *)value = (uint16_t)NUM_EQ_BANDS;\n break;\n\n case EQ_PARAM_LEVEL_RANGE:\n\tALOGV(\"%s: EQ_PARAM_LEVEL_RANGE\", __func__);\n *(int16_t *)value = -1500;\n *((int16_t *)value + 1) = 1500;\n break;\n\n\n     case EQ_PARAM_BAND_LEVEL:\n \tALOGV(\"%s: EQ_PARAM_BAND_LEVEL\", __func__);\n         param2 = *param_tmp;\n        if (param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n             break;\n         }\n         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);\n break;\n\n\n     case EQ_PARAM_CENTER_FREQ:\n \tALOGV(\"%s: EQ_PARAM_CENTER_FREQ\", __func__);\n         param2 = *param_tmp;\n        if (param2 >= NUM_EQ_BANDS) {\n           p->status = -EINVAL;\n             break;\n         }\n         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);\n break;\n\n\n     case EQ_PARAM_BAND_FREQ_RANGE:\n \tALOGV(\"%s: EQ_PARAM_BAND_FREQ_RANGE\", __func__);\n         param2 = *param_tmp;\n        if (param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n            break;\n         }\n        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,\n ((uint32_t *)value + 1));\n break;\n\n case EQ_PARAM_GET_BAND:\n\tALOGV(\"%s: EQ_PARAM_GET_BAND\", __func__);\n        param2 = *param_tmp;\n *(uint16_t *)value = (uint16_t)equalizer_get_band(eq_ctxt, param2);\n break;\n\n case EQ_PARAM_CUR_PRESET:\n\tALOGV(\"%s: EQ_PARAM_CUR_PRESET\", __func__);\n *(uint16_t *)value = (uint16_t)equalizer_get_preset(eq_ctxt);\n break;\n\n case EQ_PARAM_GET_NUM_OF_PRESETS:\n\tALOGV(\"%s: EQ_PARAM_GET_NUM_OF_PRESETS\", __func__);\n *(uint16_t *)value = (uint16_t)equalizer_get_num_presets(eq_ctxt);\n break;\n\n case EQ_PARAM_GET_PRESET_NAME:\n\tALOGV(\"%s: EQ_PARAM_GET_PRESET_NAME\", __func__);\n        param2 = *param_tmp;\n\tALOGV(\"param2: %d\", param2);\n if (param2 >= equalizer_get_num_presets(eq_ctxt)) {\n            p->status = -EINVAL;\n break;\n }\n        name = (char *)value;\n        strlcpy(name, equalizer_get_preset_name(eq_ctxt, param2), p->vsize - 1);\n        name[p->vsize - 1] = 0;\n        p->vsize = strlen(name) + 1;\n break;\n\n case EQ_PARAM_PROPERTIES: {\n\tALOGV(\"%s: EQ_PARAM_PROPERTIES\", __func__);\n int16_t *prop = (int16_t *)value;\n        prop[0] = (int16_t)equalizer_get_preset(eq_ctxt);\n        prop[1] = (int16_t)NUM_EQ_BANDS;\n for (i = 0; i < NUM_EQ_BANDS; i++) {\n            prop[2 + i] = (int16_t)equalizer_get_band_level(eq_ctxt, i);\n }\n } break;\n\n default:\n        p->status = -EINVAL;\n break;\n }\n\n return 0;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* Track::GetCodecNameAsUTF8() const\n{\n    return m_info.codecNameAsUTF8;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n vpx_codec_err_t res;\n VpxVideoReader *reader = NULL;\n const VpxInterface *decoder = NULL;\n const VpxVideoInfo *info = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 3)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing\", argv[2]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  res = vpx_codec_dec_init(&codec, decoder->interface(), NULL,\n                            VPX_CODEC_USE_POSTPROC);\n   if (res == VPX_CODEC_INCAPABLE)\n     die_codec(&codec, \"Postproc not supported by this decoder.\");\n\n if (res)\n    die_codec(&codec, \"Failed to initialize decoder.\");\n\n while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n\n ++frame_cnt;\n\n if (frame_cnt % 30 == 1) {\n vp8_postproc_cfg_t pp = {0, 0, 0};\n\n if (vpx_codec_control(&codec, VP8_SET_POSTPROC, &pp))\n      die_codec(&codec, \"Failed to turn off postproc.\");\n } else if (frame_cnt % 30 == 16) {\n vp8_postproc_cfg_t pp = {VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE,\n 4, 0};\n if (vpx_codec_control(&codec, VP8_SET_POSTPROC, &pp))\n        die_codec(&codec, \"Failed to turn on postproc.\");\n };\n\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 15000))\n      die_codec(&codec, \"Failed to decode frame\");\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {\n      vpx_img_write(img, outfile);\n }\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec\");\n\n  printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\",\n         info->frame_width, info->frame_height, argv[2]);\n\n  vpx_video_reader_close(reader);\n\n  fclose(outfile);\n return EXIT_SUCCESS;\n}\n","project":"Android","target":1},{"commit_id":"24d7c408c52143bce7b49de82f3913fd8d1219cf","func":"void WT_VoiceGain (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n    EAS_PCM *pInputBuffer;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I32 numSamples;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    EAS_I32 gainLeft, gainRight;\n#endif\n\n \/* initialize some local variables *\/\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b\/26366256\");\n         return;\n     }\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n    pInputBuffer = pWTIntFrame->pAudioBuffer;\n\n \/*lint -e{703} <avoid multiply for performance>*\/\n    gainIncrement = (pWTIntFrame->frame.gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n \/*lint -e{703} <avoid multiply for performance>*\/\n    gain = pWTIntFrame->prevGain << 16;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n    gainLeft = pWTVoice->gainLeft;\n    gainRight = pWTVoice->gainRight;\n#endif\n\n while (numSamples--) {\n\n \/* incremental gain step to prevent zipper noise *\/\n        tmp0 = *pInputBuffer++;\n        gain += gainIncrement;\n \/*lint -e{704} <avoid divide>*\/\n        tmp2 = gain >> 16;\n\n \/* scale sample by gain *\/\n        tmp2 *= tmp0;\n\n\n \/* stereo output *\/\n#if (NUM_OUTPUT_CHANNELS == 2)\n \/*lint -e{704} <avoid divide>*\/\n        tmp2 = tmp2 >> 14;\n\n \/* get the current sample in the final mix buffer *\/\n        tmp1 = *pMixBuffer;\n\n \/* left channel *\/\n        tmp0 = tmp2 * gainLeft;\n \/*lint -e{704} <avoid divide>*\/\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n \/* get the current sample in the final mix buffer *\/\n        tmp1 = *pMixBuffer;\n\n \/* right channel *\/\n        tmp0 = tmp2 * gainRight;\n \/*lint -e{704} <avoid divide>*\/\n        tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS;\n        tmp1 += tmp0;\n *pMixBuffer++ = tmp1;\n\n \/* mono output *\/\n#else\n\n \/* get the current sample in the final mix buffer *\/\n        tmp1 = *pMixBuffer;\n \/*lint -e{704} <avoid divide>*\/\n        tmp2 = tmp2 >> (NUM_MIXER_GUARD_BITS - 1);\n        tmp1 += tmp2;\n *pMixBuffer++ = tmp1;\n#endif\n\n }\n}\n","project":"Android","target":1},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"pdf_map_one_to_many(fz_context *ctx, pdf_cmap *cmap, unsigned int low, int *values, int len)\n{\n\tif (len == 1)\n\t{\n\t\tadd_range(ctx, cmap, low, low, values[0], 1, 0);\n\t\treturn;\n\t}\n\n\t\/* Decode unicode surrogate pairs. *\/\n\t\/* Only the *-UCS2 CMaps use one-to-many mappings, so assuming unicode should be safe. *\/\n\tif (len == 2 &&\n\t\tvalues[0] >= 0xD800 && values[0] <= 0xDBFF &&\n\t\tvalues[1] >= 0xDC00 && values[1] <= 0xDFFF)\n\t{\n\t\tint rune = ((values[0] - 0xD800) << 10) + (values[1] - 0xDC00) + 0x10000;\n\t\tadd_range(ctx, cmap, low, low, rune, 1, 0);\n\t\treturn;\n\t}\n\n\tif (len > PDF_MRANGE_CAP)\n\t{\n\t\tfz_warn(ctx, \"ignoring one to many mapping in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\tadd_mrange(ctx, cmap, low, values, len);\n}\n","project":"ghostscript","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"convert_to_icc_base(fz_context *ctx, fz_colorspace *srcs, float *src_f, float *des_f)\n{\n\tfloat temp_f[FZ_MAX_COLORS];\n\tfz_colorspace *base_cs = srcs->get_base(srcs);\n\n\tif (fz_colorspace_is_icc(ctx, base_cs) || fz_colorspace_is_cal(ctx, base_cs) || fz_colorspace_is_lab(ctx, base_cs))\n\t\tsrcs->to_ccs(ctx, srcs, src_f, des_f);\n\telse\n\t{\n\t\tsrcs->to_ccs(ctx, srcs, src_f, temp_f);\n\t\tconvert_to_icc_base(ctx, base_cs, temp_f, des_f);\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"do_check(cmap_splay *node, void *arg)\n{\n\tcmap_splay *tree = arg;\n\tunsigned int num = node - tree;\n\tassert(!node->many || node->low == node->high);\n\tassert(node->low <= node->high);\n\tassert((node->left == EMPTY) || (tree[node->left].parent == num &&\n\t\ttree[node->left].high < node->low));\n\tassert(node->right == EMPTY || (tree[node->right].parent == num &&\n\t\tnode->high < tree[node->right].low));\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" void Encoder::Flush() {\n   const vpx_codec_err_t res = vpx_codec_encode(&encoder_, NULL, 0, 0, 0,\n                                                deadline_);\n  ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_is_cmyk(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && cs->type == FZ_COLORSPACE_CMYK;\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_atomic (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  \/* Length check. *\/\n  if (length != 0)\n    {\n      zlog (peer->log, LOG_ERR, \"ATOMIC_AGGREGATE attribute length isn't 0 [%u]\",\n            length);\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n\n  \/* Set atomic aggregate flag. *\/\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const char* Chapters::Display::GetCountry() const\n{\n    return m_country;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"static void die_codec(vpx_codec_ctx_t *ctx, const char *s) {\n    const char *detail = vpx_codec_error_detail(ctx);\n    printf(\"%s: %s\\n\", s, vpx_codec_error(ctx));\n    if(detail)\n        printf(\"    %s\\n\",detail);\n    exit(EXIT_FAILURE);\n}\n","project":"Android","target":1},{"commit_id":"03a53d1c7765eeb3af0bc34c3dff02ada1953fbf","func":"void InputDispatcher::enqueueDispatchEntryLocked(\n const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget,\n int32_t dispatchMode) {\n int32_t inputTargetFlags = inputTarget->flags;\n if (!(inputTargetFlags & dispatchMode)) {\n return;\n }\n    inputTargetFlags = (inputTargetFlags & ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;\n\n DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, \/\/ increments ref\n            inputTargetFlags, inputTarget->xOffset, inputTarget->yOffset,\n            inputTarget->scaleFactor);\n\n switch (eventEntry->type) {\n case EventEntry::TYPE_KEY: {\n KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);\n        dispatchEntry->resolvedAction = keyEntry->action;\n        dispatchEntry->resolvedFlags = keyEntry->flags;\n\n if (!connection->inputState.trackKey(keyEntry,\n                dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {\n#if DEBUG_DISPATCH_CYCLE\n            ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent key event\",\n                    connection->getInputChannelName());\n#endif\n delete dispatchEntry;\n return; \/\/ skip the inconsistent event\n }\n break;\n }\n\n case EventEntry::TYPE_MOTION: {\n MotionEntry* motionEntry = static_cast<MotionEntry*>(eventEntry);\n if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;\n } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT;\n } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;\n } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_CANCEL;\n } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_DOWN;\n } else {\n            dispatchEntry->resolvedAction = motionEntry->action;\n }\n if (dispatchEntry->resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE\n && !connection->inputState.isHovering(\n                        motionEntry->deviceId, motionEntry->source, motionEntry->displayId)) {\n#if DEBUG_DISPATCH_CYCLE\n        ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: filling in missing hover enter event\",\n                connection->getInputChannelName());\n#endif\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;\n }\n\n        dispatchEntry->resolvedFlags = motionEntry->flags;\n\n         if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_OBSCURED) {\n             dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;\n         }\n \n         if (!connection->inputState.trackMotion(motionEntry,\n                 dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {\n#if DEBUG_DISPATCH_CYCLE\n            ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent motion event\",\n                    connection->getInputChannelName());\n#endif\n delete dispatchEntry;\n return; \/\/ skip the inconsistent event\n }\n break;\n }\n }\n\n if (dispatchEntry->hasForegroundTarget()) {\n        incrementPendingForegroundDispatchesLocked(eventEntry);\n }\n\n    connection->outboundQueue.enqueueAtTail(dispatchEntry);\n    traceOutboundQueueLengthLocked(connection);\n}\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_create_writeable_entry(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC) \/* {{{ *\/\n{\n\tif (entry->fp_type == PHAR_MOD) {\n\t\t\/* already newly created, truncate *\/\n\t\tphp_stream_truncate_set_size(entry->fp, 0);\n\n\t\tentry->old_flags = entry->flags;\n\t\tentry->is_modified = 1;\n\t\tphar->is_modified = 1;\n\t\t\/* reset file size *\/\n\t\tentry->uncompressed_filesize = 0;\n\t\tentry->compressed_filesize = 0;\n\t\tentry->crc32 = 0;\n\t\tentry->flags = PHAR_ENT_PERM_DEF_FILE;\n\t\tentry->fp_type = PHAR_MOD;\n\t\tentry->offset = 0;\n\t\treturn SUCCESS;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t\/* open a new temp file for writing *\/\n\tif (entry->link) {\n\t\tefree(entry->link);\n\t\tentry->link = NULL;\n\t\tentry->tar_type = (entry->is_tar ? TAR_FILE : '\\0');\n\t}\n\n\tentry->fp = php_stream_fopen_tmpfile();\n\n\tif (!entry->fp) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tentry->old_flags = entry->flags;\n\tentry->is_modified = 1;\n\tphar->is_modified = 1;\n\t\/* reset file size *\/\n\tentry->uncompressed_filesize = 0;\n\tentry->compressed_filesize = 0;\n\tentry->crc32 = 0;\n\tentry->flags = PHAR_ENT_PERM_DEF_FILE;\n\tentry->fp_type = PHAR_MOD;\n\tentry->offset = 0;\n\treturn SUCCESS;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long Segment::ParseHeaders()\n{\n    long long total, available;\n    const int status = m_pReader->Length(&total, &available);\n    if (status < 0) \/\/error\n         return status;\n \n    assert((total < 0) || (available <= total));\n \n    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n    assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));\n    assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n    for (;;)\n    {\n        if ((total >= 0) && (m_pos >= total))\n            break;\n \n        if ((segment_stop >= 0) && (m_pos >= segment_stop))\n            break;\n \n        long long pos = m_pos;\n        const long long element_start = pos;\n \n        if ((pos + 1) > available)\n            return (pos + 1);\n \n        long len;\n        long long result = GetUIntLength(m_pReader, pos, len);\n        if (result < 0)  \/\/error\n            return result;\n        if (result > 0)  \/\/underflow (weird)\n            return (pos + 1);\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > available)\n            return pos + len;\n        const long long idpos = pos;\n        const long long id = ReadUInt(m_pReader, idpos, len);\n        if (id < 0)  \/\/error\n            return id;\n        if (id == 0x0F43B675)  \/\/Cluster ID\n            break;\n        pos += len;  \/\/consume ID\n        if ((pos + 1) > available)\n            return (pos + 1);\n        result = GetUIntLength(m_pReader, pos, len);\n        if (result < 0)  \/\/error\n            return result;\n        if (result > 0)  \/\/underflow (weird)\n            return (pos + 1);\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > available)\n            return pos + len;\n        const long long size = ReadUInt(m_pReader, pos, len);\n        if (size < 0)  \/\/error\n            return size;\n        pos += len;  \/\/consume length of size of element\n        const long long element_size = size + pos - element_start;\n        if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + size) > available)\n            return pos + size;\n        if (id == 0x0549A966)  \/\/Segment Info ID\n        {\n            if (m_pInfo)\n                return E_FILE_FORMAT_INVALID;\n            m_pInfo = new (std::nothrow) SegmentInfo(\n                                          this,\n                                          pos,\n                                          size,\n                                          element_start,\n                                          element_size);\n            if (m_pInfo == NULL)\n                return -1;\n            const long status = m_pInfo->Parse();\n            if (status)\n                return status;\n        }\n        else if (id == 0x0654AE6B)  \/\/Tracks ID\n        {\n            if (m_pTracks)\n                return E_FILE_FORMAT_INVALID;\n            m_pTracks = new (std::nothrow) Tracks(this,\n                                                  pos,\n                                                  size,\n                                                  element_start,\n                                                  element_size);\n            if (m_pTracks == NULL)\n                return -1;\n            const long status = m_pTracks->Parse();\n            if (status)\n                return status;\n        }\n        else if (id == 0x0C53BB6B)  \/\/Cues ID\n        {\n            if (m_pCues == NULL)\n            {\n                m_pCues = new (std::nothrow) Cues(\n                                                this,\n                                                pos,\n                                                size,\n                                                element_start,\n                                                element_size);\n                if (m_pCues == NULL)\n                    return -1;\n            }\n        }\n        else if (id == 0x014D9B74)  \/\/SeekHead ID\n        {\n            if (m_pSeekHead == NULL)\n            {\n                m_pSeekHead = new (std::nothrow) SeekHead(\n                                                    this,\n                                                    pos,\n                                                    size,\n                                                    element_start,\n                                                    element_size);\n                if (m_pSeekHead == NULL)\n                    return -1;\n                const long status = m_pSeekHead->Parse();\n                if (status)\n                    return status;\n            }\n        }\n        else if (id == 0x0043A770)  \/\/Chapters ID\n        {\n            if (m_pChapters == NULL)\n            {\n                m_pChapters = new (std::nothrow) Chapters(\n                                this,\n                                pos,\n                                size,\n                                element_start,\n                                element_size);\n                if (m_pChapters == NULL)\n                  return -1;\n                const long status = m_pChapters->Parse();\n                if (status)\n                  return status;\n            }\n        }\n        m_pos = pos + size;  \/\/consume payload\n     }\n \n    assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n    if (m_pInfo == NULL)  \/\/TODO: liberalize this behavior\n        return E_FILE_FORMAT_INVALID;\n \n    if (m_pTracks == NULL)\n        return E_FILE_FORMAT_INVALID;\n \n    return 0;  \/\/success\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"int Track::Info::CopyStr(char* Info::*str, Info& dst_) const\n{\n    if (str == static_cast<char* Info::*>(NULL))\n        return -1;\n    char*& dst = dst_.*str;\n    if (dst)  \/\/should be NULL already\n        return -1;\n    const char* const src = this->*str;\n    if (src == NULL)\n        return 0;\n    const size_t len = strlen(src);\n    dst = new (std::nothrow) char[len+1];\n    if (dst == NULL)\n        return -1;\n    strcpy(dst, src);\n     return 0;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long AudioTrack::GetBitDepth() const\n{\n    return m_bitDepth;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunInvTxfm(const int16_t *out, uint8_t *dst, int stride) {\n     inv_txfm_(out, dst, stride, tx_type_);\n   }\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"   virtual void SetUp() {\n    const tuple<int, int, VarianceFunctionType>& params = this->GetParam();\n     log2width_  = get<0>(params);\n     width_ = 1 << log2width_;\n     log2height_ = get<1>(params);\n     height_ = 1 << log2height_;\n     variance_ = get<2>(params);\n \n    rnd(ACMRandom::DeterministicSeed());\n     block_size_ = width_ * height_;\n    src_ = new uint8_t[block_size_];\n    ref_ = new uint8_t[block_size_];\n     ASSERT_TRUE(src_ != NULL);\n     ASSERT_TRUE(ref_ != NULL);\n   }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_verify)\n{\n\tzval **key;\n\tEVP_PKEY *pkey;\n\tint err;\n\tEVP_MD_CTX     md_ctx;\n\tconst EVP_MD *mdtype;\n\tlong keyresource = -1;\n\tchar * data;\tint data_len;\n\tchar * signature;\tint signature_len;\n\tzval *method = NULL;\n\tlong signature_algo = OPENSSL_ALGO_SHA1;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ssZ|z\", &data, &data_len, &signature, &signature_len, &key, &method) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (method == NULL || Z_TYPE_P(method) == IS_LONG) {\n\t\tif (method != NULL) {\n\t\t\tsignature_algo = Z_LVAL_P(method);\n\t\t}\n\t\tmdtype = php_openssl_get_evp_md_from_algo(signature_algo);\n\t} else if (Z_TYPE_P(method) == IS_STRING) {\n\t\tmdtype = EVP_get_digestbyname(Z_STRVAL_P(method));\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm.\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!mdtype) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm.\");\n\t\tRETURN_FALSE;\n\t}\n\n\tpkey = php_openssl_evp_from_zval(key, 1, NULL, 0, &keyresource TSRMLS_CC);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"supplied key param cannot be coerced into a public key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tEVP_VerifyInit   (&md_ctx, mdtype);\n\tEVP_VerifyUpdate (&md_ctx, data, data_len);\n\terr = EVP_VerifyFinal (&md_ctx, (unsigned char *)signature, signature_len, pkey);\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\n\tif (keyresource == -1) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tRETURN_LONG(err);\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool SeekHead::ParseEntry(\n    IMkvReader* pReader,\n    long long start,\n    long long size_,\n    Entry* pEntry)\n{\n    if (size_ <= 0)\n        return false;\n \n    long long pos = start;\n    const long long stop = start + size_;\n \n    long len;\n \n \n    const long long seekIdId = ReadUInt(pReader, pos, len);\n \n    if (seekIdId != 0x13AB)  \/\/SeekID ID\n        return false;\n \n    if ((pos + len) > stop)\n        return false;\n \n    pos += len;  \/\/consume SeekID id\n \n    const long long seekIdSize = ReadUInt(pReader, pos, len);\n \n    if (seekIdSize <= 0)\n        return false;\n \n    if ((pos + len) > stop)\n        return false;\n \n    pos += len;  \/\/consume size of field\n \n    if ((pos + seekIdSize) > stop)\n        return false;\n \n \n    pEntry->id = ReadUInt(pReader, pos, len);  \/\/payload\n \n    if (pEntry->id <= 0)\n        return false;\n \n    if (len != seekIdSize)\n        return false;\n \n    pos += seekIdSize;  \/\/consume SeekID payload\n \n    const long long seekPosId = ReadUInt(pReader, pos, len);\n \n    if (seekPosId != 0x13AC)  \/\/SeekPos ID\n        return false;\n \n    if ((pos + len) > stop)\n        return false;\n \n    pos += len;  \/\/consume id\n \n    const long long seekPosSize = ReadUInt(pReader, pos, len);\n \n    if (seekPosSize <= 0)\n        return false;\n \n    if ((pos + len) > stop)\n        return false;\n \n    pos += len;  \/\/consume size\n \n    if ((pos + seekPosSize) > stop)\n        return false;\n \n    pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);\n \n    if (pEntry->pos < 0)\n        return false;\n \n    pos += seekPosSize;  \/\/consume payload\n \n    if (pos != stop)\n        return false;\n \n    return true;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Chapters::Parse()\n{\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long pos = m_start;  \/\/ payload start\n    const long long stop = pos + m_size;  \/\/ payload stop\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  \/\/ error\n            return status;\n        if (size == 0)  \/\/ weird\n            continue;\n        if (id == 0x05B9)  \/\/ EditionEntry ID\n        {\n            status = ParseEdition(pos, size);\n            if (status < 0)  \/\/ error\n                return status;\n        }\n        pos += size;\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n    return 0;\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkey_export)\n{\n\tstruct php_x509_request req;\n\tzval ** zpkey, * args = NULL, *out;\n\tchar * passphrase = NULL; int passphrase_len = 0;\n\tlong key_resource = -1;\n\tEVP_PKEY * key;\n\tBIO * bio_out = NULL;\n\tconst EVP_CIPHER * cipher;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zz|s!a!\", &zpkey, &out, &passphrase, &passphrase_len, &args) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tkey = php_openssl_evp_from_zval(zpkey, 0, passphrase, 0, &key_resource TSRMLS_CC);\n\n\tif (key == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get key from parameter 1\");\n\t\tRETURN_FALSE;\n\t}\n\t\n\tPHP_SSL_REQ_INIT(&req);\n\n\tif (PHP_SSL_REQ_PARSE(&req, args) == SUCCESS) {\n\t\tbio_out = BIO_new(BIO_s_mem());\n\n\t\tif (passphrase && req.priv_key_encrypt) {\n\t\t\tcipher = (EVP_CIPHER *) EVP_des_ede3_cbc();\n\t\t} else {\n\t\t\tcipher = NULL;\n\t\t}\n\t\tif (PEM_write_bio_PrivateKey(bio_out, key, cipher, (unsigned char *)passphrase, passphrase_len, NULL, NULL)) {\n\t\t\t\/* Success!\n\t\t\t * If returning the output as a string, do so now *\/\n\n\t\t\tchar * bio_mem_ptr;\n\t\t\tlong bio_mem_len;\n\t\t\tRETVAL_TRUE;\n\n\t\t\tbio_mem_len = BIO_get_mem_data(bio_out, &bio_mem_ptr);\n\t\t\tzval_dtor(out);\n\t\t\tZVAL_STRINGL(out, bio_mem_ptr, bio_mem_len, 1);\n\t\t}\n\t}\n\tPHP_SSL_REQ_DISPOSE(&req);\n\n\tif (key_resource == -1 && key) {\n\t\tEVP_PKEY_free(key);\n\t}\n\tif (bio_out) {\n\t\tBIO_free(bio_out);\n\t}\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"BlockEntry::Kind SimpleBlock::GetKind() const\n{\n    return kBlockSimple;\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_unintern_sub (struct attr *attr)\n{\n  \/* aspath refcount shoud be decrement. *\/\n  if (attr->aspath)\n    aspath_unintern (&attr->aspath);\n  UNSET_FLAG(attr->flag, BGP_ATTR_AS_PATH);\n  \n  if (attr->community)\n    community_unintern (&attr->community);\n  UNSET_FLAG(attr->flag, BGP_ATTR_COMMUNITIES);\n  \n  if (attr->extra)\n    {\n      if (attr->extra->ecommunity)\n        ecommunity_unintern (&attr->extra->ecommunity);\n      UNSET_FLAG(attr->flag, BGP_ATTR_EXT_COMMUNITIES);\n      \n      if (attr->extra->cluster)\n        cluster_unintern (attr->extra->cluster);\n      UNSET_FLAG(attr->flag, BGP_ATTR_CLUSTER_LIST);\n      \n      if (attr->extra->transit)\n        transit_unintern (attr->extra->transit);\n    }\n}\n","project":"savannah","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Block::Block(long long start, long long size_, long long discard_padding) :\n    m_start(start),\n    m_size(size_),\n    m_track(0),\n    m_timecode(-1),\n    m_flags(0),\n    m_frames(NULL),\n    m_frame_count(-1),\n    m_discard_padding(discard_padding)\n{\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Track::Track(\n    Segment* pSegment,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    content_encoding_entries_(NULL),\n    content_encoding_entries_end_(NULL)\n{\n }\n","project":"Android","target":1},{"commit_id":"4dcc6affe04368461310a21238f7e1871a752a05","func":"pdf_keep_material(fz_context *ctx, pdf_material *mat)\n{\n\tif (mat->colorspace)\n\t\tfz_keep_colorspace(ctx, mat->colorspace);\n\tif (mat->pattern)\n\t\tpdf_keep_pattern(ctx, mat->pattern);\n\tif (mat->shade)\n\t\tfz_keep_shade(ctx, mat->shade);\n\treturn mat;\n}\n","project":"ghostscript","target":0},{"commit_id":"85d253fab5e2c01bd90990667c6de25c282fc5cd","func":" void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n    mCore->dump(result, prefix);\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long long mkvparser::GetUIntLength(\n    IMkvReader* pReader,\n    long long pos,\n    long& len)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    long long total, available;\n \n    int status = pReader->Length(&total, &available);\n    assert(status >= 0);\n    assert((total < 0) || (available <= total));\n \n    len = 1;\n \n    if (pos >= available)\n        return pos;  \/\/too few bytes available\n \n\/\/\/\/ TODO(vigneshv): This function assumes that unsigned values never have their\n\/\/\/\/ high bit set.\n     unsigned char b;\n \n    status = pReader->Read(pos, 1, &b);\n \n     if (status < 0)\n        return status;\n \n    assert(status == 0);\n \n    if (b == 0)  \/\/we can't handle u-int values larger than 8 bytes\n        return E_FILE_FORMAT_INVALID;\n \n    unsigned char m = 0x80;\n    while (!(b & m))\n    {\n        m >>= 1;\n        ++len;\n    }\n    return 0;  \/\/success\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_device_gray(fz_context *ctx)\n{\n\treturn ctx->colorspace->gray;\n}\n","project":"ghostscript","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_read(SSL *s, void *buf, int len)\n\t{\n\treturn ssl3_read_internal(s, buf, len, 0);\n\t}\n","project":"openssl","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_packet_withdraw (struct peer *peer, struct stream *s, struct prefix *p,\n\t\t     afi_t afi, safi_t safi, struct prefix_rd *prd,\n\t\t     u_char *tag)\n{\n  unsigned long cp;\n  unsigned long attrlen_pnt;\n  bgp_size_t size;\n\n  cp = stream_get_endp (s);\n\n  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n  stream_putc (s, BGP_ATTR_MP_UNREACH_NLRI);\n\n  attrlen_pnt = stream_get_endp (s);\n  stream_putc (s, 0);\t\t\/* Length of this attribute. *\/\n\n  stream_putw (s, family2afi (p->family));\n\n  if (safi == SAFI_MPLS_VPN)\n    {\n      \/* SAFI *\/\n      stream_putc (s, SAFI_MPLS_LABELED_VPN);\n\n      \/* prefix. *\/\n      stream_putc (s, p->prefixlen + 88);\n      stream_put (s, tag, 3);\n      stream_put (s, prd->val, 8);\n      stream_put (s, &p->u.prefix, PSIZE (p->prefixlen));\n    }\n  else\n    {\n      \/* SAFI *\/\n      stream_putc (s, safi);\n\n      \/* prefix *\/\n      stream_put_prefix (s, p);\n    }\n\n  \/* Set MP attribute length. *\/\n  size = stream_get_endp (s) - attrlen_pnt - 1;\n  stream_putc_at (s, attrlen_pnt, size);\n\n  return stream_get_endp (s) - cp;\n}\n","project":"savannah","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"set_no_icc(fz_colorspace_context *cct)\n{\n\tcct->gray = default_gray;\n\tcct->rgb = default_rgb;\n\tcct->bgr = default_bgr;\n\tcct->cmyk = default_cmyk;\n\tcct->lab = default_lab;\n}\n","project":"ghostscript","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"void fht4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n   vp9_fht4x4_c(in, out, stride, tx_type);\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkcs7_encrypt)\n{\n\tzval ** zrecipcerts, * zheaders = NULL;\n\tSTACK_OF(X509) * recipcerts = NULL;\n\tBIO * infile = NULL, * outfile = NULL;\n\tlong flags = 0;\n\tPKCS7 * p7 = NULL;\n\tHashPosition hpos;\n\tzval ** zcertval;\n\tX509 * cert;\n\tconst EVP_CIPHER *cipher = NULL;\n\tlong cipherid = PHP_OPENSSL_CIPHER_DEFAULT;\n\tuint strindexlen;\n\tulong intindex;\n\tchar * strindex;\n\tchar * infilename = NULL;\tint infilename_len;\n\tchar * outfilename = NULL;\tint outfilename_len;\n\t\n\tRETVAL_FALSE;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ssZa!|ll\", &infilename, &infilename_len,\n\t\t\t\t&outfilename, &outfilename_len, &zrecipcerts, &zheaders, &flags, &cipherid) == FAILURE)\n\t\treturn;\n\n\tif (strlen(infilename) != infilename_len) {\n\t\treturn;\n\t}\n\n\tif (strlen(outfilename) != outfilename_len) {\n\t\treturn;\n\t}\n\n\tif (php_openssl_safe_mode_chk(infilename TSRMLS_CC) || php_openssl_safe_mode_chk(outfilename TSRMLS_CC)) {\n\t\treturn;\n\t}\n\n\tinfile = BIO_new_file(infilename, \"r\");\n\tif (infile == NULL) {\n\t\tgoto clean_exit;\n\t}\n\n\toutfile = BIO_new_file(outfilename, \"w\");\n\tif (outfile == NULL) { \n\t\tgoto clean_exit;\n\t}\n\n\trecipcerts = sk_X509_new_null();\n\n\t\/* get certs *\/\n\tif (Z_TYPE_PP(zrecipcerts) == IS_ARRAY) {\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(*zrecipcerts), &hpos);\n\t\twhile(zend_hash_get_current_data_ex(HASH_OF(*zrecipcerts), (void**)&zcertval, &hpos) == SUCCESS) {\n\t\t\tlong certresource;\n\n\t\t\tcert = php_openssl_x509_from_zval(zcertval, 0, &certresource TSRMLS_CC);\n\t\t\tif (cert == NULL) {\n\t\t\t\tgoto clean_exit;\n\t\t\t}\n\n\t\t\tif (certresource != -1) {\n\t\t\t\t\/* we shouldn't free this particular cert, as it is a resource.\n\t\t\t\t\tmake a copy and push that on the stack instead *\/\n\t\t\t\tcert = X509_dup(cert);\n\t\t\t\tif (cert == NULL) {\n\t\t\t\t\tgoto clean_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsk_X509_push(recipcerts, cert);\n\n\t\t\tzend_hash_move_forward_ex(HASH_OF(*zrecipcerts), &hpos);\n\t\t}\n\t} else {\n\t\t\/* a single certificate *\/\n\t\tlong certresource;\n\n\t\tcert = php_openssl_x509_from_zval(zrecipcerts, 0, &certresource TSRMLS_CC);\n\t\tif (cert == NULL) {\n\t\t\tgoto clean_exit;\n\t\t}\n\n\t\tif (certresource != -1) {\n\t\t\t\/* we shouldn't free this particular cert, as it is a resource.\n\t\t\t\tmake a copy and push that on the stack instead *\/\n\t\t\tcert = X509_dup(cert);\n\t\t\tif (cert == NULL) {\n\t\t\t\tgoto clean_exit;\n\t\t\t}\n\t\t}\n\t\tsk_X509_push(recipcerts, cert);\n\t}\n\n\t\/* sanity check the cipher *\/\n\tcipher = php_openssl_get_evp_cipher_from_algo(cipherid);\n\tif (cipher == NULL) {\n\t\t\/* shouldn't happen *\/\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to get cipher\");\n\t\tgoto clean_exit;\n\t}\n\n\tp7 = PKCS7_encrypt(recipcerts, infile, (EVP_CIPHER*)cipher, flags);\n\n\tif (p7 == NULL) {\n\t\tgoto clean_exit;\n\t}\n\n\t\/* tack on extra headers *\/\n\tif (zheaders) {\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(zheaders), &hpos);\n\t\twhile(zend_hash_get_current_data_ex(HASH_OF(zheaders), (void**)&zcertval, &hpos) == SUCCESS) {\n\t\t\tstrindex = NULL;\n\t\t\tzend_hash_get_current_key_ex(HASH_OF(zheaders), &strindex, &strindexlen, &intindex, 0, &hpos);\n\n\t\t\tconvert_to_string_ex(zcertval);\n\n\t\t\tif (strindex) {\n\t\t\t\tBIO_printf(outfile, \"%s: %s\\n\", strindex, Z_STRVAL_PP(zcertval));\n\t\t\t} else {\n\t\t\t\tBIO_printf(outfile, \"%s\\n\", Z_STRVAL_PP(zcertval));\n\t\t\t}\n\n\t\t\tzend_hash_move_forward_ex(HASH_OF(zheaders), &hpos);\n\t\t}\n\t}\n\n\t(void)BIO_reset(infile);\n\n\t\/* write the encrypted data *\/\n\tSMIME_write_PKCS7(outfile, p7, infile, flags);\n\n\tRETVAL_TRUE;\n\nclean_exit:\n\tPKCS7_free(p7);\n\tBIO_free(infile);\n\tBIO_free(outfile);\n\tif (recipcerts) {\n\t\tsk_X509_pop_free(recipcerts, X509_free);\n\t}\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Tracks::~Tracks()\n{\n    Track** i = m_trackEntries;\n    Track** const j = m_trackEntriesEnd;\n    while (i != j)\n    {\n        Track* const pTrack = *i++;\n        delete pTrack;\n    }\n    delete[] m_trackEntries;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Segment::LoadCluster(\n    long long& pos,\n    long& len)\n{\n    for (;;)\n    {\n        const long result = DoLoadCluster(pos, len);\n \n        if (result <= 1)\n            return result;\n     }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"void Segment::AppendCluster(Cluster* pCluster)\n{\n    assert(pCluster);\n    assert(pCluster->m_index >= 0);\n \n    const long count = m_clusterCount + m_clusterPreloadCount;\n \n    long& size = m_clusterSize;\n    assert(size >= count);\n \n    const long idx = pCluster->m_index;\n    assert(idx == m_clusterCount);\n \n    if (count >= size)\n    {\n        const long n = (size <= 0) ? 2048 : 2*size;\n \n        Cluster** const qq = new Cluster*[n];\n        Cluster** q = qq;\n \n        Cluster** p = m_clusters;\n        Cluster** const pp = p + count;\n \n        while (p != pp)\n            *q++ = *p++;\n \n        delete[] m_clusters;\n \n        m_clusters = qq;\n        size = n;\n    }\n    if (m_clusterPreloadCount > 0)\n    {\n        assert(m_clusters);\n        Cluster** const p = m_clusters + m_clusterCount;\n        assert(*p);\n        assert((*p)->m_index < 0);\n        Cluster** q = p + m_clusterPreloadCount;\n        assert(q < (m_clusters + size));\n        for (;;)\n        {\n            Cluster** const qq = q - 1;\n            assert((*qq)->m_index < 0);\n            *q = *qq;\n            q = qq;\n            if (q == p)\n                break;\n        }\n    }\n    m_clusters[idx] = pCluster;\n    ++m_clusterCount;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  unsigned int SAD(unsigned int max_sad, int block_idx = 0) {\n    unsigned int ret;\n    const uint8_t* const reference = GetReference(block_idx);\n    REGISTER_STATE_CHECK(ret = GET_PARAM(2)(source_data_, source_stride_,\n                                            reference, reference_stride_,\n                                            max_sad));\n    return ret;\n  }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Cluster::~Cluster()\n{\n    if (m_entries_count <= 0)\n        return;\n    BlockEntry** i = m_entries;\n    BlockEntry** const j = m_entries + m_entries_count;\n    while (i != j)\n    {\n         BlockEntry* p = *i++;\n         assert(p);\n         delete p;\n     }\n \n    delete[] m_entries;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"bool Track::VetEntry(const BlockEntry* pBlockEntry) const\n{\n    assert(pBlockEntry);\n    const Block* const pBlock = pBlockEntry->GetBlock();\n    assert(pBlock);\n    assert(pBlock->GetTrackNumber() == m_info.number);\n    if (!pBlock || pBlock->GetTrackNumber() != m_info.number)\n        return false;\n \n \n    return true;\n }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"phar_entry_info *phar_get_entry_info_dir(phar_archive_data *phar, char *path, int path_len, char dir, char **error, int security TSRMLS_DC) \/* {{{ *\/\n{\n\tconst char *pcr_error;\n\tphar_entry_info *entry;\n\tint is_dir;\n\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(path, path_len);\n#endif\n\n\tis_dir = (path_len && (path[path_len - 1] == '\/')) ? 1 : 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (security && path_len >= sizeof(\".phar\")-1 && !memcmp(path, \".phar\", sizeof(\".phar\")-1)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: cannot directly access magic \\\".phar\\\" directory or files within it\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!path_len && !dir) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: invalid path \\\"%s\\\" must not be empty\", path);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: invalid path \\\"%s\\\" contains %s\", path, pcr_error);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!phar->manifest.arBuckets) {\n\t\treturn NULL;\n\t}\n\n\tif (is_dir) {\n\t\tif (!path_len || path_len == 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tpath_len--;\n\t}\n\n\tif (SUCCESS == zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {\n\t\tif (entry->is_deleted) {\n\t\t\t\/* entry is deleted, but has not been flushed to disk yet *\/\n\t\t\treturn NULL;\n\t\t}\n\t\tif (entry->is_dir && !dir) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" is a directory\", path);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!entry->is_dir && dir == 2) {\n\t\t\t\/* user requested a directory, we must return one *\/\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists and is a not a directory\", path);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (dir) {\n\t\tif (zend_hash_exists(&phar->virtual_dirs, path, path_len)) {\n\t\t\t\/* a file or directory exists in a sub-directory of this path *\/\n\t\t\tentry = (phar_entry_info *) ecalloc(1, sizeof(phar_entry_info));\n\t\t\t\/* this next line tells PharFileInfo->__destruct() to efree the filename *\/\n\t\t\tentry->is_temp_dir = entry->is_dir = 1;\n\t\t\tentry->filename = (char *) estrndup(path, path_len + 1);\n\t\t\tentry->filename_len = path_len;\n\t\t\tentry->phar = phar;\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\tif (phar->mounted_dirs.arBuckets && zend_hash_num_elements(&phar->mounted_dirs)) {\n\t\tphar_zstr key;\n\t\tchar *str_key;\n\t\tulong unused;\n\t\tuint keylen;\n\n\t\tzend_hash_internal_pointer_reset(&phar->mounted_dirs);\n\t\twhile (FAILURE != zend_hash_has_more_elements(&phar->mounted_dirs)) {\n\t\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(&phar->mounted_dirs, &key, &keylen, &unused, 0, NULL)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPHAR_STR(key, str_key);\n\n\t\t\tif ((int)keylen >= path_len || strncmp(str_key, path, keylen)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tchar *test;\n\t\t\t\tint test_len;\n\t\t\t\tphp_stream_statbuf ssb;\n\n\t\t\t\tif (SUCCESS != zend_hash_find(&phar->manifest, str_key, keylen, (void **) &entry)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar internal error: mounted path \\\"%s\\\" could not be retrieved from manifest\", str_key);\n\t\t\t\t\t}\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tif (!entry->tmp || !entry->is_mounted) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar internal error: mounted path \\\"%s\\\" is not properly initialized as a mounted path\", str_key);\n\t\t\t\t\t}\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tPHAR_STR_FREE(str_key);\n\n\t\t\t\ttest_len = spprintf(&test, MAXPATHLEN, \"%s%s\", entry->tmp, path + keylen);\n\n\t\t\t\tif (SUCCESS != php_stream_stat_path(test, &ssb)) {\n\t\t\t\t\tefree(test);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tif (ssb.sb.st_mode & S_IFDIR && !dir) {\n\t\t\t\t\tefree(test);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" is a directory\", path);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tif ((ssb.sb.st_mode & S_IFDIR) == 0 && dir) {\n\t\t\t\t\tefree(test);\n\t\t\t\t\t\/* user requested a directory, we must return one *\/\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists and is a not a directory\", path);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\t\/* mount the file just in time *\/\n\t\t\t\tif (SUCCESS != phar_mount_entry(phar, test, test_len, path, path_len TSRMLS_CC)) {\n\t\t\t\t\tefree(test);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists as file \\\"%s\\\" and could not be mounted\", path, test);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tefree(test);\n\n\t\t\t\tif (SUCCESS != zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists as file \\\"%s\\\" and could not be retrieved after being mounted\", path, test);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","func":"static int phar_dir_flush(php_stream *stream TSRMLS_DC) \/* {{{ *\/\n{\n\treturn EOF;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_set_default_gray(fz_context *ctx, fz_default_colorspaces *default_cs, fz_colorspace *cs)\n{\n\tif (cs->n == 1)\n\t{\n\t\tfz_drop_colorspace(ctx, default_cs->gray);\n\t\tdefault_cs->gray = fz_keep_colorspace(ctx, cs);\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static int check_cert(X509_STORE *ctx, X509 *x, STACK_OF(X509) *untrustedchain, int purpose)\n{\n\tint ret=0;\n\tX509_STORE_CTX *csc;\n\tTSRMLS_FETCH();\n\n\tcsc = X509_STORE_CTX_new();\n\tif (csc == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"memory allocation failure\");\n\t\treturn 0;\n\t}\n\tX509_STORE_CTX_init(csc, ctx, x, untrustedchain);\n\tif(purpose >= 0) {\n\t\tX509_STORE_CTX_set_purpose(csc, purpose);\n\t}\n\tret = X509_verify_cert(csc);\n\tX509_STORE_CTX_free(csc);\n\n\treturn ret;\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Cluster* Segment::GetLast() const\n{\n    if ((m_clusters == NULL) || (m_clusterCount <= 0))\n        return &m_eos;\n \n    const long idx = m_clusterCount - 1;\n \n    Cluster* const pCluster = m_clusters[idx];\n    assert(pCluster);\n    return pCluster;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"int SeekHead::GetCount() const\n{\n    return m_entry_count;\n }\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long ContentEncoding::ParseCompressionEntry(\n    long long start,\n    long long size,\n    IMkvReader* pReader,\n    ContentCompression* compression) {\n   assert(pReader);\n   assert(compression);\n \n long long pos = start;\n const long long stop = start + size;\n\n bool valid = false;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  \/\/error\n       return status;\n \n     if (id == 0x254) {\n long long algo = UnserializeUInt(pReader, pos, size);\n if (algo < 0)\n return E_FILE_FORMAT_INVALID;\n      compression->algo = algo;\n      valid = true;\n } else if (id == 0x255) {\n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      compression->settings = buf;\n\n       compression->settings_len = buflen;\n     }\n \n    pos += size;  \/\/consume payload\n     assert(pos <= stop);\n   }\n \n if (!valid)\n return E_FILE_FORMAT_INVALID;\n\n\n   return 0;\n }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"void fz_set_icc_bgr(fz_context *ctx, fz_colorspace *cs)\n{\n\tfz_iccprofile *profile;\n\n\tif (cs == NULL || !fz_colorspace_is_icc(ctx, cs))\n\t\treturn;\n\n\tprofile = cs->data;\n\tprofile->bgr = 1;\n\treturn;\n}\n","project":"ghostscript","target":0},{"commit_id":"03a53d1c7765eeb3af0bc34c3dff02ada1953fbf","func":" bool InputWindowInfo::isTrustedOverlay() const {\n     return layoutParamsType == TYPE_INPUT_METHOD\n             || layoutParamsType == TYPE_INPUT_METHOD_DIALOG\n             || layoutParamsType == TYPE_MAGNIFICATION_OVERLAY\n             || layoutParamsType == TYPE_SECURE_SYSTEM_OVERLAY;\n }\n","project":"Android","target":1},{"commit_id":"12fe4e90be7bfa2a763197079f68f5568a14e071","func":"void timelib_strtointerval(char *s, int len, \n                           timelib_time **begin, timelib_time **end, \n\t\t\t\t\t\t   timelib_rel_time **period, int *recurrences, \n\t\t\t\t\t\t   struct timelib_error_container **errors)\n{\n\tScanner in;\n\tint t;\n\tchar *e = s + len - 1;\n\n\tmemset(&in, 0, sizeof(in));\n\tin.errors = malloc(sizeof(struct timelib_error_container));\n\tin.errors->warning_count = 0;\n\tin.errors->warning_messages = NULL;\n\tin.errors->error_count = 0;\n\tin.errors->error_messages = NULL;\n\n\tif (len > 0) {\n\t\twhile (isspace(*s) && s < e) {\n\t\t\ts++;\n\t\t}\n\t\twhile (isspace(*e) && e > s) {\n\t\t\te--;\n\t\t}\n\t}\n\tif (e - s < 0) {\n\t\tadd_error(&in, \"Empty string\");\n\t\tif (errors) {\n\t\t\t*errors = in.errors;\n\t\t} else {\n\t\t\ttimelib_error_container_dtor(in.errors);\n\t\t}\n\t\treturn;\n\t}\n\te++;\n\n\t\/* init cursor *\/\n\tin.str = malloc((e - s) + YYMAXFILL);\n\tmemset(in.str, 0, (e - s) + YYMAXFILL);\n\tmemcpy(in.str, s, (e - s));\n\tin.lim = in.str + (e - s) + YYMAXFILL;\n\tin.cur = in.str;\n\n\t\/* init value containers *\/\n\tin.begin = timelib_time_ctor();\n\tin.begin->y = TIMELIB_UNSET;\n\tin.begin->d = TIMELIB_UNSET;\n\tin.begin->m = TIMELIB_UNSET;\n\tin.begin->h = TIMELIB_UNSET;\n\tin.begin->i = TIMELIB_UNSET;\n\tin.begin->s = TIMELIB_UNSET;\n\tin.begin->f = 0;\n\tin.begin->z = 0;\n\tin.begin->dst = 0;\n\tin.begin->is_localtime = 0;\n\tin.begin->zone_type = TIMELIB_ZONETYPE_OFFSET;\n\n\tin.end = timelib_time_ctor();\n\tin.end->y = TIMELIB_UNSET;\n\tin.end->d = TIMELIB_UNSET;\n\tin.end->m = TIMELIB_UNSET;\n\tin.end->h = TIMELIB_UNSET;\n\tin.end->i = TIMELIB_UNSET;\n\tin.end->s = TIMELIB_UNSET;\n\tin.end->f = 0;\n\tin.end->z = 0;\n\tin.end->dst = 0;\n\tin.end->is_localtime = 0;\n\tin.end->zone_type = TIMELIB_ZONETYPE_OFFSET;\n\n\tin.period = timelib_rel_time_ctor();\n\tin.period->y = 0;\n\tin.period->d = 0;\n\tin.period->m = 0;\n\tin.period->h = 0;\n\tin.period->i = 0;\n\tin.period->s = 0;\n\tin.period->weekday = 0;\n\tin.period->weekday_behavior = 0;\n\tin.period->first_last_day_of = 0;\n\tin.period->days = TIMELIB_UNSET;\n\n\tin.recurrences = 1;\n\n\tdo {\n\t\tt = scan(&in);\n#ifdef DEBUG_PARSER\n\t\tprintf(\"%d\\n\", t);\n#endif\n\t} while(t != EOI);\n\n\tfree(in.str);\n\tif (errors) {\n\t\t*errors = in.errors;\n\t} else {\n\t\ttimelib_error_container_dtor(in.errors);\n\t}\n\tif (in.have_begin_date) {\n\t\t*begin = in.begin;\n\t} else {\n\t\ttimelib_time_dtor(in.begin);\n\t}\n\tif (in.have_end_date) {\n\t\t*end   = in.end;\n\t} else {\n\t\ttimelib_time_dtor(in.end);\n\t}\n\tif (in.have_period) {\n\t\t*period = in.period;\n\t} else {\n\t\ttimelib_rel_time_dtor(in.period);\n\t}\n\tif (in.have_recurrences) {\n\t\t*recurrences = in.recurrences;\n\t}\n}\n","project":"php","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_peek(SSL *s, void *buf, int len)\n\t{\n\treturn ssl3_read_internal(s, buf, len, 1);\n\t}\n","project":"openssl","target":0},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_pkcs7_decrypt)\n{\n\tzval ** recipcert, ** recipkey = NULL;\n\tX509 * cert = NULL;\n\tEVP_PKEY * key = NULL;\n\tlong certresval, keyresval;\n\tBIO * in = NULL, * out = NULL, * datain = NULL;\n\tPKCS7 * p7 = NULL;\n\tchar * infilename;\tint infilename_len;\n\tchar * outfilename;\tint outfilename_len;\n\n\tRETVAL_FALSE;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ssZ|Z\", &infilename, &infilename_len,\n\t\t\t\t&outfilename, &outfilename_len, &recipcert, &recipkey) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (strlen(infilename) != infilename_len) {\n\t\treturn;\n\t}\n\n\tif (strlen(outfilename) != outfilename_len) {\n\t\treturn;\n\t}\n\n\tcert = php_openssl_x509_from_zval(recipcert, 0, &certresval TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"unable to coerce parameter 3 to x509 cert\");\n\t\tgoto clean_exit;\n\t}\n\n\tkey = php_openssl_evp_from_zval(recipkey ? recipkey : recipcert, 0, \"\", 0, &keyresval TSRMLS_CC);\n\tif (key == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"unable to get private key\");\n\t\tgoto clean_exit;\n\t}\n\t\n\tif (php_openssl_safe_mode_chk(infilename TSRMLS_CC) || php_openssl_safe_mode_chk(outfilename TSRMLS_CC)) {\n\t\tgoto clean_exit;\n\t}\n\n\tin = BIO_new_file(infilename, \"r\");\n\tif (in == NULL) {\n\t\tgoto clean_exit;\n\t}\n\tout = BIO_new_file(outfilename, \"w\");\n\tif (out == NULL) {\n\t\tgoto clean_exit;\n\t}\n\n\tp7 = SMIME_read_PKCS7(in, &datain);\n\n\tif (p7 == NULL) {\n\t\tgoto clean_exit;\n\t}\n\tif (PKCS7_decrypt(p7, key, cert, out, PKCS7_DETACHED)) { \n\t\tRETVAL_TRUE;\n\t}\nclean_exit:\n\tPKCS7_free(p7);\n\tBIO_free(datain);\n\tBIO_free(in);\n\tBIO_free(out);\n\tif (cert && certresval == -1) {\n\t\tX509_free(cert);\n\t}\n\tif (key && keyresval == -1) {\n\t\tEVP_PKEY_free(key);\n\t}\n}\n","project":"php","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Cues* Segment::GetCues() const\n{\n    return m_pCues;\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"unsigned long Tracks::GetTracksCount() const\n{\n    const ptrdiff_t result = m_trackEntriesEnd - m_trackEntries;\n    assert(result >= 0);\n    return static_cast<unsigned long>(result);\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":" vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size) {\n   vpx_codec_err_t res_dec;\n   InitOnce();\n  REGISTER_STATE_CHECK(\n       res_dec = vpx_codec_decode(&decoder_,\n                                  cxdata, static_cast<unsigned int>(size),\n                                 NULL, 0));\n   return res_dec;\n }\n","project":"Android","target":1},{"commit_id":"e629194c62a9a129ce378e08cb1059a8a53f1795","func":"WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,\n                         WORD32 i4_poc,\n pocstruct_t *ps_temp_poc,\n                         UWORD16 u2_frame_num,\n dec_pic_params_t *ps_pps)\n{\n pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;\n pocstruct_t *ps_cur_poc = ps_temp_poc;\n\n pic_buffer_t *pic_buf;\n\n ivd_video_decode_op_t * ps_dec_output =\n (ivd_video_decode_op_t *)ps_dec->pv_dec_out;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n dec_seq_params_t *ps_seq = ps_pps->ps_sps;\n    UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;\n    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;\n \/* high profile related declarations *\/\n high_profile_tools_t s_high_profile;\n    WORD32 ret;\n\n    H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);\n\n    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\n    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\n    ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                    ps_cur_poc->i4_delta_pic_order_cnt_bottom;\n    ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[0];\n    ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[1];\n    ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;\n    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\n    ps_prev_poc->u2_frame_num = u2_frame_num;\n    ps_dec->i1_prev_mb_qp_delta = 0;\n    ps_dec->i1_next_ctxt_idx = 0;\n\n\n    ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores == 1)\n       ps_dec->u4_nmb_deblk = 1;\n\n\n\n if(ps_seq->u1_mb_aff_flag == 1)\n {\n        ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores > 2)\n            ps_dec->u4_num_cores = 2;\n }\n\n        ps_dec->u4_use_intrapred_line_copy = 0;\n\n\n\n if (ps_seq->u1_mb_aff_flag == 0)\n {\n        ps_dec->u4_use_intrapred_line_copy = 1;\n }\n\n    ps_dec->u4_app_disable_deblk_frm = 0;\n \/* If degrade is enabled, set the degrade flags appropriately *\/\n if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)\n {\n        WORD32 degrade_pic;\n        ps_dec->i4_degrade_pic_cnt++;\n        degrade_pic = 0;\n\n \/* If degrade is to be done in all frames, then do not check further *\/\n switch(ps_dec->i4_degrade_pics)\n {\n case 4:\n {\n                degrade_pic = 1;\n break;\n }\n case 3:\n {\n if(ps_cur_slice->u1_slice_type != I_SLICE)\n                    degrade_pic = 1;\n\n break;\n }\n case 2:\n {\n\n \/* If pic count hits non-degrade interval or it is an islice, then do not degrade *\/\n if((ps_cur_slice->u1_slice_type != I_SLICE)\n && (ps_dec->i4_degrade_pic_cnt\n != ps_dec->i4_nondegrade_interval))\n                    degrade_pic = 1;\n\n break;\n }\n case 1:\n {\n \/* Check if the current picture is non-ref *\/\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n                    degrade_pic = 1;\n }\n break;\n }\n\n }\n if(degrade_pic)\n {\n if(ps_dec->i4_degrade_type & 0x2)\n                ps_dec->u4_app_disable_deblk_frm = 1;\n\n \/* MC degrading is done only for non-ref pictures *\/\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n if(ps_dec->i4_degrade_type & 0x4)\n                    ps_dec->i4_mv_frac_mask = 0;\n\n if(ps_dec->i4_degrade_type & 0x8)\n                    ps_dec->i4_mv_frac_mask = 0;\n }\n }\n else\n            ps_dec->i4_degrade_pic_cnt = 0;\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_dec->u1_sl_typ_5_9\n && ((ps_cur_slice->u1_slice_type == I_SLICE)\n || (ps_cur_slice->u1_slice_type\n == SI_SLICE)))\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n else\n            ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\n\n if(ps_err->u1_pic_aud_i == PIC_TYPE_I)\n {\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n            ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n }\n\n if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n if(ps_err->u1_err_flag)\n                ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)\n {\n \/* Reset the decoder picture buffers *\/\n        WORD32 j;\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                  ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_IO);\n }\n\n \/* reset the decoder structure parameters related to buffer handling *\/\n        ps_dec->u1_second_field = 0;\n        ps_dec->i4_cur_display_seq = 0;\n\n \/********************************************************************\/\n \/* indicate in the decoder output i4_status that some frames are being *\/\n \/* dropped, so that it resets timestamp and wait for a new sequence *\/\n \/********************************************************************\/\n\n        ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n }\n    ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);\n if(ret != OK)\n return ret;\n\n    ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;\n if(ps_dec->u1_separate_parse)\n {\n        UWORD16 pic_wd;\n        UWORD16 pic_ht;\n        UWORD32 num_mbs;\n\n        pic_wd = ps_dec->u2_pic_wd;\n        pic_ht = ps_dec->u2_pic_ht;\n        num_mbs = (pic_wd * pic_ht) >> 8;\n\n if(ps_dec->pu1_dec_mb_map)\n {\n            memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu1_recon_mb_map)\n {\n\n            memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu2_slice_num_map)\n {\n            memset((void *)ps_dec->pu2_slice_num_map, 0,\n (num_mbs * sizeof(UWORD16)));\n }\n\n }\n\n    ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n\n \/* Initialize all the HP toolsets to zero *\/\n    ps_dec->s_high_profile.u1_scaling_present = 0;\n    ps_dec->s_high_profile.u1_transform8x8_present = 0;\n\n \/* Get Next Free Picture *\/\n if(1 == ps_dec->u4_share_disp_buf)\n {\n        UWORD32 i;\n \/* Free any buffer that is in the queue to be freed *\/\n for(i = 0; i < MAX_DISP_BUFS_NEW; i++)\n {\n if(0 == ps_dec->u4_disp_buf_to_be_freed[i])\n continue;\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,\n            BUF_MGR_IO);\n            ps_dec->u4_disp_buf_to_be_freed[i] = 0;\n            ps_dec->u4_disp_buf_mapping[i] = 0;\n\n }\n }\n if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) \/\/ps_dec->u1_second_field))\n {\n pic_buffer_t *ps_cur_pic;\n        WORD32 cur_pic_buf_id, cur_mv_buf_id;\n col_mv_buf_t *ps_col_mv;\n while(1)\n {\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])\n {\n break;\n }\n\n }\n        ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n            ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n        ps_dec->ps_cur_pic = ps_cur_pic;\n        ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n        ps_cur_pic->u4_ts = ps_dec->u4_ts;\n\n\n        ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n        ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n        ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n        ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n        ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n if(ps_dec->u1_first_slice_in_stream)\n {\n \/*make first entry of list0 point to cur pic,so that if first Islice is in error, ref pic struct will have valid entries*\/\n            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;\n }\n\n if(!ps_dec->ps_cur_pic)\n {\n            WORD32 j;\n            H264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                      ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_IO);\n }\n\n            ps_dec->i4_cur_display_seq = 0;\n            ps_dec->i4_prev_max_display_seq = 0;\n            ps_dec->i4_max_poc = 0;\n\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n\n            ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n            ps_dec->ps_cur_pic = ps_cur_pic;\n            ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n            ps_cur_pic->u4_ts = ps_dec->u4_ts;\n            ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;\n\n            ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n            ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n            ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n            ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n            ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n }\n\n        ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;\n        ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;\n        H264_DEC_DEBUG_PRINT(\"got a buffer\\n\");\n }\n else\n {\n        H264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");\n }\n\n    ps_dec->u4_pic_buf_got = 1;\n\n    ps_dec->ps_cur_pic->i4_poc = i4_poc;\n    ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =\n                    ps_pps->i4_bottom_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;\n    ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;\n\n    ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);\n if(u1_field_pic_flag && u1_bottom_field_flag)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n \/* Point to odd lines, since it's bottom field *\/\n        ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;\n        ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.ps_mv +=\n ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht\n * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;\n        i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        i4_temp_poc = MIN(i4_top_field_order_poc,\n                                 i4_bot_field_order_poc);\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n\n    ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n\n    ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag\n << 2);\n\n    ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; \/\/[0];\n    ps_dec->ps_cur_mb_row += 2;\n    ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row;\n    ps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));\n    ps_dec->ps_top_mb_row += 2;\n\n \/* CHANGED CODE *\/\n    ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];\n \/* CHANGED CODE *\/\n    ps_dec->u1_mv_top_p = 0;\n    ps_dec->u1_mb_idx = 0;\n \/* CHANGED CODE *\/\n    ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);\n    ps_dec->u4_pred_info_idx = 0;\n    ps_dec->u4_pred_info_pkd_idx = 0;\n    ps_dec->u4_dma_buf_idx = 0;\n    ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->i2_prev_slice_mbx = -1;\n    ps_dec->i2_prev_slice_mby = 0;\n    ps_dec->u2_mv_2mb[0] = 0;\n    ps_dec->u2_mv_2mb[1] = 0;\n    ps_dec->u1_last_pic_not_decoded = 0;\n\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->u2_cur_slice_num_dec_thread = 0;\n    ps_dec->u2_cur_slice_num_bs = 0;\n    ps_dec->u4_intra_pred_line_ofst = 0;\n    ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;\n\n    ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;\n\n\n\n\n\n    ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line\n + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);\n\n    ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;\n    ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;\n\n    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n \/* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag *\/\n {\n if(ps_cur_slice->u1_mbaff_frame_flag)\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;\n            ps_dec->pf_mvpred = ih264d_mvpred_mbaff;\n }\n else\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;\n            ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;\n }\n }\n \/* Set up the Parameter for DMA transfer *\/\n {\n        UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;\n\n        UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)\n % (ps_dec->u1_recon_mb_grp >> u1_mbaff));\n        UWORD16 ui16_lastmbs_widthY =\n (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 4));\n        UWORD16 ui16_lastmbs_widthUV =\n                        uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 3);\n\n        ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n        ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n        ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n        ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y\n << u1_field_pic_flag;\n        ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv\n << u1_field_pic_flag;\n\n if(u1_field_pic_flag)\n {\n            ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;\n            ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;\n }\n\n \/* Normal Increment of Pointer *\/\n        ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n        ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n\n \/* End of Row Increment *\/\n        ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY\n + (PAD_LEN_Y_H << 1)\n + ps_dec->s_tran_addrecon.u2_frm_wd_y\n * ((15 << u1_mbaff) + u1_mbaff));\n        ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV\n + (PAD_LEN_UV_H << 2)\n + ps_dec->s_tran_addrecon.u2_frm_wd_uv\n * ((15 << u1_mbaff) + u1_mbaff));\n\n \/* Assign picture numbers to each frame\/field  *\/\n \/* only once per picture.                      *\/\n        ih264d_assign_pic_num(ps_dec);\n        ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp\n << 2) - 1 - (u1_mbaff << 2);\n        ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) - 1) << (4 + u1_mbaff);\n }\n \/**********************************************************************\/\n \/* High profile related initialization at pictrue level               *\/\n \/**********************************************************************\/\n if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)\n {\n if((ps_seq->i4_seq_scaling_matrix_present_flag)\n || (ps_pps->i4_pic_scaling_matrix_present_flag))\n {\n            ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);\n            ps_dec->s_high_profile.u1_scaling_present = 1;\n }\n else\n {\n            ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n if(ps_pps->i4_transform_8x8_mode_flag)\n {\n            ps_dec->s_high_profile.u1_transform8x8_present = 1;\n }\n }\n else\n {\n        ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n \/* required while reading the transform_size_8x8 u4_flag *\/\n    ps_dec->s_high_profile.u1_direct_8x8_inference_flag =\n                    ps_seq->u1_direct_8x8_inference_flag;\n    ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;\n\n    ps_dec->i1_recon_in_thread3_flag = 1;\n    ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;\n if(ps_dec->u1_separate_parse)\n {\n        memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)\n {\n            memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n            ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;\n }\n }\n\n\n    ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),\n                               ps_dec->u2_frm_wd_in_mbs, 0);\n\n    ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;\n    ps_dec->u4_cur_deblk_mb_num = 0;\n\n \n     ps_dec->u4_deblk_mb_x = 0;\n     ps_dec->u4_deblk_mb_y = 0;\n \n     H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);\n     return OK;\n}\n","project":"Android","target":1},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_intern (struct attr *attr)\n{\n  struct attr *find;\n\n  \/* Intern referenced strucutre. *\/\n  if (attr->aspath)\n    {\n      if (! attr->aspath->refcnt)\n\tattr->aspath = aspath_intern (attr->aspath);\n      else\n\tattr->aspath->refcnt++;\n    }\n  if (attr->community)\n    {\n      if (! attr->community->refcnt)\n\tattr->community = community_intern (attr->community);\n      else\n\tattr->community->refcnt++;\n    }\n  if (attr->extra)\n    {\n      struct attr_extra *attre = attr->extra;\n      \n      if (attre->ecommunity)\n        {\n          if (! attre->ecommunity->refcnt)\n            attre->ecommunity = ecommunity_intern (attre->ecommunity);\n          else\n            attre->ecommunity->refcnt++;\n          \n        }\n      if (attre->cluster)\n        {\n          if (! attre->cluster->refcnt)\n            attre->cluster = cluster_intern (attre->cluster);\n          else\n            attre->cluster->refcnt++;\n        }\n      if (attre->transit)\n        {\n          if (! attre->transit->refcnt)\n            attre->transit = transit_intern (attre->transit);\n          else\n            attre->transit->refcnt++;\n        }\n    }\n  \n  find = (struct attr *) hash_get (attrhash, attr, bgp_attr_hash_alloc);\n  find->refcnt++;\n  \n  return find;\n}\n","project":"savannah","target":0},{"commit_id":"268068f25673242d1d5130d96202d3288c91b700","func":"void close_all_sockets(atransport* t) {\n    asocket* s;\n\n\n     \/* this is a little gross, but since s->close() *will* modify\n     ** the list out from under you, your options are limited.\n     *\/\n    adb_mutex_lock(&socket_list_lock);\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close_locked(s);\n             goto restart;\n         }\n     }\n    adb_mutex_unlock(&socket_list_lock);\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"static void php_pkey_free(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tEVP_PKEY *pkey = (EVP_PKEY *)rsrc->ptr;\n\n\tassert(pkey != NULL);\n\n\tEVP_PKEY_free(pkey);\n}\n","project":"php","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"int fz_colorspace_device_n_has_only_cmyk(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && ((cs->flags & FZ_CS_HAS_CMYK_AND_SPOTS) == FZ_CS_HAS_CMYK);\n}\n","project":"ghostscript","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"bgp_attr_local_pref (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  \/* Length check. *\/\n  if (length != 4)\n  {\n    zlog (peer->log, LOG_ERR, \"LOCAL_PREF attribute length isn't 4 [%u]\",\n          length);\n    return bgp_attr_malformed (args,\n                               BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                               args->total);\n  }\n\n  \/* If it is contained in an UPDATE message that is received from an\n     external peer, then this attribute MUST be ignored by the\n     receiving speaker. *\/\n  if (peer_sort (peer) == BGP_PEER_EBGP)\n    {\n      stream_forward_getp (peer->ibuf, length);\n      return BGP_ATTR_PARSE_PROCEED;\n    }\n\n  attr->local_pref = stream_getl (peer->ibuf);\n\n  \/* Set atomic aggregate flag. *\/\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n","project":"savannah","target":0},{"commit_id":"918eeaa29d99d257282fafec931b4bda0e3bae12","func":"void SoftAVC::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mSignalledError) {\n return;\n }\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (NULL == mCodecCtx) {\n if (OK != initDecoder()) {\n            ALOGE(\"Failed to initialize decoder\");\n            notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);\n            mSignalledError = true;\n return;\n }\n }\n if (outputBufferWidth() != mStride) {\n \/* Set the run-time (dynamic) parameters *\/\n        mStride = outputBufferWidth();\n        setParams(mStride);\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n \/* If input EOS is seen and decoder is not in flush mode,\n     * set the decoder in flush mode.\n     * There can be a case where EOS is sent along with last picture data\n     * In that case, only after decoding that input data, decoder has to be\n     * put in flush. This case is handled here  *\/\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n                    inQueue.erase(inQueue.begin());\n                    inInfo->mOwnedByUs = false;\n continue;\n }\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL) {\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n\n if (!(inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n continue;\n }\n\n                mReceivedEOS = true;\n                inHeader = NULL;\n                setFlushMode();\n } else if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mReceivedEOS = true;\n }\n }\n\n \/* Get a free slot in timestamp array to hold input timestamp *\/\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n\n             WORD32 timeDelay, timeTaken;\n             size_t sizeY, sizeUV;\n \n            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n             DUMP_TO_FILE(mInFile, s_dec_ip.pv_stream_buffer, s_dec_ip.u4_num_Bytes);\n \n            GETTIME(&mTimeStart, NULL);\n \/* Compute time elapsed between end of previous decode()\n             * to start of current decode() *\/\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n            IV_API_CALL_STATUS_T status;\n            status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n\n bool unsupportedResolution =\n (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == (s_dec_op.u4_error_code & 0xFF));\n\n \/* Check for unsupported dimensions *\/\n if (unsupportedResolution) {\n                ALOGE(\"Unsupported resolution : %dx%d\", mWidth, mHeight);\n                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n bool allocationFailed = (IVD_MEM_ALLOC_FAILED == (s_dec_op.u4_error_code & 0xFF));\n if (allocationFailed) {\n                ALOGE(\"Allocation failure in decoder\");\n                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n\n            GETTIME(&mTimeEnd, NULL);\n \/* Compute time taken for decode() *\/\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            PRINT_TIME(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n \/* If the input did not contain picture data, then ignore\n                 * the associated timestamp *\/\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n                outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) \/ 2;\n\n                outHeader->nTimeStamp = mTimeStamps[s_dec_op.u4_ts];\n                mTimeStampsValid[s_dec_op.u4_ts] = false;\n\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(outQueue.begin());\n                outInfo = NULL;\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n } else {\n \/* If in flush mode and no output is returned by the codec,\n                 * then come out of flush mode *\/\n                mIsInFlush = false;\n\n \/* If EOS was recieved on input port and there is no output\n                 * from the codec, then signal EOS on output port *\/\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"Chapters::~Chapters()\n{\n    while (m_editions_count > 0)\n    {\n        Edition& e = m_editions[--m_editions_count];\n        e.Clear();\n    }\n}\n","project":"Android","target":1},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"const Track* Tracks::GetTrackByIndex(unsigned long idx) const\n{\n    const ptrdiff_t count = m_trackEntriesEnd - m_trackEntries;\n    if (idx >= static_cast<unsigned long>(count))\n         return NULL;\n    return m_trackEntries[idx];\n }\n","project":"Android","target":1},{"commit_id":"c1224573c773b6845e83505f717fbf820fc18415","func":"PHP_FUNCTION(openssl_csr_export_to_file)\n{\n\tX509_REQ * csr;\n\tzval * zcsr = NULL;\n\tzend_bool notext = 1;\n\tchar * filename = NULL; int filename_len;\n\tBIO * bio_out;\n\tlong csr_resource;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs|b\", &zcsr, &filename, &filename_len, &notext) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tif (strlen(filename) != filename_len) {\n\t\treturn;\n\t}\n\n\tcsr = php_openssl_csr_from_zval(&zcsr, 0, &csr_resource TSRMLS_CC);\n\tif (csr == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get CSR from parameter 1\");\n\t\treturn;\n\t}\n\n\tif (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {\n\t\treturn;\n\t}\n\n\tbio_out = BIO_new_file(filename, \"w\");\n\tif (bio_out) {\n\t\tif (!notext) {\n\t\t\tX509_REQ_print(bio_out, csr);\n\t\t}\n\t\tPEM_write_bio_X509_REQ(bio_out, csr);\n\t\tRETVAL_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error opening file %s\", filename);\n\t}\n\n\tif (csr_resource == -1 && csr) {\n\t\tX509_REQ_free(csr);\n\t}\n\tBIO_free(bio_out);\n}\n","project":"php","target":0},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"  void RunAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     uint32_t max_error = 0;\n     int64_t total_error = 0;\n     const int count_test_block = 10000;\n     for (int i = 0; i < count_test_block; ++i) {\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        test_input_block[j] = src[j] - dst[j];\n       }\n \n      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,\n                                      test_temp_block, pitch_));\n      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n        total_error += error;\n\n       }\n     }\n \n    EXPECT_GE(1u, max_error)\n        << \"Error: 4x4 FHT\/IHT has an individual round trip error > 1\";\n \n    EXPECT_GE(count_test_block , total_error)\n        << \"Error: 4x4 FHT\/IHT has average round trip error > 1 per block\";\n   }\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_new_default_colorspaces(fz_context *ctx)\n{\n\tfz_default_colorspaces *default_cs = fz_malloc_struct(ctx, fz_default_colorspaces);\n\tdefault_cs->refs = 1;\n\tdefault_cs->gray = fz_keep_colorspace(ctx, fz_device_gray(ctx));\n\tdefault_cs->rgb = fz_keep_colorspace(ctx, fz_device_rgb(ctx));\n\tdefault_cs->cmyk = fz_keep_colorspace(ctx, fz_device_cmyk(ctx));\n\tdefault_cs->oi = NULL;\n\treturn default_cs;\n}\n","project":"ghostscript","target":0},{"commit_id":"ca989269a2876bae79393bd54c3e72d49975fc75","func":"int ssl3_new(SSL *s)\n\t{\n\tSSL3_STATE *s3;\n\n\tif ((s3=OPENSSL_malloc(sizeof *s3)) == NULL) goto err;\n\tmemset(s3,0,sizeof *s3);\n\tmemset(s3->rrec.seq_num,0,sizeof(s3->rrec.seq_num));\n\tmemset(s3->wrec.seq_num,0,sizeof(s3->wrec.seq_num));\n\n\ts->s3=s3;\n\n#ifndef OPENSSL_NO_SRP\n\tSSL_SRP_CTX_init(s);\n#endif\n\ts->method->ssl_clear(s);\n\treturn(1);\nerr:\n\treturn(0);\n\t}\n","project":"openssl","target":0},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"const char *fz_colorspace_name(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs ? cs->name : \"\";\n}\n","project":"ghostscript","target":0},{"commit_id":"04839626ed859623901ebd3a5fd483982186b59d","func":"long Track::ParseContentEncodingsEntry(long long start, long long size) {\n IMkvReader* const pReader = m_pSegment->m_pReader;\n  assert(pReader);\n\n long long pos = start;\n const long long stop = start + size;\n\n\n   int count = 0;\n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  \/\/error\n       return status;\n \n     if (id == 0x2240)  \/\/ ContentEncoding ID\n       ++count;\n \n    pos += size;  \/\/consume payload\n     assert(pos <= stop);\n   }\n \n   if (count <= 0)\n     return -1;\n \n  content_encoding_entries_ = new (std::nothrow) ContentEncoding*[count];\n   if (!content_encoding_entries_)\n     return -1;\n \n  content_encoding_entries_end_ = content_encoding_entries_;\n\n\n   pos = start;\n   while (pos < stop) {\n     long long id, size;\n    long status = ParseElementHeader(pReader,\n                                     pos,\n                                     stop,\n                                     id,\n                                     size);\n    if (status < 0)  \/\/error\n       return status;\n \n    if (id == 0x2240) { \/\/ ContentEncoding ID\n       ContentEncoding* const content_encoding =\n           new (std::nothrow) ContentEncoding();\n       if (!content_encoding)\n         return -1;\n \n      status = content_encoding->ParseContentEncodingEntry(pos,\n                                                           size,\n                                                           pReader);\n       if (status) {\n         delete content_encoding;\n         return status;\n }\n\n\n       *content_encoding_entries_end_++ = content_encoding;\n     }\n \n    pos += size;  \/\/consume payload\n     assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n\n\n   return 0;\n }\n","project":"Android","target":1},{"commit_id":"075d7556964f5a871a73c22ac4b69f5361295099","func":"is_invalid_entry (struct fileinfo *f)\n{\n  struct fileinfo *cur = f;\n  char *f_name = f->name;\n\n  \/* If the node we're currently checking has a duplicate later, we eliminate\n   * the current node and leave the next one intact. *\/\n  while (cur->next)\n    {\n      cur = cur->next;\n      if (strcmp(f_name, cur->name) == 0)\n          return true;\n    }\n  return false;\n}\n","project":"savannah","target":0},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"static int phar_call_openssl_signverify(int is_sign, php_stream *fp, off_t end, char *key, int key_len, char **signature, int *signature_len TSRMLS_DC) \/* {{{ *\/\n{\n\tzend_fcall_info fci;\n\tzend_fcall_info_cache fcc;\n\tzval *zdata, *zsig, *zkey, *retval_ptr, **zp[3], *openssl;\n\n\tMAKE_STD_ZVAL(zdata);\n\tMAKE_STD_ZVAL(openssl);\n\tZVAL_STRINGL(openssl, is_sign ? \"openssl_sign\" : \"openssl_verify\", is_sign ? sizeof(\"openssl_sign\")-1 : sizeof(\"openssl_verify\")-1, 1);\n\tMAKE_STD_ZVAL(zsig);\n\tZVAL_STRINGL(zsig, *signature, *signature_len, 1);\n\tMAKE_STD_ZVAL(zkey);\n\tZVAL_STRINGL(zkey, key, key_len, 1);\n\tzp[0] = &zdata;\n\tzp[1] = &zsig;\n\tzp[2] = &zkey;\n\n\tphp_stream_rewind(fp);\n\tZ_TYPE_P(zdata) = IS_STRING;\n\tZ_STRLEN_P(zdata) = end;\n\n\tif (end != (off_t) php_stream_copy_to_mem(fp, &(Z_STRVAL_P(zdata)), (size_t) end, 0)) {\n\t\tzval_dtor(zdata);\n\t\tzval_dtor(zsig);\n\t\tzval_dtor(zkey);\n\t\tzval_dtor(openssl);\n\t\tefree(openssl);\n\t\tefree(zdata);\n\t\tefree(zkey);\n\t\tefree(zsig);\n\t\treturn FAILURE;\n\t}\n\n\tif (FAILURE == zend_fcall_info_init(openssl, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {\n\t\tzval_dtor(zdata);\n\t\tzval_dtor(zsig);\n\t\tzval_dtor(zkey);\n\t\tzval_dtor(openssl);\n\t\tefree(openssl);\n\t\tefree(zdata);\n\t\tefree(zkey);\n\t\tefree(zsig);\n\t\treturn FAILURE;\n\t}\n\n\tfci.param_count = 3;\n\tfci.params = zp;\n\tZ_ADDREF_P(zdata);\n\tif (is_sign) {\n\t\tZ_SET_ISREF_P(zsig);\n\t} else {\n\t\tZ_ADDREF_P(zsig);\n\t}\n\tZ_ADDREF_P(zkey);\n\n\tfci.retval_ptr_ptr = &retval_ptr;\n\n\tif (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {\n\t\tzval_dtor(zdata);\n\t\tzval_dtor(zsig);\n\t\tzval_dtor(zkey);\n\t\tzval_dtor(openssl);\n\t\tefree(openssl);\n\t\tefree(zdata);\n\t\tefree(zkey);\n\t\tefree(zsig);\n\t\treturn FAILURE;\n\t}\n\n\tzval_dtor(openssl);\n\tefree(openssl);\n\tZ_DELREF_P(zdata);\n\n\tif (is_sign) {\n\t\tZ_UNSET_ISREF_P(zsig);\n\t} else {\n\t\tZ_DELREF_P(zsig);\n\t}\n\tZ_DELREF_P(zkey);\n\n\tzval_dtor(zdata);\n\tefree(zdata);\n\tzval_dtor(zkey);\n\tefree(zkey);\n\n\tswitch (Z_TYPE_P(retval_ptr)) {\n\t\tdefault:\n\t\tcase IS_LONG:\n\t\t\tzval_dtor(zsig);\n\t\t\tefree(zsig);\n\t\t\tif (1 == Z_LVAL_P(retval_ptr)) {\n\t\t\t\tefree(retval_ptr);\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\tefree(retval_ptr);\n\t\t\treturn FAILURE;\n\t\tcase IS_BOOL:\n\t\t\tefree(retval_ptr);\n\t\t\tif (Z_BVAL_P(retval_ptr)) {\n\t\t\t\t*signature = estrndup(Z_STRVAL_P(zsig), Z_STRLEN_P(zsig));\n\t\t\t\t*signature_len = Z_STRLEN_P(zsig);\n\t\t\t\tzval_dtor(zsig);\n\t\t\t\tefree(zsig);\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\tzval_dtor(zsig);\n\t\t\tefree(zsig);\n\t\t\treturn FAILURE;\n\t}\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","func":"static int samldb_fill_foreignSecurityPrincipal_object(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tconst struct ldb_val *rdn_value;\n\tstruct dom_sid *sid;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tsid = samdb_result_dom_sid(ac->msg, ac->msg, \"objectSid\");\n\tif (sid == NULL) {\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tsid = dom_sid_parse_talloc(ac->msg,\n\t\t\t\t\t   (const char *)rdn_value->data);\n\t\tif (sid == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: No valid SID found in ForeignSecurityPrincipal CN!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tif (! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t}\n\n\t\/* finally proceed with adding the entry *\/\n\tret = samldb_add_step(ac, samldb_add_entry);\n\tif (ret != LDB_SUCCESS) return ret;\n\n\treturn samldb_first_step(ac);\n}\n","project":"samba","target":0},{"commit_id":"8794e8d229dc9fe29ea31424883433d4880ef408","func":"cluster_init (void)\n{\n  cluster_hash = hash_create (cluster_hash_key_make, cluster_hash_cmp);\n}\n","project":"savannah","target":0},{"commit_id":"d2f47191538837e796e2b10c1ff7e1ee35f6e0ab","func":"void SoftMPEG4::onQueueFilled(OMX_U32 \/* portIndex *\/) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n continue;\n }\n\n PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n ++mInputBufferCount;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n }\n return;\n }\n\n uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n uint32_t *start_code = (uint32_t *)bitstream;\n bool volHeader = *start_code == 0xB0010000;\n if (volHeader) {\n PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n }\n\n if (!mInitialized) {\n uint8_t *vol_data[1];\n int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n }\n\n            MP4DecodingMode mode =\n (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n bool hasFrameData = false;\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n } else if (volHeader) {\n                hasFrameData = true;\n }\n\n            mInitialized = true;\n\n if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n return;\n }\n\n if (!hasFrameData) {\n continue;\n }\n }\n\n if (!mFramesConfigured) {\n PortInfo *port = editPortInfo(1);\n            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n\n PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n\n            mFramesConfigured = true;\n }\n\n uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n uint32_t timestamp = 0xFFFFFFFF;\n if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n }\n\n\n         int32_t bufferSize = inHeader->nFilledLen;\n         int32_t tmp = bufferSize;\n \n if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n\n if (handlePortSettingsChange()) {\n return;\n }\n\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n } else {\n            outHeader->nFlags = 0;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n\n         ++mInputBufferCount;\n \n         outHeader->nOffset = 0;\n        outHeader->nFilledLen = (mWidth * mHeight * 3) \/ 2;\n \n         List<BufferInfo *>::iterator it = outQueue.begin();\n         while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mNumSamplesOutput;\n }\n}\n","project":"Android","target":1},{"commit_id":"83d4dae44c71816c084a635550acc1a51529b881","func":"fz_set_default_cmyk(fz_context *ctx, fz_default_colorspaces *default_cs, fz_colorspace *cs)\n{\n\tif (cs->n == 4)\n\t{\n\t\tfz_drop_colorspace(ctx, default_cs->cmyk);\n\t\tdefault_cs->cmyk = fz_keep_colorspace(ctx, cs);\n\t}\n}\n","project":"ghostscript","target":0},{"commit_id":"f597300439e62f5e921f0d7b1e880b5c1a1f1607","func":"move_to_root(cmap_splay *tree, unsigned int x)\n{\n\tif (x == EMPTY)\n\t\treturn;\n\tdo\n\t{\n\t\tunsigned int z, zp;\n\t\tunsigned int y = tree[x].parent;\n\t\tif (y == EMPTY)\n\t\t\tbreak;\n\t\tz = tree[y].parent;\n\t\tif (z == EMPTY)\n\t\t{\n\t\t\t\/* Case 3 *\/\n\t\t\ttree[x].parent = EMPTY;\n\t\t\ttree[y].parent = x;\n\t\t\tif (tree[y].left == x)\n\t\t\t{\n\t\t\t\t\/* Case 3 *\/\n\t\t\t\ttree[y].left = tree[x].right;\n\t\t\t\tif (tree[y].left != EMPTY)\n\t\t\t\t\ttree[tree[y].left].parent = y;\n\t\t\t\ttree[x].right = y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\/* Case 3 - reflected *\/\n\t\t\t\tassert(tree[y].right == x);\n\t\t\t\ttree[y].right = tree[x].left;\n\t\t\t\tif (tree[y].right != EMPTY)\n\t\t\t\t\ttree[tree[y].right].parent = y;\n\t\t\t\ttree[x].left = y;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tzp = tree[z].parent;\n\t\ttree[x].parent = zp;\n\t\tif (zp != EMPTY) {\n\t\t\tif (tree[zp].left == z)\n\t\t\t\ttree[zp].left = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(tree[zp].right == z);\n\t\t\t\ttree[zp].right = x;\n\t\t\t}\n\t\t}\n\t\ttree[y].parent = x;\n\t\tif (tree[y].left == x)\n\t\t{\n\t\t\ttree[y].left = tree[x].right;\n\t\t\tif (tree[y].left != EMPTY)\n\t\t\t\ttree[tree[y].left].parent = y;\n\t\t\ttree[x].right = y;\n\t\t\tif (tree[z].left == y)\n\t\t\t{\n\t\t\t\t\/* Case 1 *\/\n\t\t\t\ttree[z].parent = y;\n\t\t\t\ttree[z].left = tree[y].right;\n\t\t\t\tif (tree[z].left != EMPTY)\n\t\t\t\t\ttree[tree[z].left].parent = z;\n\t\t\t\ttree[y].right = z;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\/* Case 2 - reflected *\/\n\t\t\t\tassert(tree[z].right == y);\n\t\t\t\ttree[z].parent = x;\n\t\t\t\ttree[z].right = tree[x].left;\n\t\t\t\tif (tree[z].right != EMPTY)\n\t\t\t\t\ttree[tree[z].right].parent = z;\n\t\t\t\ttree[x].left = z;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(tree[y].right == x);\n\t\t\ttree[y].right = tree[x].left;\n\t\t\tif (tree[y].right != EMPTY)\n\t\t\t\ttree[tree[y].right].parent = y;\n\t\t\ttree[x].left = y;\n\t\t\tif (tree[z].left == y)\n\t\t\t{\n\t\t\t\t\/* Case 2 *\/\n\t\t\t\ttree[z].parent = x;\n\t\t\t\ttree[z].left = tree[x].right;\n\t\t\t\tif (tree[z].left != EMPTY)\n\t\t\t\t\ttree[tree[z].left].parent = z;\n\t\t\t\ttree[x].right = z;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\/* Case 1 - reflected *\/\n\t\t\t\tassert(tree[z].right == y);\n\t\t\t\ttree[z].parent = y;\n\t\t\t\ttree[z].right = tree[y].left;\n\t\t\t\tif (tree[z].right != EMPTY)\n\t\t\t\t\ttree[tree[z].right].parent = z;\n\t\t\t\ttree[y].left = z;\n\t\t\t}\n\t\t}\n\t} while (1);\n}\n","project":"ghostscript","target":0},{"commit_id":"295c883fe3105b19bcd0f9e07d54c6b589fc5bff","func":"OMX_ERRORTYPE SoftOpus::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch ((int)index) {\n case OMX_IndexParamAudioAndroidOpus:\n {\n\n             OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *opusParams =\n                 (OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *)params;\n \n             if (opusParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            opusParams->nAudioBandWidth = 0;\n            opusParams->nSampleRate = kRate;\n            opusParams->nBitRate = 0;\n\n if (!isConfigured()) {\n                opusParams->nChannels = 1;\n } else {\n                opusParams->nChannels = mHeader->channels;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n            pcmParams->nSamplingRate = kRate;\n\n if (!isConfigured()) {\n                pcmParams->nChannels = 1;\n } else {\n                pcmParams->nChannels = mHeader->channels;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n","project":"Android","target":1},{"commit_id":"ca8ac8acdad662230ae37998c6c4091bb39402b6","func":"bool CmapCoverage::getCoverage(SparseBitSet& coverage, const uint8_t* cmap_data, size_t cmap_size) {\n vector<uint32_t> coverageVec;\n const size_t kHeaderSize = 4;\n const size_t kNumTablesOffset = 2;\n const size_t kTableSize = 8;\n\n     const size_t kPlatformIdOffset = 0;\n     const size_t kEncodingIdOffset = 2;\n     const size_t kOffsetOffset = 4;\n    const int kMicrosoftPlatformId = 3;\n    const int kUnicodeBmpEncodingId = 1;\n    const int kUnicodeUcs4EncodingId = 10;\n     if (kHeaderSize > cmap_size) {\n         return false;\n     }\n    int numTables = readU16(cmap_data, kNumTablesOffset);\n     if (kHeaderSize + numTables * kTableSize > cmap_size) {\n         return false;\n     }\n    int bestTable = -1;\n    for (int i = 0; i < numTables; i++) {\n         uint16_t platformId = readU16(cmap_data, kHeaderSize + i * kTableSize + kPlatformIdOffset);\n         uint16_t encodingId = readU16(cmap_data, kHeaderSize + i * kTableSize + kEncodingIdOffset);\n         if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeUcs4EncodingId) {\n            bestTable = i;\n break;\n } else if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeBmpEncodingId) {\n            bestTable = i;\n }\n }\n\n #ifdef PRINTF_DEBUG\n     printf(\"best table = %d\\n\", bestTable);\n #endif\n    if (bestTable < 0) {\n         return false;\n     }\n     uint32_t offset = readU32(cmap_data, kHeaderSize + bestTable * kTableSize + kOffsetOffset);\n    if (offset + 2 > cmap_size) {\n         return false;\n     }\n     uint16_t format = readU16(cmap_data, offset);\n bool success = false;\n const uint8_t* tableData = cmap_data + offset;\n const size_t tableSize = cmap_size - offset;\n if (format == 4) {\n        success = getCoverageFormat4(coverageVec, tableData, tableSize);\n } else if (format == 12) {\n        success = getCoverageFormat12(coverageVec, tableData, tableSize);\n }\n if (success) {\n        coverage.initFromRanges(&coverageVec.front(), coverageVec.size() >> 1);\n }\n#ifdef PRINTF_DEBUG\n for (int i = 0; i < coverageVec.size(); i += 2) {\n        printf(\"%x:%x\\n\", coverageVec[i], coverageVec[i + 1]);\n }\n#endif\n return success;\n}\n","project":"Android","target":1},{"commit_id":"5a9753fca56f0eeb9f61e342b2fccffc364f9426","func":"int main(int argc, char **argv) {\n ::testing::InitGoogleTest(&argc, argv);\n\n\n #if ARCH_X86 || ARCH_X86_64\n   const int simd_caps = x86_simd_caps();\n   if (!(simd_caps & HAS_MMX))\n    append_negative_gtest_filter(\":MMX\/*\");\n   if (!(simd_caps & HAS_SSE))\n    append_negative_gtest_filter(\":SSE\/*\");\n   if (!(simd_caps & HAS_SSE2))\n    append_negative_gtest_filter(\":SSE2\/*\");\n   if (!(simd_caps & HAS_SSE3))\n    append_negative_gtest_filter(\":SSE3\/*\");\n   if (!(simd_caps & HAS_SSSE3))\n    append_negative_gtest_filter(\":SSSE3\/*\");\n   if (!(simd_caps & HAS_SSE4_1))\n    append_negative_gtest_filter(\":SSE4_1\/*\");\n   if (!(simd_caps & HAS_AVX))\n    append_negative_gtest_filter(\":AVX\/*\");\n   if (!(simd_caps & HAS_AVX2))\n    append_negative_gtest_filter(\":AVX2\/*\");\n #endif\n \n #if !CONFIG_SHARED\n\n \n #if CONFIG_VP8\n   vp8_rtcd();\n#endif\n #if CONFIG_VP9\n   vp9_rtcd();\n#endif\n#endif\n \n   return RUN_ALL_TESTS();\n }\n","project":"Android","target":1},{"commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda2","func":"int phar_mount_entry(phar_archive_data *phar, char *filename, int filename_len, char *path, int path_len TSRMLS_DC) \/* {{{ *\/\n{\n\tphar_entry_info entry = {0};\n\tphp_stream_statbuf ssb;\n\tint is_phar;\n\tconst char *err;\n\n\tif (phar_path_check(&path, &path_len, &err) > pcr_is_ok) {\n\t\treturn FAILURE;\n\t}\n\n\tif (path_len >= sizeof(\".phar\")-1 && !memcmp(path, \".phar\", sizeof(\".phar\")-1)) {\n\t\t\/* no creating magic phar files by mounting them *\/\n\t\treturn FAILURE;\n\t}\n\n\tis_phar = (filename_len > 7 && !memcmp(filename, \"phar:\/\/\", 7));\n\n\tentry.phar = phar;\n\tentry.filename = estrndup(path, path_len);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(entry.filename, path_len);\n#endif\n\tentry.filename_len = path_len;\n\tif (is_phar) {\n\t\tentry.tmp = estrndup(filename, filename_len);\n\t} else {\n\t\tentry.tmp = expand_filepath(filename, NULL TSRMLS_CC);\n\t\tif (!entry.tmp) {\n\t\t\tentry.tmp = estrndup(filename, filename_len);\n\t\t}\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && !is_phar && (!php_checkuid(entry.tmp, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\tefree(entry.tmp);\n\t\tefree(entry.filename);\n\t\treturn FAILURE;\n\t}\n#endif\n\tfilename = entry.tmp;\n\n\t\/* only check openbasedir for files, not for phar streams *\/\n\tif (!is_phar && php_check_open_basedir(filename TSRMLS_CC)) {\n\t\tefree(entry.tmp);\n\t\tefree(entry.filename);\n\t\treturn FAILURE;\n\t}\n\n\tentry.is_mounted = 1;\n\tentry.is_crc_checked = 1;\n\tentry.fp_type = PHAR_TMP;\n\n\tif (SUCCESS != php_stream_stat_path(filename, &ssb)) {\n\t\tefree(entry.tmp);\n\t\tefree(entry.filename);\n\t\treturn FAILURE;\n\t}\n\n\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\tentry.is_dir = 1;\n\t\tif (SUCCESS != zend_hash_add(&phar->mounted_dirs, entry.filename, path_len, (void *)&(entry.filename), sizeof(char *), NULL)) {\n\t\t\t\/* directory already mounted *\/\n\t\t\tefree(entry.tmp);\n\t\t\tefree(entry.filename);\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\tentry.is_dir = 0;\n\t\tentry.uncompressed_filesize = entry.compressed_filesize = ssb.sb.st_size;\n\t}\n\n\tentry.flags = ssb.sb.st_mode;\n\n\tif (SUCCESS == zend_hash_add(&phar->manifest, entry.filename, path_len, (void*)&entry, sizeof(phar_entry_info), NULL)) {\n\t\treturn SUCCESS;\n\t}\n\n\tefree(entry.tmp);\n\tefree(entry.filename);\n\treturn FAILURE;\n}\n\/* }}} *\/\n","project":"php","target":0},{"commit_id":"c351b47ce85a3a147cfa801fa9f0149ab4160834","func":"PHPAPI pcre_cache_entry* pcre_get_compiled_regex_cache(char *regex, int regex_len TSRMLS_DC)\n{\n\tpcre\t\t\t\t*re = NULL;\n\tpcre_extra\t\t\t*extra;\n\tint\t\t\t\t\t coptions = 0;\n\tint\t\t\t\t\t soptions = 0;\n\tconst char\t\t\t*error;\n\tint\t\t\t\t\t erroffset;\n\tchar\t\t\t\t delimiter;\n\tchar\t\t\t\t start_delimiter;\n\tchar\t\t\t\t end_delimiter;\n\tchar\t\t\t\t*p, *pp;\n\tchar\t\t\t\t*pattern;\n\tint\t\t\t\t\t do_study = 0;\n\tint\t\t\t\t\t poptions = 0;\n\tint\t\t\t\tcount = 0;\n\tunsigned const char *tables = NULL;\n#if HAVE_SETLOCALE\n\tchar\t\t\t\t*locale;\n#endif\n\tpcre_cache_entry\t*pce;\n\tpcre_cache_entry\t new_entry;\n\tchar                *tmp = NULL;\n\n#if HAVE_SETLOCALE\n# if defined(PHP_WIN32) && defined(ZTS)\n\t_configthreadlocale(_ENABLE_PER_THREAD_LOCALE);\n# endif\n\tlocale = setlocale(LC_CTYPE, NULL);\n#endif\n\n\t\/* Try to lookup the cached regex entry, and if successful, just pass\n\t   back the compiled pattern, otherwise go on and compile it. *\/\n\tif (zend_hash_find(&PCRE_G(pcre_cache), regex, regex_len+1, (void **)&pce) == SUCCESS) {\n\t\t\/*\n\t\t * We use a quick pcre_fullinfo() check to see whether cache is corrupted, and if it\n\t\t * is, we flush it and compile the pattern from scratch.\n\t\t *\/\n\t\tif (pcre_fullinfo(pce->re, NULL, PCRE_INFO_CAPTURECOUNT, &count) == PCRE_ERROR_BADMAGIC) {\n\t\t\tzend_hash_clean(&PCRE_G(pcre_cache));\n\t\t} else {\n#if HAVE_SETLOCALE\n\t\t\tif (!strcmp(pce->locale, locale)) {\n#endif\n\t\t\t\treturn pce;\n#if HAVE_SETLOCALE\n\t\t\t}\n#endif\n\t\t}\n\t}\n\t\n\tp = regex;\n\t\n\t\/* Parse through the leading whitespace, and display a warning if we\n\t   get to the end without encountering a delimiter. *\/\n\twhile (isspace((int)*(unsigned char *)p)) p++;\n\tif (*p == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \n\t\t\t\t\t\t p < regex + regex_len ? \"Null byte in regex\" : \"Empty regular expression\");\n\t\treturn NULL;\n\t}\n\t\n\t\/* Get the delimiter and display a warning if it is alphanumeric\n\t   or a backslash. *\/\n\tdelimiter = *p++;\n\tif (isalnum((int)*(unsigned char *)&delimiter) || delimiter == '\\\\') {\n\t\tphp_error_docref(NULL TSRMLS_CC,E_WARNING, \"Delimiter must not be alphanumeric or backslash\");\n\t\treturn NULL;\n\t}\n\n\tstart_delimiter = delimiter;\n\tif ((pp = strchr(\"([{< )]}> )]}>\", delimiter)))\n","project":"php","target":0}]